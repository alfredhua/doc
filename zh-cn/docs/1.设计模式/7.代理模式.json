{
  "filename": "7.代理模式.md",
  "__html": "<p>静态代理:</p>\n<p>静态代理不需要接口，只是一个代理对象拿到了被代理对象的引用，有代理对象调用被代理对象而已。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> Son son;\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Father</span><span class=\"hljs-params\">(Son son)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.son=son;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">findSonLove</span><span class=\"hljs-params\">()</span></span>{\n        System.out.println(<span class=\"hljs-string\">\"代理前-----------\"</span>);\n        son.findLove();\n        System.out.println(<span class=\"hljs-string\">\"被代理后---------\"</span>);\n    }\n}\n\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Son</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">findLove</span><span class=\"hljs-params\">()</span></span>{\n        System.out.println(<span class=\"hljs-string\">\"son 被代理\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StaticTest</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>{\n            <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-keyword\">new</span> Son()).findSonLove();\n    }\n}\n\n\n</code></pre>\n<p>动态代理：JKD和CGLIB俩种方式</p>\n<p>JDK动态代理：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span>  <span class=\"hljs-title\">Person</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">findLove</span><span class=\"hljs-params\">()</span></span>;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eat</span><span class=\"hljs-params\">()</span></span>;\n}\n\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MeiPoProxy</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">InvocationHandler</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> Person person;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">(Person person)</span></span>{\n        <span class=\"hljs-keyword\">this</span>.person=person;\n        Class&lt;? extends Person&gt; aClass = person.getClass();\n        <span class=\"hljs-keyword\">return</span> Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), aClass.getInterfaces(), <span class=\"hljs-keyword\">this</span>);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(Object proxy, Method method, Object[] args)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n        System.out.println(<span class=\"hljs-string\">\"被代理前----------------\"</span>);\n        method.invoke(<span class=\"hljs-keyword\">this</span>.person, args);\n        System.out.println(<span class=\"hljs-string\">\"被代理后--------------\"</span>);\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeBody</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Person</span> </span>{\n\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">findLove</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"some body 被代理\"</span>);\n\n    }\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eat</span><span class=\"hljs-params\">()</span> </span>{\n\n    }\n}\n\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JDKProxyTest</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        <span class=\"hljs-keyword\">try</span> {\n            Person obj = (Person)<span class=\"hljs-keyword\">new</span> JDK58().getInstance(<span class=\"hljs-keyword\">new</span> XieMu());\n            System.out.println(obj.getClass());\n            obj.findJob();\n            <span class=\"hljs-comment\">//原理：</span>\n            <span class=\"hljs-comment\">//1、拿到被代理对象的引用，并且获取到它的所有的接口，反射获取</span>\n            <span class=\"hljs-comment\">//2、JDK Proxy类重新生成一个新的类、同时新的类要实现被代理类所有实现的所有的接口</span>\n            <span class=\"hljs-comment\">//3、动态生成Java代码，把新加的业务逻辑方法由一定的逻辑代码去调用（在代码中体现）</span>\n            <span class=\"hljs-comment\">//4、编译新生成的Java代码.class</span>\n            <span class=\"hljs-comment\">//5、再重新加载到JVM中运行</span>\n            <span class=\"hljs-comment\">//以上这个过程就叫字节码重组</span>\n\n            <span class=\"hljs-comment\">//JDK中有个规范，只要要是$开头的一般都是自动生成的</span>\n\n            <span class=\"hljs-comment\">//通过反编译工具可以查看源代码</span>\n            <span class=\"hljs-keyword\">byte</span> [] bytes = ProxyGenerator.generateProxyClass(<span class=\"hljs-string\">\"$Proxy0\"</span>,<span class=\"hljs-keyword\">new</span> Class[]{Person<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>})</span>;\n            FileOutputStream os = <span class=\"hljs-keyword\">new</span> FileOutputStream(<span class=\"hljs-string\">\"E://$Proxy0.class\"</span>);\n            os.write(bytes);\n            os.close();\n\n        } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n\n</code></pre>\n<p>CGLIB动态代理:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeBody</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Person</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">findLove</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"some body 被代理\"</span>);\n\n    }\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eat</span><span class=\"hljs-params\">()</span> </span>{\n\n    }\n}\n\n\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CglibProxy</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">MethodInterceptor</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">(Class clazz)</span></span>{\n        Enhancer enhancer=<span class=\"hljs-keyword\">new</span> Enhancer();\n        enhancer.setSuperclass(clazz);\n        enhancer.setCallback(<span class=\"hljs-keyword\">this</span>);\n        <span class=\"hljs-keyword\">return</span> enhancer.create();\n\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">intercept</span><span class=\"hljs-params\">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n        System.out.println(<span class=\"hljs-string\">\"被代理前------------\"</span>);\n        methodProxy.invokeSuper(o, objects);\n        System.out.println(<span class=\"hljs-string\">\"被代理后------------\"</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n    }\n\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CglibTest</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>{\n        CglibProxy cglibProxy=<span class=\"hljs-keyword\">new</span> CglibProxy();\n        Person instance =(Person) cglibProxy.getInstance(SomeBody<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n        instance.findLove();\n    }\n}\n\n\n</code></pre>\n<p>自己动手实现动态代理：\n动态代理之所以是动态的，是因为代理之前，也不知道代理的是什么，只有在代码运行时才知道，所以就需要动态的生成中间代理，然后进行代理。</p>\n<p>实现方式:</p>\n<ol>\n<li>动态生成源代码.java文件。</li>\n<li>JAVA文件输出到磁盘。</li>\n<li>把自己生成的java文件编辑成class文件。</li>\n<li>将编译的class文件加载到JVM中。</li>\n<li>返回的字节码重组成新的对象。</li>\n</ol>\n<pre><code class=\"language-java\">public class CustomerMeiPoProxy implements HuaIncationHandle {\n\n\n    private Person person;\n\n    public Object getInstance(Person person){\n        this.person=person;\n        Class&lt;? extends Person&gt; aClass = person.getClass();\n        return HuaProxy.newProxyInstance(new HuaClassLoader(), aClass.getInterfaces(), this);\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"被代理前-------------------\");\n\n        method.invoke(person, args);\n        System.out.println(\"被代理后-------------------\");\n        return null;\n    }\n}\n\n\npublic class HuaClassLoader  extends ClassLoader{\n\n    private File classPathFile;\n\n    public HuaClassLoader() {\n        String classPath = HuaClassLoader.class.getResource(\"\").getPath();\n        this.classPathFile = new File(classPath);\n    }\n\n    @Override\n    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {\n        String className = HuaClassLoader.class.getPackage().getName() + \".\" + name;\n\n        if (classPathFile != null){\n            File classFile = new File(classPathFile,name.replaceAll(\"\\\\.\",\"/\") + \".class\");\n            if (classFile.exists()){\n\n                FileInputStream inputStream = null;\n                ByteArrayOutputStream outputStream=null;\n\n\n                try {\n                    inputStream=new FileInputStream(classFile);\n                    outputStream=new ByteArrayOutputStream();\n                    byte [] buff = new byte[1024];\n                    int len;\n                    while((len=inputStream.read(buff))!=-1){\n                        outputStream.write(buff,0,len);\n                    }\n                    return  defineClass(className,outputStream.toByteArray(),0,outputStream.size());\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }else {\n\n            return null;\n        }\n        return null;\n    }\n}\n\npublic interface HuaIncationHandle {\n\n     Object invoke(Object proxy, Method method, Object[] args) throws Throwable;\n\n}\n\npublic class HuaProxy {\n\n\n    private static String ln=\"\\r\\n\";\n\n    public static Object newProxyInstance(HuaClassLoader loader,Class&lt;?&gt;[] interfaces, HuaIncationHandle h){\n\n        //1.动态的生成java文件。\n        try {\n            String s = generaterStr(interfaces);\n\n            //2.输出到磁盘上，\n            String path = HuaProxy.class.getResource(\"\").getPath();\n            System.out.println(path+\"------\");\n            File file = new File(path + \"$Proxy0.java\");\n\n            FileWriter fileWriter = new FileWriter(file);\n            fileWriter.write(s);\n            fileWriter.flush();\n            fileWriter.close();\n\n            //3.编译成class文件。\n            JavaCompiler systemJavaCompiler = ToolProvider.getSystemJavaCompiler();\n            StandardJavaFileManager standardFileManager = systemJavaCompiler.getStandardFileManager(null, null, null);\n\n            Iterable&lt;? extends JavaFileObject&gt; javaFileObjects = standardFileManager.getJavaFileObjects(file);\n            JavaCompiler.CompilationTask task = systemJavaCompiler.getTask(null,standardFileManager,null,null,null,javaFileObjects);\n            task.call();\n            standardFileManager.close();\n\n            //4.加载到JVM中。\n            Class&lt;?&gt; proxyClass = loader.findClass(\"$Proxy0\");\n            Constructor c = proxyClass.getConstructor(HuaIncationHandle.class);\n            //5.返回字节码重组以后的新的代理对象\n            return c.newInstance(h);\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private static String generaterStr(Class&lt;?&gt;[] interfaces) {\n        StringBuffer sb=new StringBuffer();\n\n        sb.append(\"package com.gpxy.proxy.custome;\"+ln);\n        sb.append(\"import com.gpxy.proxy.Person;\" + ln);\n        sb.append(\"import java.lang.reflect.Method;\" + ln);\n\n        sb.append(\"public class $Proxy0 implements \"+interfaces[0].getName()+\"{\"+ln );\n\n            sb.append(\" HuaIncationHandle  h; \"+ln);\n\n            sb.append(\" public $Proxy0 (HuaIncationHandle h){\"+ln);\n                    sb.append(\"this.h=h;\"+ln);\n            sb.append(\"}\"+ln);\n\n        for ( Method method :interfaces[0].getMethods()){\n                sb.append(\" public \"+method.getReturnType().getName()+\" \"+method.getName()+\"(){\" +ln);\n                                sb.append(\"try{\"+ln);\n                                     sb.append(\"Method m = \" + interfaces[0].getName() + \".class.getMethod(\\\"\" + method.getName() + \"\\\",new Class[]{});\" + ln);\n                                     sb.append(\"this.h.invoke(this,m,null);\" + ln);\n                                sb.append(\"}catch(Throwable e){\"+ln);\n                                     sb.append(\"e.printStackTrace();\" + ln);\n                                sb.append(\"}\"+ln);\n                sb.append(\"}\"+ln);\n             }\n        sb.append(\"}\"+ln);\n\n        return sb.toString();\n    }\n}\n\npublic class SomeBody implements Person {\n\n\n    @Override\n    public void findLove() {\n        System.out.println(\"some body 被代理\");\n\n    }\n    @Override\n    public void eat() {\n\n    }\n}\n\npublic class CustomerProxyTest {\n    public static void main(String[] args){\n        CustomerMeiPoProxy customerMeiPoProxy=new CustomerMeiPoProxy();\n        Person instance =(Person) customerMeiPoProxy.getInstance(new SomeBody());\n        instance.findLove();\n    }\n}\n</code></pre>\n",
  "link": "/zh-cn/docs/1.设计模式/7.代理模式.html",
  "meta": {
    "title": "代理模式-码农阿华",
    "keywords": "静态代理，动态代理，代理模式，设计模式",
    "description": "静态代理：静态代理不需要接口，只是一个代理对象拿到了被代理对象的引用，有代理对象调用被代理对象而已。动态代理：JKD和CGLIB俩种方式"
  }
}