{
  "filename": "2.dashboard.md",
  "__html": "<h2 id=\"dashboard\">dashboard <a class=\"header-anchor\" href=\"#dashboard\">#</a></h2>\n<blockquote>\n<p>当前系统的实时数据面板，按 ctrl+c 退出。</p>\n</blockquote>\n<p><img src=\"https://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/blog/image-20201104225026358.png\" alt=\"image-20201104225026358\"></p>\n<ul>\n<li>ID: Java级别的线程ID，注意这个ID不能跟jstack中的nativeID一一对应。</li>\n<li>NAME: 线程名</li>\n<li>GROUP: 线程组名</li>\n<li>PRIORITY: 线程优先级, 1~10之间的数字，越大表示优先级越高</li>\n<li>STATE: 线程的状态</li>\n<li>CPU%: 线程的cpu使用率。比如采样间隔1000ms，某个线程的增量cpu时间为100ms，则cpu使用率=100/1000=10%</li>\n<li>DELTA_TIME: 上次采样之后线程运行增量CPU时间，数据格式为<code>秒</code></li>\n<li>TIME: 线程运行总CPU时间，数据格式为<code>分:秒</code></li>\n<li>INTERRUPTED: 线程当前的中断位状态</li>\n<li>DAEMON: 是否是daemon线程</li>\n</ul>\n<p>JVM内部线程</p>\n<p>Java 8之后支持获取JVM内部线程CPU时间，这些线程只有名称和CPU时间，没有ID及状态等信息（显示ID为-1）。 通过内部线程可以观测到JVM活动，如GC、JIT编译等占用CPU情况，方便了解JVM整体运行状况。</p>\n<ul>\n<li>当JVM 堆(heap)/元数据(metaspace)空间不足或OOM时，可以看到GC线程的CPU占用率明显高于其他的线程。</li>\n<li>当执行<code>trace/watch/tt/redefine</code>等命令后，可以看到JIT线程活动变得更频繁。因为JVM热更新class字节码时清除了此class相关的JIT编译结果，需要重新编译。</li>\n</ul>\n<p>JVM内部线程包括下面几种：</p>\n<ul>\n<li>JIT编译线程: 如 <code>C1 CompilerThread0</code>, <code>C2 CompilerThread0</code></li>\n<li>GC线程: 如<code>GC Thread0</code>, <code>G1 Young RemSet Sampling</code></li>\n<li>其它内部线程: 如<code>VM Periodic Task Thread</code>, <code>VM Thread</code>, <code>Service Thread</code></li>\n</ul>\n",
  "link": "/zh-cn/docs/10.工具/arthas/2.dashboard.html",
  "meta": {}
}