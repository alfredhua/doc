{
  "filename": "9.常见问题.md",
  "__html": "<h2 id=\"%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%8F%91%E7%94%9F%E7%9A%84%E6%97%B6%E6%9C%BA%EF%BC%9F\">垃圾收集发生的时机？ <a class=\"header-anchor\" href=\"#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%8F%91%E7%94%9F%E7%9A%84%E6%97%B6%E6%9C%BA%EF%BC%9F\">#</a></h2>\n<pre><code>GC是由JVM自动完成的，根据JVM系统环境而定，所以时机是不确定的。 当然，我们可以手动进行垃圾回收， 比如调用System.gc()方法通知JVM进行一次垃圾回收，但是具体什么时刻运行也无法控制。也就是说 System.gc()只是通知要回收，什么时候回收由JVM决定。 但是不建议手动调用该方法，因为消耗的资源比较大。  \n\n一般以下几种情况会发生垃圾回收\n1. 当Eden区或者S区不够用了 \n2. 老年代空间不够用了\n3. 方法区空间不够用了 \n4. System.gc()\n</code></pre>\n<h2 id=\"%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8C%BA%E5%88%AB\">内存泄漏与内存溢出的区别 <a class=\"header-anchor\" href=\"#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8C%BA%E5%88%AB\">#</a></h2>\n<ul>\n<li>内存泄漏:对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。</li>\n<li>内存溢出:内存泄漏到一定的程度就会导致内存溢出，但是内存溢出也有可能是大对象导致的。</li>\n</ul>\n<h2 id=\"young-gc%E4%BC%9A%E6%9C%89stw%E5%90%97%3F\">young gc会有stw吗? <a class=\"header-anchor\" href=\"#young-gc%E4%BC%9A%E6%9C%89stw%E5%90%97%3F\">#</a></h2>\n<pre><code>不管什么 GC，都会有 stop-the-world，只是发生时间的长短。\n</code></pre>\n<h2 id=\"major-gc%E5%92%8Cfull-gc%E7%9A%84%E5%8C%BA%E5%88%AB\">major gc和full gc的区别 <a class=\"header-anchor\" href=\"#major-gc%E5%92%8Cfull-gc%E7%9A%84%E5%8C%BA%E5%88%AB\">#</a></h2>\n<pre><code>major gc指的是老年代的gc，而full gc等于young+old+metaspace的gc。\n</code></pre>\n<h2 id=\"g1%E4%B8%8Ecms%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88\">G1与CMS的区别是什么 <a class=\"header-anchor\" href=\"#g1%E4%B8%8Ecms%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88\">#</a></h2>\n<pre><code>CMS 用于老年代的回收，而 G1 用于新生代和老年代的回收。\n\nG1 使用了 Region 方式对堆内存进行了划分，且基于标记整理算法实现，整体减少了垃圾碎片的产生。\n</code></pre>\n<h2 id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98\">什么是直接内存 <a class=\"header-anchor\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98\">#</a></h2>\n<pre><code>直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于Java堆。因此出于性能的考 虑，读写频繁的场合可能会考虑使用直接内存。\n</code></pre>\n<h2 id=\"%E4%B8%8D%E5%8F%AF%E8%BE%BE%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%80%E5%AE%9A%E8%A6%81%E8%A2%AB%E5%9B%9E%E6%94%B6%E5%90%97%3F\">不可达的对象一定要被回收吗? <a class=\"header-anchor\" href=\"#%E4%B8%8D%E5%8F%AF%E8%BE%BE%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%80%E5%AE%9A%E8%A6%81%E8%A2%AB%E5%9B%9E%E6%94%B6%E5%90%97%3F\">#</a></h2>\n<pre><code>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对 象死亡，至少要经历两次标记过程;可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此 对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机 将这两种情况视为没有必要执行。\n</code></pre>\n<p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关 联，否则就会被真的回收。</p>\n<h2 id=\"%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E7%9A%84%E6%97%A0%E7%94%A8%E7%B1%BB%E5%9B%9E%E6%94%B6-%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BB%E8%A6%81%E5%9B%9E%E6%94%B6%E7%9A%84%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB%EF%BC%8C%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB%E7%9A%84%E5%91%A2%3F\">方法区中的无用类回收 方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢? <a class=\"header-anchor\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E7%9A%84%E6%97%A0%E7%94%A8%E7%B1%BB%E5%9B%9E%E6%94%B6-%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BB%E8%A6%81%E5%9B%9E%E6%94%B6%E7%9A%84%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB%EF%BC%8C%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB%E7%9A%84%E5%91%A2%3F\">#</a></h2>\n<pre><code>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满 足下面 3 个条件才能算是 “无用的类” :\n该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n加载该类的 ClassLoader 已经被回收。\n该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然 被回收。\n</code></pre>\n<h2 id=\"%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BC%95%E7%94%A8\">不同的引用 <a class=\"header-anchor\" href=\"#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BC%95%E7%94%A8\">#</a></h2>\n<pre><code>JDK1.2以后，Java对引用进行了扩充:强引用、软引用、弱引用和虚引用</code></pre>\n",
  "link": "/zh-cn/docs/2.java/jvm/9.常见问题.html",
  "meta": {
    "title": "常见问题-码农阿华",
    "keywords": "垃圾收集发生的时机？内存泄漏与内存溢出的区别?young gc会有stw吗?major gc和full gc的区别?G1与CMS的区别是什么?",
    "description": "垃圾收集发生的时机？内存泄漏与内存溢出的区别?young gc会有stw吗?major gc和full gc的区别?G1与CMS的区别是什么?"
  }
}