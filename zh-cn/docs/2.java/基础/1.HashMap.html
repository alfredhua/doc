<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="1.HashMap" />
	<meta name="description" content="1.HashMap" />
	<!-- 网页标签标题 -->
	<title>1.HashMap</title>
	<link rel="shortcut icon" href="/img/docsite.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a class="logo" href="/zh-cn/index.html"><span class="logo-normal">码农阿华| <span class="logo-desc">玩玩技术，说说产品</span></span></a><div class="search search-normal"><span class="icon-search"></span></div><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/begin.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/system/docs.png" class="front-img"/><span>文档</span><img src="/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>设计模式</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>设计原则<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/2.开闭原则.html" target="_self">开闭原则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/3.接口隔离原则.html" target="_self">接口隔离原则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>JAVA</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>目录<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dir/demo3.html" target="_self">示例3</a></li></ul></li></ul></li></ul></div><div class="doc-content markdown-body"><ul>
<li>HashMap的put方法：</li>
</ul>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>{
    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);
}
</code></pre>
<p>hash方法，计算出该存放的在数组中的位置（除以16求余道理一样）：</p>
<p>hashCode() 方法用于返回字符串的哈希码。
字符串对象的哈希码根据以下公式计算：
s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</p>
<p>使用 int 算法，这里 s[i] 是字符串的第 i 个字符，n 是字符串的长度，^ 表示求幂。空字符串的哈希值为 0。</p>
<p>h无符号位右移动 16位，相当于获取高16位，低16位舍去，
与h进行异或运算，则一定获取的是一个32位的数字。</p>
<pre><code class="language-java"><span class="hljs-comment">//h无符号位右移动 16位与h进行异或运算</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>{
    <span class="hljs-keyword">int</span> h;
    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);
}
</code></pre>
<ul>
<li>
<p>putVal方法：</p>
<p>tab[ (n - 1) &amp; hash]：n是tab的长度，则： (n - 1) &amp; hash：一定是一个小于n的数字。</p>
</li>
</ul>
<pre><code class="language-java">
<span class="hljs-comment">//肯定是一个小于n的数。</span>

<span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,
               <span class="hljs-keyword">boolean</span> evict)</span> </span>{
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;
    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)
    <span class="hljs-comment">//首次进来初始化tab大小， resize()是初始化tab的大小，确定阈值。</span>
        n = (tab = resize()).length;
    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)
    <span class="hljs-comment">//第一次放入value，Node在tab的第i个位置上</span>
        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);
    <span class="hljs-keyword">else</span> {
        Node&lt;K,V&gt; e; K k;
        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
            e = p;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)
           <span class="hljs-comment">//往红黑树中插入节点</span>
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">//遍历插入节点</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) {
                <span class="hljs-comment">//寻找到最后一个节点是null的时候，存放节点   </span>
                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) {
                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);
                    <span class="hljs-comment">//如果当前列表下的节点&gt;7的时候，转换成为二叉树</span>
                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>
                        treeifyBin(tab, hash);
                    <span class="hljs-keyword">break</span>;
                }
                <span class="hljs-comment">//如果不是的话，那么一直遍历循环。</span>
                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
                    <span class="hljs-keyword">break</span>;
                p = e;
            }
        }
        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// existing mapping for key</span>
            V oldValue = e.value;
            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)
                e.value = value;
            afterNodeAccess(e);
            <span class="hljs-keyword">return</span> oldValue;
        }
    }
    ++modCount;
    <span class="hljs-keyword">if</span> (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}


n = tab.length
(n - <span class="hljs-number">1</span>) &amp; hash



<span class="hljs-comment">//初始化大小，还有扩容</span>
<span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() {
    Node&lt;K,V&gt;[] oldTab = table;
    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;
    <span class="hljs-keyword">int</span> oldThr = threshold;
    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">//2的n次方必须小于1 &lt;&lt; 30------》2^30</span>
        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            <span class="hljs-keyword">return</span> oldTab;
        }
        <span class="hljs-comment">//DEFAULT_INITIAL_CAPACITY 默认大小是 1&lt;&lt;4位，即16。</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>
        newCap = oldThr;
    <span class="hljs-keyword">else</span> { <span class="hljs-comment">// zero initial threshold signifies using defaults</span>
        newCap = DEFAULT_INITIAL_CAPACITY;
        <span class="hljs-comment">//阈值时 DEFAULT_LOAD_FACTOR*16 =12 。 3/4。</span>
        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?
                  (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    <span class="hljs-meta">@SuppressWarnings</span>({<span class="hljs-string">"rawtypes"</span>,<span class="hljs-string">"unchecked"</span>})
    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];
    table = newTab;
    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) {
            Node&lt;K,V&gt; e;
            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) {
                oldTab[j] = <span class="hljs-keyword">null</span>;
                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)
                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);
                <span class="hljs-keyword">else</span> { <span class="hljs-comment">// preserve order</span>
                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;
                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;
                    Node&lt;K,V&gt; next;
                    <span class="hljs-keyword">do</span> {
                        next = e.next;
                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) {
                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)
                                loHead = e;
                            <span class="hljs-keyword">else</span>
                                loTail.next = e;
                            loTail = e;
                        }
                        <span class="hljs-keyword">else</span> {
                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)
                                hiHead = e;
                            <span class="hljs-keyword">else</span>
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);
                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) {
                        loTail.next = <span class="hljs-keyword">null</span>;
                        newTab[j] = loHead;
                    }
                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) {
                        hiTail.next = <span class="hljs-keyword">null</span>;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    <span class="hljs-keyword">return</span> newTab;
}
</code></pre>
<p>问题：</p>
<h2 id="1.%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E7%BA%A2%E9%BB%91%E6%A0%91%E9%98%88%E5%80%BC%E6%97%B68%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BD%AC%E6%8D%A2%E5%88%97%E8%A1%A8%E9%98%88%E5%80%BC%E6%98%AF6%E3%80%82%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F">1.列表转换红黑树阈值时8，红黑树转换列表阈值是6。为什么？ <a class="header-anchor" href="#1.%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E7%BA%A2%E9%BB%91%E6%A0%91%E9%98%88%E5%80%BC%E6%97%B68%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BD%AC%E6%8D%A2%E5%88%97%E8%A1%A8%E9%98%88%E5%80%BC%E6%98%AF6%E3%80%82%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F">#</a></h2>
<p>通过源码我们得知HashMap源码作者通过泊松分布算出，当桶中结点个数为8时，出现的几率是亿分之6的，因此常见的情况是桶中个数小于8的情况，此时链表的查询性能和红黑树相差不多，因为转化为树还需要时间和空间，所以此时没有转化成树的必要。</p>
<p>既然个数为8时发生的几率这么低，我们为什么还要当链表个数大于8时来树化来优化这几乎不会发生的场景呢？</p>
<p>首先我们要知道亿分之6这个几乎不可能的概率是建立在什么情况下的 答案是：建立在良好的hash算法情况下，例如String，Integer等包装类的hash算法、如果一旦发生桶中元素大于8，说明是不正常情况，可能采用了冲突较大的hash算法，此时桶中个数出现超过8的概率是非常大的，可能有n个key冲突在同一个桶中，此时再看链表的平均查询复杂度和红黑树的时间复杂度，就知道为什么要引入红黑树了，
举个例子，若hash算法写的不好，一个桶中冲突1024个key，使用链表平均需要查询512次，但是红黑树仅仅10次，红黑树的引入保证了在大量hash冲突的情况下，HashMap还具有良好的查询性能。
红黑树的时间复杂度：
红黑树的插入、删除和遍历的最坏时间复杂度都是log(n)，
列表的时间复杂度：n</p>
<h2 id="2.hashmap%E7%9A%84%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84%EF%BC%8C%E6%89%A9%E5%AE%B9%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F">2.hashMap的扩容过程是怎么样子的，扩容的大小是什么样的？ <a class="header-anchor" href="#2.hashmap%E7%9A%84%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84%EF%BC%8C%E6%89%A9%E5%AE%B9%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F">#</a></h2>
<p>那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16</em>0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。</p>
<h2 id="3.hash%E7%9A%84%E5%86%B2%E7%AA%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F">3.hash的冲突是如何处理的？ <a class="header-anchor" href="#3.hash%E7%9A%84%E5%86%B2%E7%AA%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F">#</a></h2>
<p>如果persons.put(“1”,”jack”);persons.put(“2”,”john”); 同时计算到的hash值都为123，那么jack先放在第一列的第一个位置Node-jack，persons.put(“2”,”john”);执行时会将Node-jack的next(Node) = Node(john)，Jack的下个节点将指向Node(john)。
那么取的时候呢，persons.get(“2”)，这个时候取得的hash值是123，即table[123]，这时table[123]其实是Node-jack，Key值不相等，取Node-jack的next下个Node，即Node-John，这时Key值相等了，然后返回对应的person.</p>
<h2 id="4.hashmap%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BC%9A%E5%BC%95%E5%8F%91%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F%EF%BC%88%E5%88%97%E8%A1%A8%E7%8E%AF%E8%B7%AF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E7%94%BB%E5%9B%BE%E8%AF%B4%E6%98%8E%EF%BC%89">4.hashMap的多线程的环境下会引发什么样的情况？（列表环路，为什么？画图说明） <a class="header-anchor" href="#4.hashmap%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BC%9A%E5%BC%95%E5%8F%91%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F%EF%BC%88%E5%88%97%E8%A1%A8%E7%8E%AF%E8%B7%AF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E7%94%BB%E5%9B%BE%E8%AF%B4%E6%98%8E%EF%BC%89">#</a></h2>
<ol>
<li>put的时候导致的多线程数据不一致。</li>
<li>多线程put后可能导致get死循环：</li>
</ol>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Entry[] newTable)</span> </span>{
     Entry[] src = table;                   <span class="hljs-comment">//src引用了旧的Entry数组</span>
     <span class="hljs-keyword">int</span> newCapacity = newTable.length;
     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; src.length; j++) { <span class="hljs-comment">//遍历旧的Entry数组</span>
         Entry&lt;K,V&gt; e = src[j];             <span class="hljs-comment">//取得旧Entry数组的每个元素</span>
         <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) {
             src[j] = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span>
             <span class="hljs-keyword">do</span> {
                 Entry&lt;K,V&gt; next = e.next;
                 <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="hljs-comment">//！！重新计算每个元素在数组中的位置</span>
                 e.next = newTable[i]; <span class="hljs-comment">//标记[1]</span>
                 newTable[i] = e;      <span class="hljs-comment">//将元素放在数组上</span>
                 e = next;             <span class="hljs-comment">//访问下一个Entry链上的元素</span>
             } <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>);
         }
     }
 }
</code></pre>
<ol>
<li>
<p>对索引数组中的元素遍历</p>
</li>
<li>
<p>对链表上的每一个节点遍历：用 next 取得要转移那个元素的下一个，将 e 转移到新 Hash 表的头部，使用头插法插入节点。</p>
</li>
<li>
<p>循环2，直到链表节点全部转移</p>
</li>
<li>
<p>循环1，直到所有索引数组全部转移
经过这几步，我们会发现转移的时候是逆序的。假如转移前链表顺序是1-&gt;2-&gt;3，那么转移后就会变成3-&gt;2-&gt;1。这时候就有点头绪了，死锁问题不就是因为1-&gt;2的同时2-&gt;1造成的吗？所以，HashMap 的死锁问题就出在这个transfer()函数上。
单线程情况下：</p>
<p>当线程1已经拿到了Key：3的下一个节点为key:7，
但是此时，线程1已经扩容完成，由于扩容要进行列表反转，此时的key:3的下一个节点已经指向了key：7。所以会导致死循环。</p>
</li>
</ol>
<h2 id="5.hashmap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E4%B8%BA%E4%BC%9A%E5%A6%82%E4%BD%95%EF%BC%9F">5.hashMap的初始化大小是多少？如果自定义初始化大小为会如何？ <a class="header-anchor" href="#5.hashmap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E4%B8%BA%E4%BC%9A%E5%A6%82%E4%BD%95%EF%BC%9F">#</a></h2>
<p>初始化大小是：16，</p>
<p>最大定义是2的30次方。超过这个大小则为2的30次方，
自定义为3 的话，则初始化大小为4，为最近的2的n次方。
如果HashMap需要放置1024个元素，由于没有设置容量初始大小，随着元素不断增加，容量7次被迫扩大，resize需要重建hash表，严重影响性能。</p>
<h2 id="6.%E4%B8%BA%E4%BB%80%E4%B9%88hashmap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E4%BC%9A%E8%AE%BE%E7%BD%AE%E4%B8%BA2%E7%9A%84n%E6%AC%A1%E6%96%B9%EF%BC%9F">6.为什么hashMap的初始化大小会设置为2的n次方？ <a class="header-anchor" href="#6.%E4%B8%BA%E4%BB%80%E4%B9%88hashmap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E4%BC%9A%E8%AE%BE%E7%BD%AE%E4%B8%BA2%E7%9A%84n%E6%AC%A1%E6%96%B9%EF%BC%9F">#</a></h2>
<p>为了减少hash碰撞，因为tab的存放位置是(n - 1) &amp; hash，2的n次方发生hash碰撞的几率要小，能均匀分布。
为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的 范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应 用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之 前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算 方法是“ (n - 1) &amp; hash ”。(n代表数组长度)。这也就解释了 HashMap 的长度为什么是2的幂次方。</p>
</div></section><footer class="footer-container"><div class="footer-body"><div class="cols-container"><div class="col col-12"><h3>码农阿华</h3><p>联系邮箱：alfredhua@aliyun.com</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/demo1.html" target="_self">概览</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd></dl></div></div><div class="copyright"><span>CopyRight©2019 版权所有 码农阿华 京ICP备19044364号</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>