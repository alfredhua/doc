{
  "filename": "2.integer.md",
  "__html": "<p>将 Integer对象i和j进行互换：</p>\n<pre><code>\npublic class IntegetTest {\n\n  public static void main(String[] args) {\n      Integer i=1,j=2;\n      swap(i,j);\n      System.out.println(&quot;i=&quot;+i+&quot;,j=&quot;+j);\n  }\n\n  private static void swap(Integer i,Integer j){\n    Integer tmp=j;\n    j=i;\n    i=tmp;\n  }\n}\n\n</code></pre>\n<p>以上是正常互换情形，但是输出结果却是：i=1,j=2\n未发生互换。</p>\n<p>解读：\n我们输入，Integer i=1；实际上的操作是 Integer i=Integer.value(1);\n此时我们可以看到Integer.value方法如下：</p>\n<pre><code>public static Integer valueOf(int i) {\n    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n\n</code></pre>\n<p>当i&gt;= IntegerCache.low即（-128） &amp;&amp; i &lt;= IntegerCache.high（127）\n是从 IntegerCache.cache对应的下标获取值。即 -128到127存放在cache下标为：0到256的位置上。\n所以，我们在进行</p>\n<pre><code> private static void swap(Integer i,Integer j){\n    Integer tmp=j;\n    j=i;\n    i=tmp;\n  }\n</code></pre>\n<p>操作时，实际上是获取的Integer.cache中的对应的下标值，所以并没有发生变化。\n由此可以发现：\n在-128到127之间，我们进行互换操作时，不受影响，但是其他的值会发生变化。</p>\n<pre><code>private static void swap(Integer i,Integer j) throws NoSuchFieldException, IllegalAccessException {\n  Field value = i.getClass().getDeclaredField(&quot;value&quot;);\n  value.setAccessible(true);\n  int tmp=i;\n  value.set(i,j);\n  System.out.println(tmp);\n  value.set(j, new Integer(tmp));\n}\n\n\n</code></pre>\n<p>new Integer(tmp)的时候才会把int类型的值传递给Integer中的value属性。</p>\n<p>反射：\nvalue.setAccessible(true);\n会设置override属性为true</p>\n<pre><code>private static void setAccessible0(AccessibleObject obj, boolean flag)\n    throws SecurityException\n{\n    if (obj instanceof Constructor &amp;&amp; flag == true) {\n        Constructor&lt;?&gt; c = (Constructor&lt;?&gt;)obj;\n        if (c.getDeclaringClass() == Class.class) {\n            throw new SecurityException(&quot;Cannot make a java.lang.Class&quot; +\n                                        &quot; constructor accessible&quot;);\n        }\n    }\n    obj.override = flag;\n}\n\npublic void set(Object obj, Object value)\n    throws IllegalArgumentException, IllegalAccessException\n{\n    if (!override) {\n        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {\n            Class&lt;?&gt; caller = Reflection.getCallerClass();\n            checkAccess(caller, clazz, obj, modifiers);\n        }\n    }\n    getFieldAccessor(obj).set(obj, value);\n}\n\n</code></pre>\n<p>我们在调用Set方法时候可以看到会先判断override属性，如果是true的话才允许设置。</p>\n",
  "link": "/zh-cn/docs/2.java/基础/2.integer.html",
  "meta": {}
}