{
  "filename": "6.原子类.md",
  "__html": "<h2 id=\"juc-%E5%8C%85%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%98%AF%E5%93%AA4%E7%B1%BB%3F\">JUC 包中的原子类是哪4类? <a class=\"header-anchor\" href=\"#juc-%E5%8C%85%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%98%AF%E5%93%AA4%E7%B1%BB%3F\">#</a></h2>\n<p>基本类型：</p>\n<p>使用原子的方式更新基本类型</p>\n<ul>\n<li>AtomicInteger:整形原子类</li>\n<li>AtomicLong:长整型原子类</li>\n<li>AtomicBoolean :布尔型原子类</li>\n</ul>\n<p>数组类型：</p>\n<p>使用原子的方式更新数组里的某个元素</p>\n<ul>\n<li>AtomicIntegerArray:整形数组原子类</li>\n<li>AtomicLongArray:长整形数组原子类</li>\n<li>AtomicReferenceArray :引用类型数组原子类</li>\n</ul>\n<p>引用类型：</p>\n<ul>\n<li>AtomicReference:引用类型原子类</li>\n<li>AtomicStampedRerence:原子更新引用类型里的字段原子类</li>\n<li>AtomicMarkableReference :原子更新带有标记位的引用类型</li>\n</ul>\n<p>对象的属性修改类型 ：</p>\n<ul>\n<li>AtomicIntegerFieldUpdater:原子更新整形字段的更新器</li>\n<li>AtomicLongFieldUpdater:原子更新长整形字段的更新器</li>\n<li>AtomicStampedReference :原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原 子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>\n</ul>\n<blockquote>\n<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>\n</blockquote>\n<blockquote>\n<p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的objectFieldOffset() 方法 是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变 量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>\n</blockquote>\n",
  "link": "/zh-cn/docs/2.java/并发/6.原子类.html",
  "meta": {}
}