<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="5.引擎engine" />
	<meta name="description" content="5.引擎engine" />
	<!-- 网页标签标题 -->
	<title>5.引擎engine</title>
	<link rel="shortcut icon" href="/img/docsite.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a class="logo" href="/zh-cn/index.html"><span class="logo-normal">码农阿华| <span class="logo-desc">玩玩技术，说说产品</span></span></a><div class="search search-normal"><span class="icon-search"></span></div><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/begin.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/system/docs.png" class="front-img"/><span>文档</span><img src="/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>设计模式</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>设计原则<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/2.开闭原则.html" target="_self">开闭原则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/3.接口隔离原则.html" target="_self">接口隔离原则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>JAVA</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>目录<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dir/demo3.html" target="_self">示例3</a></li></ul></li></ul></li></ul></div><div class="doc-content markdown-body"><h2 id="1%E3%80%81tinylog">1、TinyLog <a class="header-anchor" href="#1%E3%80%81tinylog">#</a></h2>
<blockquote>
<p>最简单的一种引擎，每一列保存为一个文件，里面的内容是压缩过的，不支持索引
这种引擎没有并发控制，所以，当你需要在读，又在写时，读会出错。并发写，内容都会坏掉。</p>
</blockquote>
<p>​    <strong>应用场景</strong> :</p>
<blockquote>
<p>a. 基本上就是那种只写一次
b. 然后就是只读的场景。
c. 不适用于处理量大的数据，官方推荐，使用这种引擎的表最多 100 万行的数据</p>
</blockquote>
<pre><code class="language-sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> test.tinylog;
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.tinylog (a UInt16, b UInt16) <span class="hljs-keyword">ENGINE</span> = TinyLog;
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.tinylog(a,b) <span class="hljs-keyword">values</span> (<span class="hljs-number">7</span>,<span class="hljs-number">13</span>);
</code></pre>
<p>此时<code>/var/lib/clickhouse/data/test/tinylog</code>保存数据的目录结构：</p>
<pre><code>├── a.bin
├── b.bin
└── sizes.json
</code></pre>
<p>a.bin 和 b.bin 是压缩过的对应的列的数据， sizes.json 中记录了每个 *.bin 文件的大小</p>
<h2 id="2%E3%80%81log">2、Log <a class="header-anchor" href="#2%E3%80%81log">#</a></h2>
<p>这种引擎跟 TinyLog 基本一致
它的改进点，是加了一个 __marks.mrk 文件，里面记录了每个数据块的偏移
这样做的一个用处，就是可以准确地切分读的范围，从而使用并发读取成为可能
但是，它是不能支持并发写的，一个写操作会阻塞其它读写操作
Log 不支持索引，同时因为有一个 __marks.mrk 的冗余数据，所以在写入数据时，一旦出现问题，这个表就废了</p>
<p>**应用场景:</p>
<blockquote>
<p>同 TinyLog 差不多，它适用的场景也是那种写一次之后，后面就是只读的场景，临时数据用它保存也可以</p>
</blockquote>
<pre><code class="language-sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> test.log;
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.log (a UInt16, b UInt16) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">Log</span>;
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.log(a,b) <span class="hljs-keyword">values</span> (<span class="hljs-number">7</span>,<span class="hljs-number">13</span>);
</code></pre>
<p>此时<code>/var/lib/clickhouse/data/test/log</code>保存数据的目录结构：</p>
<pre><code>├── __marks.mrk
├── a.bin
├── b.bin
└── sizes.json
</code></pre>
<h2 id="3%E3%80%81memory">3、Memory <a class="header-anchor" href="#3%E3%80%81memory">#</a></h2>
<p>内存引擎，数据以未压缩的原始形式直接保存在内存当中，服务器重启数据就会消失
可以并行读，读写互斥锁的时间也非常短
不支持索引，简单查询下有非常非常高的性能表现</p>
<p><strong>应用场景:</strong></p>
<blockquote>
<p>a. 进行测试
b. 在需要非常高的性能，同时数据量又不太大（上限大概 1 亿行）的场景</p>
</blockquote>
<h2 id="4%E3%80%81merge">4、Merge <a class="header-anchor" href="#4%E3%80%81merge">#</a></h2>
<p>一个工具引擎，本身不保存数据，只用于把指定库中的指定多个表链在一起。 这样，读取操作可以并发执行，同时也可以利用原表的索引，但是，此引擎不支持写操作指定引擎的同时，需要指定要链接的库及表，库名可以使用一个表达式，表名可以使用正则表达式指定</p>
<pre><code class="language-sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.tinylog1 (<span class="hljs-keyword">id</span> UInt16, <span class="hljs-keyword">name</span> <span class="hljs-keyword">String</span>) <span class="hljs-keyword">ENGINE</span>=TinyLog;
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.tinylog2 (<span class="hljs-keyword">id</span> UInt16, <span class="hljs-keyword">name</span> <span class="hljs-keyword">String</span>) <span class="hljs-keyword">ENGINE</span>=TinyLog;
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.tinylog3 (<span class="hljs-keyword">id</span> UInt16, <span class="hljs-keyword">name</span> <span class="hljs-keyword">String</span>) <span class="hljs-keyword">ENGINE</span>=TinyLog;

<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.tinylog1(<span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">'tinylog1'</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.tinylog2(<span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>) <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>, <span class="hljs-string">'tinylog2'</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.tinylog3(<span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>) <span class="hljs-keyword">values</span> (<span class="hljs-number">3</span>, <span class="hljs-string">'tinylog3'</span>);

<span class="hljs-keyword">use</span> <span class="hljs-keyword">test</span>;
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.merge (<span class="hljs-keyword">id</span> UInt16, <span class="hljs-keyword">name</span> <span class="hljs-keyword">String</span>) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">Merge</span>(currentDatabase(), <span class="hljs-string">'^tinylog[0-9]+'</span>);
<span class="hljs-keyword">select</span> _table,* <span class="hljs-keyword">from</span> test.merge <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">desc</span>
</code></pre>
<h2 id="5%E3%80%81distributed">5、Distributed <a class="header-anchor" href="#5%E3%80%81distributed">#</a></h2>
<p>与 Merge 类似， Distributed 也是通过一个逻辑表，去访问各个物理表，设置引擎时的样子是：</p>
<pre><code class="language-sql">Distributed(remote_group, database, table [, sharding_key])
</code></pre>
<p>其中：</p>
<blockquote>
<p>remote_group /etc/clickhouse-server/config.xml中remote_servers参数
database 是各服务器中的库名
table 是表名
sharding_key 是一个寻址表达式，可以是一个列名，也可以是像 rand() 之类的函数调用，它与 remote_servers 中的 weight 共同作用，决定在 写 时往哪个 shard 写</p>
</blockquote>
<p>配置文件中的 <code>remote_servers</code></p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">remote_servers</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">log</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">shard</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">weight</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">weight</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">internal_replication</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">internal_replication</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">replica</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">host</span>&gt;</span>172.17.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">host</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>9000<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span>
           <span class="hljs-tag">&lt;/<span class="hljs-name">replica</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">shard</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">shard</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">weight</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">weight</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">internal_replication</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">internal_replication</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">replica</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">host</span>&gt;</span>172.17.0.4<span class="hljs-tag">&lt;/<span class="hljs-name">host</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>9000<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span>
           <span class="hljs-tag">&lt;/<span class="hljs-name">replica</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">shard</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">log</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">remote_servers</span>&gt;</span>
</code></pre>
<blockquote>
<ul>
<li>log是某个 shard 组的名字，就是上面的 remote_group 的值</li>
</ul>
</blockquote>
<ul>
<li>shard 是固定标签</li>
<li>weight 是权重，前面说的 sharding_key 与这个有关。
简单来说，上面的配置，理论上来看:
第一个 shard “被选中”的概率是 1 / (1 + 2) ，第二个是 2 / (1 + 2) ，这很容易理解。但是， sharding_key 的工作情况，是按实际数字的“命中区间”算的，即第一个的区间是 [0, 1) 的周期，第二个区间是 [1, 1+2) 的周期。比如把 sharding_key 设置成 id ，当 id=0 或 id=3 时，一定是写入到第一个 shard 中，如果把 sharding_key 设置成 rand() ，那系统会对应地自己作一般化转换吧，这种时候就是一种概率场景了。</li>
<li>internal_replication是定义针对多个 replica 时的写入行为的。
如果为 false ，则会往所有的 replica 中写入数据，但是并不保证数据写入的一致性，所以这种情况时间一长，各 replica 的数据很可能出现差异。如果为 true ，则只会往第一个可写的 replica 中写入数据（剩下的事“物理表”自己处理）。</li>
<li>replica 就是定义各个冗余副本的，选项有 host ， port ， user ， password 等</li>
</ul>
<p>看一个实际的例子，我们先在两台机器上创建好物理表并插入一些测试数据：</p>
<pre><code class="language-sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.tinylog_d1(<span class="hljs-keyword">id</span> UInt16, <span class="hljs-keyword">name</span> <span class="hljs-keyword">String</span>) <span class="hljs-keyword">ENGINE</span>=TinyLog;
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.tinylog_d1(<span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">'Distributed record 1'</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.tinylog_d1(<span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>) <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>, <span class="hljs-string">'Distributed record 2'</span>);


</code></pre>
<p>在其中一台创建逻辑表：</p>
<pre><code class="language-sql">
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.tinylog_d (<span class="hljs-keyword">id</span> UInt16, <span class="hljs-keyword">name</span> <span class="hljs-keyword">String</span>) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">Distributed</span>(<span class="hljs-keyword">log</span>, <span class="hljs-keyword">test</span>,tinylog_d1 , <span class="hljs-keyword">id</span>);

<span class="hljs-comment">-- 插入数据到逻辑表，观察数据分发情况</span>
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.tinylog_d(<span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>) <span class="hljs-keyword">values</span> (<span class="hljs-number">0</span>, <span class="hljs-string">'main'</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.tinylog_d(<span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">'main'</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.tinylog_d(<span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>) <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>, <span class="hljs-string">'main'</span>);

<span class="hljs-keyword">select</span> <span class="hljs-keyword">name</span>,<span class="hljs-keyword">sum</span>(<span class="hljs-keyword">id</span>),<span class="hljs-keyword">count</span>(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">from</span> test.tinylog_d <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">name</span>;
</code></pre>
<p><code>注：</code>逻辑表中的写入操作是异步的，会先缓存在本机的文件系统上，并且，对于物理表的不可访问状态，并没有严格控制，所以写入失败丢数据的情况是可能发生的</p>
<h2 id="null">Null <a class="header-anchor" href="#null">#</a></h2>
<p>空引擎，写入的任何数据都会被忽略，读取的结果一定是空。</p>
<p>但是注意，虽然数据本身不会被存储，但是结构上的和数据格式上的约束还是跟普通表一样是存在的，同时，你也可以在这个引擎上创建视图</p>
<h2 id="buffer">Buffer <a class="header-anchor" href="#buffer">#</a></h2>
<ol>
<li>Buffer 引擎，像是Memory 存储的一个上层应用似的（磁盘上也是没有相应目录的）</li>
<li>它的行为是一个缓冲区，写入的数据先被放在缓冲区，达到一个阈值后，这些数据会自动被写到指定的另一个表中</li>
<li>和Memory 一样，有很多的限制，比如没有索引</li>
<li>Buffer 是接在其它表前面的一层，对它的读操作，也会自动应用到后面表，但是因为前面说到的限制的原因，一般我们读数据，就直接从源表读就好了，缓冲区的这点数据延迟，只要配置得当，影响不大的</li>
<li>Buffer 后面也可以不接任何表，这样的话，当数据达到阈值，就会被丢弃掉</li>
</ol>
<p>一些特点：</p>
<ul>
<li>如果一次写入的数据太大或太多，超过了 max 条件，则会直接写入源表。</li>
<li>删源表或改源表的时候，建议 Buffer 表删了重建。</li>
<li>“友好重启”时， Buffer 数据会先落到源表，“暴力重启”， Buffer 表中的数据会丢失。</li>
<li>即使使用了 Buffer ，多次的小数据写入，对比一次大数据写入，也 慢得多 （几千行与百万行的差距）</li>
</ul>
<pre><code class="language-sql"><span class="hljs-comment">-- 创建源表</span>
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.mergetree (sdt  <span class="hljs-built_in">Date</span>, <span class="hljs-keyword">id</span> UInt16, <span class="hljs-keyword">name</span> <span class="hljs-keyword">String</span>, point UInt16) <span class="hljs-keyword">ENGINE</span>=MergeTree(sdt, (<span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>), <span class="hljs-number">10</span>);
<span class="hljs-comment">-- 创建 Buffer表</span>
<span class="hljs-comment">-- Buffer(database, table, num_layers, min_time, max_time, min_rows, max_rows, min_bytes, max_bytes)</span>
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.mergetree_buffer <span class="hljs-keyword">as</span> test.mergetree <span class="hljs-keyword">ENGINE</span>=Buffer(<span class="hljs-keyword">test</span>, mergetree, <span class="hljs-number">16</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10000</span>);

<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.mergetree (sdt, <span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>, point) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2017-07-10'</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, <span class="hljs-number">20</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.mergetree_buffer (sdt, <span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>, point) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2017-07-10'</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>, <span class="hljs-number">10</span>);
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.mergetree;
<span class="hljs-keyword">select</span> <span class="hljs-string">'------'</span>;
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.mergetree_buffer;
</code></pre>
<ul>
<li>
<p>database数据库</p>
</li>
<li>
<p>table 源表，这里除了字符串常量，也可以使用变量的。</p>
</li>
<li>
<p>num_layer 是类似“分区”的概念，每个分区的后面的 min / max 是独立计算的，官方推荐的值是 16 。</p>
</li>
<li>
<p>min / max 这组配置荐，就是设置阈值的，分别是 时间（秒），行数，空间（字节）。</p>
<p>阈值的规则: 是“所有的 min 条件都满足， 或 至少一个 max 条件满足”。</p>
</li>
</ul>
<p>如果按上面我们的建表来说，所有的 min 条件就是：过了 3秒，2条数据，1 Byte。一个 max 条件是：20秒，或 10 条数据，或有 10K</p>
<h2 id="set">Set <a class="header-anchor" href="#set">#</a></h2>
<p>Set 这个引擎有点特殊，因为它只用在 IN 操作符右侧，你不能对它 select</p>
<pre><code class="language-sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.set(<span class="hljs-keyword">id</span> UInt16, <span class="hljs-keyword">name</span> <span class="hljs-keyword">String</span>) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">Set</span>;
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.set(<span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">'hello'</span>);
<span class="hljs-comment">-- select 1 where (1, 'hello') in test.set; -- 默认UInt8 需要手动进行类型转换</span>
<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> (toUInt16(<span class="hljs-number">1</span>), <span class="hljs-string">'hello'</span>) <span class="hljs-keyword">in</span> test.set;
</code></pre>
<blockquote>
<p><code>注:</code> Set 引擎表，是全内存运行的，但是相关数据会落到磁盘上保存，启动时会加载到内存中。所以，意外中断或暴力重启，是可能产生数据丢失问题的</p>
</blockquote>
<h2 id="mergetree">MergeTree <a class="header-anchor" href="#mergetree">#</a></h2>
<p>这个引擎是 ClickHouse 的<code>重头戏</code>，它支持<code>一个日期和一组主键的两层式索引</code>，还可以<code>实时更新数据</code>。同时，索引的粒度可以自定义，外加直接支持采样功能</p>
<pre><code class="language-sql">MergeTree(EventDate, (CounterID, EventDate), 8192)
MergeTree(EventDate, intHash32(UserID), (CounterID, EventDate, intHash32(UserID)), 8192)
</code></pre>
<ul>
<li>EventDate一个日期的列名</li>
<li>intHash32(UserID) 采样表达式</li>
<li>(CounterID, EventDate) 主键组（里面除了列名，也支持表达式），也可以是一个表达式</li>
<li>8192 主键索引的粒度</li>
</ul>
<pre><code class="language-sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> test.mergetree1;
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.mergetree1 (sdt  <span class="hljs-built_in">Date</span>, <span class="hljs-keyword">id</span> UInt16, <span class="hljs-keyword">name</span> <span class="hljs-keyword">String</span>, cnt UInt16) <span class="hljs-keyword">ENGINE</span>=MergeTree(sdt, (<span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>), <span class="hljs-number">10</span>);

<span class="hljs-comment">-- 日期的格式，好像必须是 yyyy-mm-dd</span>
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.mergetree1(sdt, <span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>, cnt) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2018-06-01'</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'aaa'</span>, <span class="hljs-number">10</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.mergetree1(sdt, <span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>, cnt) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2018-06-02'</span>, <span class="hljs-number">4</span>, <span class="hljs-string">'bbb'</span>, <span class="hljs-number">10</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.mergetree1(sdt, <span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>, cnt) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2018-06-03'</span>, <span class="hljs-number">5</span>, <span class="hljs-string">'ccc'</span>, <span class="hljs-number">11</span>);
</code></pre>
<p>结构</p>
<pre><code>├── 20180601_20180601_1_1_0
│   ├── checksums.txt
│   ├── columns.txt
│   ├── id.bin
│   ├── id.mrk
│   ├── name.bin
│   ├── name.mrk
│   ├── cnt.bin
│   ├── cnt.mrk 
│   ├── cnt.idx
│   ├── primary.idx
│   ├── sdt.bin
│   └── sdt.mrk -- 保存一下块偏移量
├── 20180602_20180602_2_2_0
│   └── ...
├── 20180603_20180603_3_3_0
│   └── ...
├── format_version.txt
└── detached
</code></pre>
<h2 id="replacingmergetree">ReplacingMergeTree <a class="header-anchor" href="#replacingmergetree">#</a></h2>
<ol>
<li>在 MergeTree 的基础上，添加了“处理重复数据”的功能=&gt;实时数据场景</li>
<li>相比 MergeTree ,ReplacingMergeTree 在最后加一个&quot;版本列&quot;,它跟时间列配合一起，用以区分哪条数据是&quot;新的&quot;，并把旧的丢掉(这个过程是在 merge 时处理，不是数据写入时就处理了的，平时重复的数据还是保存着的，并且查也是跟平常一样会查出来的)</li>
<li>主键列组用于区分重复的行</li>
</ol>
<pre><code class="language-sql"><span class="hljs-comment">-- 版本列 允许的类型是， UInt 一族的整数，或 Date 或 DateTime</span>
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.replacingmergetree (sdt  <span class="hljs-built_in">Date</span>, <span class="hljs-keyword">id</span> UInt16, <span class="hljs-keyword">name</span> <span class="hljs-keyword">String</span>, cnt UInt16) <span class="hljs-keyword">ENGINE</span>=ReplacingMergeTree(sdt, (<span class="hljs-keyword">name</span>), <span class="hljs-number">10</span>, cnt);

<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.replacingmergetree (sdt, <span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>, cnt) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2018-06-10'</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, <span class="hljs-number">20</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.replacingmergetree (sdt, <span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>, cnt) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2018-06-10'</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, <span class="hljs-number">30</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.replacingmergetree (sdt, <span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>, cnt) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2018-06-11'</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, <span class="hljs-number">20</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.replacingmergetree (sdt, <span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>, cnt) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2018-06-11'</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, <span class="hljs-number">30</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.replacingmergetree (sdt, <span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>, cnt) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2018-06-11'</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>);

<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.replacingmergetree;

<span class="hljs-comment">-- 如果记录未执行merge，可以手动触发一下 merge 行为</span>
<span class="hljs-keyword">optimize</span> <span class="hljs-keyword">table</span> test.replacingmergetree;
</code></pre>
<h2 id="summingmergetree">SummingMergeTree <a class="header-anchor" href="#summingmergetree">#</a></h2>
<ol>
<li>SummingMergeTree 就是在 merge 阶段把数据sum求和</li>
<li>sum求和的列可以指定，不可加的未指定列，会取一个最先出现的值</li>
</ol>
<pre><code class="language-sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.summingmergetree (sdt <span class="hljs-built_in">Date</span>, <span class="hljs-keyword">name</span> <span class="hljs-keyword">String</span>, a UInt16, b UInt16) <span class="hljs-keyword">ENGINE</span>=SummingMergeTree(sdt, (sdt, <span class="hljs-keyword">name</span>), <span class="hljs-number">8192</span>, (a));

<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.summingmergetree (sdt, <span class="hljs-keyword">name</span>, a, b) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2018-06-10'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.summingmergetree (sdt, <span class="hljs-keyword">name</span>, a, b) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2018-06-10'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-number">2</span>, <span class="hljs-number">11</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.summingmergetree (sdt, <span class="hljs-keyword">name</span>, a, b) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2018-06-11'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-number">3</span>, <span class="hljs-number">18</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.summingmergetree (sdt, <span class="hljs-keyword">name</span>, a, b) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2018-06-11'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-number">3</span>, <span class="hljs-number">82</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.summingmergetree (sdt, <span class="hljs-keyword">name</span>, a, b) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2018-06-11'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-number">3</span>, <span class="hljs-number">11</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.summingmergetree (sdt, <span class="hljs-keyword">name</span>, a, b) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2018-06-12'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">35</span>);

<span class="hljs-comment">-- 手动触发一下 merge 行为</span>
<span class="hljs-keyword">optimize</span> <span class="hljs-keyword">table</span> test.summingmergetree;

<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.summingmergetree;
</code></pre>
<p>注: 可加列不能是主键中的列，并且如果某行数据可加列都是 null ，则这行会被删除</p>
<h2 id="aggregatingmergetree">AggregatingMergeTree <a class="header-anchor" href="#aggregatingmergetree">#</a></h2>
<p>AggregatingMergeTree 是在 MergeTree 基础之上，针对聚合函数结果，作增量计算优化的一个设计，它会在 merge 时，针对主键预处理聚合的数据应用于AggregatingMergeTree 上的聚合函数除了普通的 sum, uniq等，还有 sumState , uniqState ，及 sumMerge ， uniqMerge 这两组</p>
<p>聚合数据的预计算是一种“空间换时间”的权衡，并且是以减少维度为代价的</p>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test.amt_basic_tab(<span class="hljs-built_in">date</span> <span class="hljs-built_in">Date</span>,D1 <span class="hljs-keyword">String</span>,D2 <span class="hljs-keyword">String</span>,D3 <span class="hljs-keyword">String</span>,M1 UInt16) <span class="hljs-keyword">ENGINE</span> MergeTree() <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (D1,D2,D3);


<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.amt_basic_tab (<span class="hljs-built_in">date</span>, D1, D2, D3, M1) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2017-07-10'</span>, <span class="hljs-string">'甲'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.amt_basic_tab (<span class="hljs-built_in">date</span>, D1, D2, D3, M1) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2017-07-10'</span>, <span class="hljs-string">'甲'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.amt_basic_tab (<span class="hljs-built_in">date</span>, D1, D2, D3, M1) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2017-07-10'</span>, <span class="hljs-string">'甲'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.amt_basic_tab (<span class="hljs-built_in">date</span>, D1, D2, D3, M1) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2017-07-10'</span>, <span class="hljs-string">'乙'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.amt_basic_tab (<span class="hljs-built_in">date</span>, D1, D2, D3, M1) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2017-07-10'</span>, <span class="hljs-string">'丙'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.amt_basic_tab (<span class="hljs-built_in">date</span>, D1, D2, D3, M1) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2017-07-10'</span>, <span class="hljs-string">'丙'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.amt_basic_tab (<span class="hljs-built_in">date</span>, D1, D2, D3, M1) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2017-07-10'</span>, <span class="hljs-string">'丁'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.amt_basic_tab (<span class="hljs-built_in">date</span>, D1, D2, D3, M1) <span class="hljs-keyword">values</span> (<span class="hljs-string">'2017-07-10'</span>, <span class="hljs-string">'丁'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-number">1</span>);

<span class="hljs-comment">-- 创建一个AggregatingMergeTree的物化视图</span>
<span class="hljs-keyword">create</span> <span class="hljs-keyword">materialized</span> <span class="hljs-keyword">view</span> amt_tab_view <span class="hljs-keyword">ENGINE</span> = AggregatingMergeTree() <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (D2,D3) <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">date</span>,D2, D3, uniqState(D1) <span class="hljs-keyword">as</span> uv <span class="hljs-keyword">from</span> amt_basic_tab <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-built_in">date</span>,D2,D3;
</code></pre>
<h4 id="%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">使用场景 <a class="header-anchor" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">#</a></h4>
<p>可以使用<code>AggregatingMergeTree</code>表来做增量数据统计聚合，包括物化视图的数据聚合。</p>
<h2 id="collapsingmergetree">CollapsingMergeTree <a class="header-anchor" href="#collapsingmergetree">#</a></h2>
<p>是专门为 OLAP 场景下，一种“变通”存数做法而设计的，在数据是不能改，更不能删的前提下，通过“运算”的方式，去抹掉旧数据的影响，把旧数据“减”去即可，从而解决&quot;最终状态&quot;类的问题，比如 <code>当前有多少人在线？</code></p>
<p>“以加代删”的增量存储方式，带来了聚合计算方便的好处，代价却是存储空间的翻倍，并且，对于只关心最新状态的场景，中间数据都是无用的</p>
<p>CollapsingMergeTree 在创建时与 MergeTree 基本一样，除了最后多了一个参数，需要指定 Sign 位（必须是 Int8 类型）</p>
<pre><code class="language-sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.collapsingmergetree(<span class="hljs-keyword">sign</span> <span class="hljs-built_in">Int8</span>, sdt <span class="hljs-built_in">Date</span>, <span class="hljs-keyword">name</span> <span class="hljs-keyword">String</span>, cnt UInt16) <span class="hljs-keyword">ENGINE</span>=CollapsingMergeTree(sdt, (sdt, <span class="hljs-keyword">name</span>), <span class="hljs-number">8192</span>, <span class="hljs-keyword">sign</span>);

</code></pre>
</div></section><footer class="footer-container"><div class="footer-body"><div class="cols-container"><div class="col col-12"><h3>码农阿华</h3><p>联系邮箱：alfredhua@aliyun.com</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/demo1.html" target="_self">概览</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd></dl></div></div><div class="copyright"><span>CopyRight©2019 版权所有 码农阿华 京ICP备19044364号</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>