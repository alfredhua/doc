{
  "filename": "5.引擎engine.md",
  "__html": "<h2 id=\"1%E3%80%81tinylog\">1、TinyLog <a class=\"header-anchor\" href=\"#1%E3%80%81tinylog\">#</a></h2>\n<blockquote>\n<p>最简单的一种引擎，每一列保存为一个文件，里面的内容是压缩过的，不支持索引\n这种引擎没有并发控制，所以，当你需要在读，又在写时，读会出错。并发写，内容都会坏掉。</p>\n</blockquote>\n<p>​    <strong>应用场景</strong> :</p>\n<blockquote>\n<p>a. 基本上就是那种只写一次\nb. 然后就是只读的场景。\nc. 不适用于处理量大的数据，官方推荐，使用这种引擎的表最多 100 万行的数据</p>\n</blockquote>\n<pre><code class=\"language-sql\"><span class=\"hljs-keyword\">drop</span> <span class=\"hljs-keyword\">table</span> <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">exists</span> test.tinylog;\n<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test.tinylog (a UInt16, b UInt16) <span class=\"hljs-keyword\">ENGINE</span> = TinyLog;\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.tinylog(a,b) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">13</span>);\n</code></pre>\n<p>此时<code>/var/lib/clickhouse/data/test/tinylog</code>保存数据的目录结构：</p>\n<pre><code>├── a.bin\n├── b.bin\n└── sizes.json\n</code></pre>\n<p>a.bin 和 b.bin 是压缩过的对应的列的数据， sizes.json 中记录了每个 *.bin 文件的大小</p>\n<h2 id=\"2%E3%80%81log\">2、Log <a class=\"header-anchor\" href=\"#2%E3%80%81log\">#</a></h2>\n<p>这种引擎跟 TinyLog 基本一致\n它的改进点，是加了一个 __marks.mrk 文件，里面记录了每个数据块的偏移\n这样做的一个用处，就是可以准确地切分读的范围，从而使用并发读取成为可能\n但是，它是不能支持并发写的，一个写操作会阻塞其它读写操作\nLog 不支持索引，同时因为有一个 __marks.mrk 的冗余数据，所以在写入数据时，一旦出现问题，这个表就废了</p>\n<p>**应用场景:</p>\n<blockquote>\n<p>同 TinyLog 差不多，它适用的场景也是那种写一次之后，后面就是只读的场景，临时数据用它保存也可以</p>\n</blockquote>\n<pre><code class=\"language-sql\"><span class=\"hljs-keyword\">drop</span> <span class=\"hljs-keyword\">table</span> <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">exists</span> test.log;\n<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test.log (a UInt16, b UInt16) <span class=\"hljs-keyword\">ENGINE</span> = <span class=\"hljs-keyword\">Log</span>;\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.log(a,b) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">13</span>);\n</code></pre>\n<p>此时<code>/var/lib/clickhouse/data/test/log</code>保存数据的目录结构：</p>\n<pre><code>├── __marks.mrk\n├── a.bin\n├── b.bin\n└── sizes.json\n</code></pre>\n<h2 id=\"3%E3%80%81memory\">3、Memory <a class=\"header-anchor\" href=\"#3%E3%80%81memory\">#</a></h2>\n<p>内存引擎，数据以未压缩的原始形式直接保存在内存当中，服务器重启数据就会消失\n可以并行读，读写互斥锁的时间也非常短\n不支持索引，简单查询下有非常非常高的性能表现</p>\n<p><strong>应用场景:</strong></p>\n<blockquote>\n<p>a. 进行测试\nb. 在需要非常高的性能，同时数据量又不太大（上限大概 1 亿行）的场景</p>\n</blockquote>\n<h2 id=\"4%E3%80%81merge\">4、Merge <a class=\"header-anchor\" href=\"#4%E3%80%81merge\">#</a></h2>\n<p>一个工具引擎，本身不保存数据，只用于把指定库中的指定多个表链在一起。 这样，读取操作可以并发执行，同时也可以利用原表的索引，但是，此引擎不支持写操作指定引擎的同时，需要指定要链接的库及表，库名可以使用一个表达式，表名可以使用正则表达式指定</p>\n<pre><code class=\"language-sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test.tinylog1 (<span class=\"hljs-keyword\">id</span> UInt16, <span class=\"hljs-keyword\">name</span> <span class=\"hljs-keyword\">String</span>) <span class=\"hljs-keyword\">ENGINE</span>=TinyLog;\n<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test.tinylog2 (<span class=\"hljs-keyword\">id</span> UInt16, <span class=\"hljs-keyword\">name</span> <span class=\"hljs-keyword\">String</span>) <span class=\"hljs-keyword\">ENGINE</span>=TinyLog;\n<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test.tinylog3 (<span class=\"hljs-keyword\">id</span> UInt16, <span class=\"hljs-keyword\">name</span> <span class=\"hljs-keyword\">String</span>) <span class=\"hljs-keyword\">ENGINE</span>=TinyLog;\n\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.tinylog1(<span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'tinylog1'</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.tinylog2(<span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">'tinylog2'</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.tinylog3(<span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">'tinylog3'</span>);\n\n<span class=\"hljs-keyword\">use</span> <span class=\"hljs-keyword\">test</span>;\n<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test.merge (<span class=\"hljs-keyword\">id</span> UInt16, <span class=\"hljs-keyword\">name</span> <span class=\"hljs-keyword\">String</span>) <span class=\"hljs-keyword\">ENGINE</span>=<span class=\"hljs-keyword\">Merge</span>(currentDatabase(), <span class=\"hljs-string\">'^tinylog[0-9]+'</span>);\n<span class=\"hljs-keyword\">select</span> _table,* <span class=\"hljs-keyword\">from</span> test.merge <span class=\"hljs-keyword\">order</span> <span class=\"hljs-keyword\">by</span> <span class=\"hljs-keyword\">id</span> <span class=\"hljs-keyword\">desc</span>\n</code></pre>\n<h2 id=\"5%E3%80%81distributed\">5、Distributed <a class=\"header-anchor\" href=\"#5%E3%80%81distributed\">#</a></h2>\n<p>与 Merge 类似， Distributed 也是通过一个逻辑表，去访问各个物理表，设置引擎时的样子是：</p>\n<pre><code class=\"language-sql\">Distributed(remote_group, database, table [, sharding_key])\n</code></pre>\n<p>其中：</p>\n<blockquote>\n<p>remote_group /etc/clickhouse-server/config.xml中remote_servers参数\ndatabase 是各服务器中的库名\ntable 是表名\nsharding_key 是一个寻址表达式，可以是一个列名，也可以是像 rand() 之类的函数调用，它与 remote_servers 中的 weight 共同作用，决定在 写 时往哪个 shard 写</p>\n</blockquote>\n<p>配置文件中的 <code>remote_servers</code></p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">remote_servers</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">log</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">shard</span>&gt;</span>\n           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">weight</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">weight</span>&gt;</span>\n           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">internal_replication</span>&gt;</span>false<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">internal_replication</span>&gt;</span>\n           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">replica</span>&gt;</span>\n               <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">host</span>&gt;</span>172.17.0.3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">host</span>&gt;</span>\n               <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">port</span>&gt;</span>9000<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">port</span>&gt;</span>\n           <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">replica</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">shard</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">shard</span>&gt;</span>\n           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">weight</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">weight</span>&gt;</span>\n           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">internal_replication</span>&gt;</span>false<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">internal_replication</span>&gt;</span>\n           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">replica</span>&gt;</span>\n               <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">host</span>&gt;</span>172.17.0.4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">host</span>&gt;</span>\n               <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">port</span>&gt;</span>9000<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">port</span>&gt;</span>\n           <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">replica</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">shard</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">log</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">remote_servers</span>&gt;</span>\n</code></pre>\n<blockquote>\n<ul>\n<li>log是某个 shard 组的名字，就是上面的 remote_group 的值</li>\n</ul>\n</blockquote>\n<ul>\n<li>shard 是固定标签</li>\n<li>weight 是权重，前面说的 sharding_key 与这个有关。\n简单来说，上面的配置，理论上来看:\n第一个 shard “被选中”的概率是 1 / (1 + 2) ，第二个是 2 / (1 + 2) ，这很容易理解。但是， sharding_key 的工作情况，是按实际数字的“命中区间”算的，即第一个的区间是 [0, 1) 的周期，第二个区间是 [1, 1+2) 的周期。比如把 sharding_key 设置成 id ，当 id=0 或 id=3 时，一定是写入到第一个 shard 中，如果把 sharding_key 设置成 rand() ，那系统会对应地自己作一般化转换吧，这种时候就是一种概率场景了。</li>\n<li>internal_replication是定义针对多个 replica 时的写入行为的。\n如果为 false ，则会往所有的 replica 中写入数据，但是并不保证数据写入的一致性，所以这种情况时间一长，各 replica 的数据很可能出现差异。如果为 true ，则只会往第一个可写的 replica 中写入数据（剩下的事“物理表”自己处理）。</li>\n<li>replica 就是定义各个冗余副本的，选项有 host ， port ， user ， password 等</li>\n</ul>\n<p>看一个实际的例子，我们先在两台机器上创建好物理表并插入一些测试数据：</p>\n<pre><code class=\"language-sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test.tinylog_d1(<span class=\"hljs-keyword\">id</span> UInt16, <span class=\"hljs-keyword\">name</span> <span class=\"hljs-keyword\">String</span>) <span class=\"hljs-keyword\">ENGINE</span>=TinyLog;\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.tinylog_d1(<span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'Distributed record 1'</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.tinylog_d1(<span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">'Distributed record 2'</span>);\n\n\n</code></pre>\n<p>在其中一台创建逻辑表：</p>\n<pre><code class=\"language-sql\">\n<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test.tinylog_d (<span class=\"hljs-keyword\">id</span> UInt16, <span class=\"hljs-keyword\">name</span> <span class=\"hljs-keyword\">String</span>) <span class=\"hljs-keyword\">ENGINE</span>=<span class=\"hljs-keyword\">Distributed</span>(<span class=\"hljs-keyword\">log</span>, <span class=\"hljs-keyword\">test</span>,tinylog_d1 , <span class=\"hljs-keyword\">id</span>);\n\n<span class=\"hljs-comment\">-- 插入数据到逻辑表，观察数据分发情况</span>\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.tinylog_d(<span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">'main'</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.tinylog_d(<span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'main'</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.tinylog_d(<span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">'main'</span>);\n\n<span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">name</span>,<span class=\"hljs-keyword\">sum</span>(<span class=\"hljs-keyword\">id</span>),<span class=\"hljs-keyword\">count</span>(<span class=\"hljs-keyword\">id</span>) <span class=\"hljs-keyword\">from</span> test.tinylog_d <span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> <span class=\"hljs-keyword\">name</span>;\n</code></pre>\n<p><code>注：</code>逻辑表中的写入操作是异步的，会先缓存在本机的文件系统上，并且，对于物理表的不可访问状态，并没有严格控制，所以写入失败丢数据的情况是可能发生的</p>\n<h2 id=\"null\">Null <a class=\"header-anchor\" href=\"#null\">#</a></h2>\n<p>空引擎，写入的任何数据都会被忽略，读取的结果一定是空。</p>\n<p>但是注意，虽然数据本身不会被存储，但是结构上的和数据格式上的约束还是跟普通表一样是存在的，同时，你也可以在这个引擎上创建视图</p>\n<h2 id=\"buffer\">Buffer <a class=\"header-anchor\" href=\"#buffer\">#</a></h2>\n<ol>\n<li>Buffer 引擎，像是Memory 存储的一个上层应用似的（磁盘上也是没有相应目录的）</li>\n<li>它的行为是一个缓冲区，写入的数据先被放在缓冲区，达到一个阈值后，这些数据会自动被写到指定的另一个表中</li>\n<li>和Memory 一样，有很多的限制，比如没有索引</li>\n<li>Buffer 是接在其它表前面的一层，对它的读操作，也会自动应用到后面表，但是因为前面说到的限制的原因，一般我们读数据，就直接从源表读就好了，缓冲区的这点数据延迟，只要配置得当，影响不大的</li>\n<li>Buffer 后面也可以不接任何表，这样的话，当数据达到阈值，就会被丢弃掉</li>\n</ol>\n<p>一些特点：</p>\n<ul>\n<li>如果一次写入的数据太大或太多，超过了 max 条件，则会直接写入源表。</li>\n<li>删源表或改源表的时候，建议 Buffer 表删了重建。</li>\n<li>“友好重启”时， Buffer 数据会先落到源表，“暴力重启”， Buffer 表中的数据会丢失。</li>\n<li>即使使用了 Buffer ，多次的小数据写入，对比一次大数据写入，也 慢得多 （几千行与百万行的差距）</li>\n</ul>\n<pre><code class=\"language-sql\"><span class=\"hljs-comment\">-- 创建源表</span>\n<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test.mergetree (sdt  <span class=\"hljs-built_in\">Date</span>, <span class=\"hljs-keyword\">id</span> UInt16, <span class=\"hljs-keyword\">name</span> <span class=\"hljs-keyword\">String</span>, point UInt16) <span class=\"hljs-keyword\">ENGINE</span>=MergeTree(sdt, (<span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>), <span class=\"hljs-number\">10</span>);\n<span class=\"hljs-comment\">-- 创建 Buffer表</span>\n<span class=\"hljs-comment\">-- Buffer(database, table, num_layers, min_time, max_time, min_rows, max_rows, min_bytes, max_bytes)</span>\n<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test.mergetree_buffer <span class=\"hljs-keyword\">as</span> test.mergetree <span class=\"hljs-keyword\">ENGINE</span>=Buffer(<span class=\"hljs-keyword\">test</span>, mergetree, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10000</span>);\n\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.mergetree (sdt, <span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>, point) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2017-07-10'</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-number\">20</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.mergetree_buffer (sdt, <span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>, point) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2017-07-10'</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-number\">10</span>);\n<span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> test.mergetree;\n<span class=\"hljs-keyword\">select</span> <span class=\"hljs-string\">'------'</span>;\n<span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> test.mergetree_buffer;\n</code></pre>\n<ul>\n<li>\n<p>database数据库</p>\n</li>\n<li>\n<p>table 源表，这里除了字符串常量，也可以使用变量的。</p>\n</li>\n<li>\n<p>num_layer 是类似“分区”的概念，每个分区的后面的 min / max 是独立计算的，官方推荐的值是 16 。</p>\n</li>\n<li>\n<p>min / max 这组配置荐，就是设置阈值的，分别是 时间（秒），行数，空间（字节）。</p>\n<p>阈值的规则: 是“所有的 min 条件都满足， 或 至少一个 max 条件满足”。</p>\n</li>\n</ul>\n<p>如果按上面我们的建表来说，所有的 min 条件就是：过了 3秒，2条数据，1 Byte。一个 max 条件是：20秒，或 10 条数据，或有 10K</p>\n<h2 id=\"set\">Set <a class=\"header-anchor\" href=\"#set\">#</a></h2>\n<p>Set 这个引擎有点特殊，因为它只用在 IN 操作符右侧，你不能对它 select</p>\n<pre><code class=\"language-sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test.set(<span class=\"hljs-keyword\">id</span> UInt16, <span class=\"hljs-keyword\">name</span> <span class=\"hljs-keyword\">String</span>) <span class=\"hljs-keyword\">ENGINE</span>=<span class=\"hljs-keyword\">Set</span>;\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.set(<span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'hello'</span>);\n<span class=\"hljs-comment\">-- select 1 where (1, 'hello') in test.set; -- 默认UInt8 需要手动进行类型转换</span>\n<span class=\"hljs-keyword\">select</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">where</span> (toUInt16(<span class=\"hljs-number\">1</span>), <span class=\"hljs-string\">'hello'</span>) <span class=\"hljs-keyword\">in</span> test.set;\n</code></pre>\n<blockquote>\n<p><code>注:</code> Set 引擎表，是全内存运行的，但是相关数据会落到磁盘上保存，启动时会加载到内存中。所以，意外中断或暴力重启，是可能产生数据丢失问题的</p>\n</blockquote>\n<h2 id=\"mergetree\">MergeTree <a class=\"header-anchor\" href=\"#mergetree\">#</a></h2>\n<p>这个引擎是 ClickHouse 的<code>重头戏</code>，它支持<code>一个日期和一组主键的两层式索引</code>，还可以<code>实时更新数据</code>。同时，索引的粒度可以自定义，外加直接支持采样功能</p>\n<pre><code class=\"language-sql\">MergeTree(EventDate, (CounterID, EventDate), 8192)\nMergeTree(EventDate, intHash32(UserID), (CounterID, EventDate, intHash32(UserID)), 8192)\n</code></pre>\n<ul>\n<li>EventDate一个日期的列名</li>\n<li>intHash32(UserID) 采样表达式</li>\n<li>(CounterID, EventDate) 主键组（里面除了列名，也支持表达式），也可以是一个表达式</li>\n<li>8192 主键索引的粒度</li>\n</ul>\n<pre><code class=\"language-sql\"><span class=\"hljs-keyword\">drop</span> <span class=\"hljs-keyword\">table</span> <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">exists</span> test.mergetree1;\n<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test.mergetree1 (sdt  <span class=\"hljs-built_in\">Date</span>, <span class=\"hljs-keyword\">id</span> UInt16, <span class=\"hljs-keyword\">name</span> <span class=\"hljs-keyword\">String</span>, cnt UInt16) <span class=\"hljs-keyword\">ENGINE</span>=MergeTree(sdt, (<span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>), <span class=\"hljs-number\">10</span>);\n\n<span class=\"hljs-comment\">-- 日期的格式，好像必须是 yyyy-mm-dd</span>\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.mergetree1(sdt, <span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>, cnt) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2018-06-01'</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'aaa'</span>, <span class=\"hljs-number\">10</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.mergetree1(sdt, <span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>, cnt) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2018-06-02'</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">'bbb'</span>, <span class=\"hljs-number\">10</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.mergetree1(sdt, <span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>, cnt) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2018-06-03'</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">'ccc'</span>, <span class=\"hljs-number\">11</span>);\n</code></pre>\n<p>结构</p>\n<pre><code>├── 20180601_20180601_1_1_0\n│   ├── checksums.txt\n│   ├── columns.txt\n│   ├── id.bin\n│   ├── id.mrk\n│   ├── name.bin\n│   ├── name.mrk\n│   ├── cnt.bin\n│   ├── cnt.mrk \n│   ├── cnt.idx\n│   ├── primary.idx\n│   ├── sdt.bin\n│   └── sdt.mrk -- 保存一下块偏移量\n├── 20180602_20180602_2_2_0\n│   └── ...\n├── 20180603_20180603_3_3_0\n│   └── ...\n├── format_version.txt\n└── detached\n</code></pre>\n<h2 id=\"replacingmergetree\">ReplacingMergeTree <a class=\"header-anchor\" href=\"#replacingmergetree\">#</a></h2>\n<ol>\n<li>在 MergeTree 的基础上，添加了“处理重复数据”的功能=&gt;实时数据场景</li>\n<li>相比 MergeTree ,ReplacingMergeTree 在最后加一个&quot;版本列&quot;,它跟时间列配合一起，用以区分哪条数据是&quot;新的&quot;，并把旧的丢掉(这个过程是在 merge 时处理，不是数据写入时就处理了的，平时重复的数据还是保存着的，并且查也是跟平常一样会查出来的)</li>\n<li>主键列组用于区分重复的行</li>\n</ol>\n<pre><code class=\"language-sql\"><span class=\"hljs-comment\">-- 版本列 允许的类型是， UInt 一族的整数，或 Date 或 DateTime</span>\n<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test.replacingmergetree (sdt  <span class=\"hljs-built_in\">Date</span>, <span class=\"hljs-keyword\">id</span> UInt16, <span class=\"hljs-keyword\">name</span> <span class=\"hljs-keyword\">String</span>, cnt UInt16) <span class=\"hljs-keyword\">ENGINE</span>=ReplacingMergeTree(sdt, (<span class=\"hljs-keyword\">name</span>), <span class=\"hljs-number\">10</span>, cnt);\n\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.replacingmergetree (sdt, <span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>, cnt) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2018-06-10'</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-number\">20</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.replacingmergetree (sdt, <span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>, cnt) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2018-06-10'</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-number\">30</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.replacingmergetree (sdt, <span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>, cnt) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2018-06-11'</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-number\">20</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.replacingmergetree (sdt, <span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>, cnt) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2018-06-11'</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-number\">30</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.replacingmergetree (sdt, <span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>, cnt) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2018-06-11'</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-number\">10</span>);\n\n<span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> test.replacingmergetree;\n\n<span class=\"hljs-comment\">-- 如果记录未执行merge，可以手动触发一下 merge 行为</span>\n<span class=\"hljs-keyword\">optimize</span> <span class=\"hljs-keyword\">table</span> test.replacingmergetree;\n</code></pre>\n<h2 id=\"summingmergetree\">SummingMergeTree <a class=\"header-anchor\" href=\"#summingmergetree\">#</a></h2>\n<ol>\n<li>SummingMergeTree 就是在 merge 阶段把数据sum求和</li>\n<li>sum求和的列可以指定，不可加的未指定列，会取一个最先出现的值</li>\n</ol>\n<pre><code class=\"language-sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test.summingmergetree (sdt <span class=\"hljs-built_in\">Date</span>, <span class=\"hljs-keyword\">name</span> <span class=\"hljs-keyword\">String</span>, a UInt16, b UInt16) <span class=\"hljs-keyword\">ENGINE</span>=SummingMergeTree(sdt, (sdt, <span class=\"hljs-keyword\">name</span>), <span class=\"hljs-number\">8192</span>, (a));\n\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.summingmergetree (sdt, <span class=\"hljs-keyword\">name</span>, a, b) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2018-06-10'</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">20</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.summingmergetree (sdt, <span class=\"hljs-keyword\">name</span>, a, b) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2018-06-10'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">11</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.summingmergetree (sdt, <span class=\"hljs-keyword\">name</span>, a, b) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2018-06-11'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">18</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.summingmergetree (sdt, <span class=\"hljs-keyword\">name</span>, a, b) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2018-06-11'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">82</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.summingmergetree (sdt, <span class=\"hljs-keyword\">name</span>, a, b) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2018-06-11'</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">11</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.summingmergetree (sdt, <span class=\"hljs-keyword\">name</span>, a, b) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2018-06-12'</span>, <span class=\"hljs-string\">'c'</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">35</span>);\n\n<span class=\"hljs-comment\">-- 手动触发一下 merge 行为</span>\n<span class=\"hljs-keyword\">optimize</span> <span class=\"hljs-keyword\">table</span> test.summingmergetree;\n\n<span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> test.summingmergetree;\n</code></pre>\n<p>注: 可加列不能是主键中的列，并且如果某行数据可加列都是 null ，则这行会被删除</p>\n<h2 id=\"aggregatingmergetree\">AggregatingMergeTree <a class=\"header-anchor\" href=\"#aggregatingmergetree\">#</a></h2>\n<p>AggregatingMergeTree 是在 MergeTree 基础之上，针对聚合函数结果，作增量计算优化的一个设计，它会在 merge 时，针对主键预处理聚合的数据应用于AggregatingMergeTree 上的聚合函数除了普通的 sum, uniq等，还有 sumState , uniqState ，及 sumMerge ， uniqMerge 这两组</p>\n<p>聚合数据的预计算是一种“空间换时间”的权衡，并且是以减少维度为代价的</p>\n<pre><code class=\"language-sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> test.amt_basic_tab(<span class=\"hljs-built_in\">date</span> <span class=\"hljs-built_in\">Date</span>,D1 <span class=\"hljs-keyword\">String</span>,D2 <span class=\"hljs-keyword\">String</span>,D3 <span class=\"hljs-keyword\">String</span>,M1 UInt16) <span class=\"hljs-keyword\">ENGINE</span> MergeTree() <span class=\"hljs-keyword\">PARTITION</span> <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-built_in\">date</span> <span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> (D1,D2,D3);\n\n\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.amt_basic_tab (<span class=\"hljs-built_in\">date</span>, D1, D2, D3, M1) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2017-07-10'</span>, <span class=\"hljs-string\">'甲'</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'1'</span>, <span class=\"hljs-number\">1</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.amt_basic_tab (<span class=\"hljs-built_in\">date</span>, D1, D2, D3, M1) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2017-07-10'</span>, <span class=\"hljs-string\">'甲'</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'1'</span>, <span class=\"hljs-number\">1</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.amt_basic_tab (<span class=\"hljs-built_in\">date</span>, D1, D2, D3, M1) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2017-07-10'</span>, <span class=\"hljs-string\">'甲'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-string\">'2'</span>, <span class=\"hljs-number\">1</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.amt_basic_tab (<span class=\"hljs-built_in\">date</span>, D1, D2, D3, M1) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2017-07-10'</span>, <span class=\"hljs-string\">'乙'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-string\">'3'</span>, <span class=\"hljs-number\">1</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.amt_basic_tab (<span class=\"hljs-built_in\">date</span>, D1, D2, D3, M1) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2017-07-10'</span>, <span class=\"hljs-string\">'丙'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-string\">'2'</span>, <span class=\"hljs-number\">1</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.amt_basic_tab (<span class=\"hljs-built_in\">date</span>, D1, D2, D3, M1) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2017-07-10'</span>, <span class=\"hljs-string\">'丙'</span>, <span class=\"hljs-string\">'c'</span>, <span class=\"hljs-string\">'1'</span>, <span class=\"hljs-number\">1</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.amt_basic_tab (<span class=\"hljs-built_in\">date</span>, D1, D2, D3, M1) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2017-07-10'</span>, <span class=\"hljs-string\">'丁'</span>, <span class=\"hljs-string\">'c'</span>, <span class=\"hljs-string\">'2'</span>, <span class=\"hljs-number\">1</span>);\n<span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> test.amt_basic_tab (<span class=\"hljs-built_in\">date</span>, D1, D2, D3, M1) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">'2017-07-10'</span>, <span class=\"hljs-string\">'丁'</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'1'</span>, <span class=\"hljs-number\">1</span>);\n\n<span class=\"hljs-comment\">-- 创建一个AggregatingMergeTree的物化视图</span>\n<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">materialized</span> <span class=\"hljs-keyword\">view</span> amt_tab_view <span class=\"hljs-keyword\">ENGINE</span> = AggregatingMergeTree() <span class=\"hljs-keyword\">PARTITION</span> <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-built_in\">date</span> <span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> (D2,D3) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">date</span>,D2, D3, uniqState(D1) <span class=\"hljs-keyword\">as</span> uv <span class=\"hljs-keyword\">from</span> amt_basic_tab <span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> <span class=\"hljs-built_in\">date</span>,D2,D3;\n</code></pre>\n<h4 id=\"%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">使用场景 <a class=\"header-anchor\" href=\"#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">#</a></h4>\n<p>可以使用<code>AggregatingMergeTree</code>表来做增量数据统计聚合，包括物化视图的数据聚合。</p>\n<h2 id=\"collapsingmergetree\">CollapsingMergeTree <a class=\"header-anchor\" href=\"#collapsingmergetree\">#</a></h2>\n<p>是专门为 OLAP 场景下，一种“变通”存数做法而设计的，在数据是不能改，更不能删的前提下，通过“运算”的方式，去抹掉旧数据的影响，把旧数据“减”去即可，从而解决&quot;最终状态&quot;类的问题，比如 <code>当前有多少人在线？</code></p>\n<p>“以加代删”的增量存储方式，带来了聚合计算方便的好处，代价却是存储空间的翻倍，并且，对于只关心最新状态的场景，中间数据都是无用的</p>\n<p>CollapsingMergeTree 在创建时与 MergeTree 基本一样，除了最后多了一个参数，需要指定 Sign 位（必须是 Int8 类型）</p>\n<pre><code class=\"language-sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test.collapsingmergetree(<span class=\"hljs-keyword\">sign</span> <span class=\"hljs-built_in\">Int8</span>, sdt <span class=\"hljs-built_in\">Date</span>, <span class=\"hljs-keyword\">name</span> <span class=\"hljs-keyword\">String</span>, cnt UInt16) <span class=\"hljs-keyword\">ENGINE</span>=CollapsingMergeTree(sdt, (sdt, <span class=\"hljs-keyword\">name</span>), <span class=\"hljs-number\">8192</span>, <span class=\"hljs-keyword\">sign</span>);\n\n</code></pre>\n",
  "link": "/zh-cn/docs/3.数据库/clickhouse/5.引擎engine.html",
  "meta": {}
}