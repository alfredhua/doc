<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="2.源码解读" />
	<meta name="description" content="2.源码解读" />
	<!-- 网页标签标题 -->
	<title>2.源码解读</title>
	<link rel="shortcut icon" href="/img/docsite.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a class="logo" href="/zh-cn/index.html"><span class="logo-normal">码农阿华| <span class="logo-desc">玩玩技术，说说产品</span></span></a><div class="search search-normal"><span class="icon-search"></span></div><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/begin.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/system/docs.png" class="front-img"/><span>文档</span><img src="/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>设计模式</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>设计原则<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/2.开闭原则.html" target="_self">开闭原则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/3.接口隔离原则.html" target="_self">接口隔离原则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>JAVA</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>目录<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dir/demo3.html" target="_self">示例3</a></li></ul></li></ul></li></ul></div><div class="doc-content markdown-body"><ol>
<li>mybatis的核心模块</li>
</ol>
<p><img src="http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/file/5c79a65f3dc24481b8dff7b3a797493a" alt="image"></p>
<ol start="2">
<li>注解注入方式（入口）这里用的是Hikari连接，其它连接方式道理一样</li>
</ol>
<pre><code class="language-java">    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"dataSource"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"==============  url  "</span> +  url );

        <span class="hljs-keyword">if</span> (maxpoolsize &lt; <span class="hljs-number">10</span>) {
            maxpoolsize = <span class="hljs-number">10</span>;
        }
        <span class="hljs-keyword">if</span> (maxpoolsize &gt; <span class="hljs-number">100</span>) {
            maxpoolsize = <span class="hljs-number">100</span>;
        }
        <span class="hljs-keyword">final</span> HikariDataSource ds = <span class="hljs-keyword">new</span> HikariDataSource();
        ds.setMaximumPoolSize(maxpoolsize);
        ds.setDriverClassName(driverClassName);
        ds.setJdbcUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        <span class="hljs-keyword">return</span> ds;
    }

   <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">sqlSessionFactory</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">"dataSource"</span>)</span> DataSource dataSource) <span class="hljs-keyword">throws</span> Exception </span>{
        org.apache.ibatis.logging.LogFactory.useStdOutLogging();
        <span class="hljs-keyword">final</span> SqlSessionFactoryBean sessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();
        sessionFactory.setDataSource(dataSource);
        <span class="hljs-keyword">return</span> sessionFactory.getObject();
    }

</code></pre>
<p>关键在于：</p>
<pre><code class="language-java"><span class="hljs-keyword">final</span> SqlSessionFactoryBean sessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();
sessionFactory.setDataSource(dataSource);
<span class="hljs-keyword">return</span> sessionFactory.getObject();
</code></pre>
<p>sessionFactory.setDataSource(dataSource);
是在进行数据库配置项初始化。</p>
<p>sessionFactory.getObject();</p>
<p>在mybatis-spring.jar中存在SqlSessionFactoryBean。</p>
<pre><code class="language-java">  <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sqlSessionFactory == <span class="hljs-keyword">null</span>) {
      afterPropertiesSet();
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sqlSessionFactory;
  }

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
    notNull(dataSource, <span class="hljs-string">"Property 'dataSource' is required"</span>);
    notNull(sqlSessionFactoryBuilder, <span class="hljs-string">"Property 'sqlSessionFactoryBuilder' is required"</span>);

    <span class="hljs-keyword">this</span>.sqlSessionFactory = buildSqlSessionFactory();
  }
</code></pre>
<p>getObject()中的afterPropertiesSet方法调用buildSqlSessionFactory()才是进行mybatis的初始化。</p>
<p>mybatis的真正的入口</p>
<pre><code class="language-java">sqlSessionFactoryBuilder.build(configuration);
</code></pre>
<pre><code class="language-java">  <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">build</span><span class="hljs-params">(Configuration config)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultSqlSessionFactory(config);
  }
</code></pre>
<p>加载config配置文件：这里给注入到DefaultSqlSessionFactory的config， openSession的时候config才会有值。openSessionFromDataSource()方法加载对应的exector，获取对应的sqlSession。</p>
<pre><code class="language-java"> <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSession <span class="hljs-title">openSession</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);
  }

   <span class="hljs-function"><span class="hljs-keyword">private</span> SqlSession <span class="hljs-title">openSessionFromDataSource</span><span class="hljs-params">(ExecutorType execType, TransactionIsolationLevel level, <span class="hljs-keyword">boolean</span> autoCommit)</span> </span>{
    Transaction tx = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">final</span> Environment environment = configuration.getEnvironment();
      <span class="hljs-keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
      <span class="hljs-keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);
    } <span class="hljs-keyword">catch</span> (Exception e) {
      closeTransaction(tx); <span class="hljs-comment">// may have fetched a connection so lets call close()</span>
      <span class="hljs-keyword">throw</span> ExceptionFactory.wrapException(<span class="hljs-string">"Error opening session.  Cause: "</span> + e, e);
    } <span class="hljs-keyword">finally</span> {
      ErrorContext.instance().reset();
    }
  }
</code></pre>
<p>拿到DefaultSqlSession 对象后采用反射的方式 mapperProxyFactory.newInstance(sqlSession) 获取mapper对象，mapperRegistry中存在 Map&lt;Class<?>, MapperProxyFactory<?>&gt; knownMappers = new HashMap&lt;&gt;()，存放相应的代理工厂类，可以获取到相应的代理对象</p>
<pre><code class="language-java"> <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>{
    <span class="hljs-keyword">return</span> configuration.getMapper(type, <span class="hljs-keyword">this</span>);
  }
</code></pre>
<p>MapperProxy是代理类，invoke方法执行相应的sql，MapperMethod.execute(sqlSession, args);执行相应的方法</p>
<pre><code class="language-java">
  <span class="hljs-comment">/**
   * 反射入口
   * <span class="hljs-doctag">@param</span> proxy
   * <span class="hljs-doctag">@param</span> method
   * <span class="hljs-doctag">@param</span> args
   * <span class="hljs-doctag">@return</span>
   * <span class="hljs-doctag">@throws</span> Throwable
   */</span>
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">if</span> (Object<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">equals</span>(<span class="hljs-title">method</span>.<span class="hljs-title">getDeclaringClass</span>())) </span>{
        <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-keyword">this</span>, args);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isDefaultMethod(method)) {
        <span class="hljs-keyword">return</span> invokeDefaultMethod(proxy, method, args);
      }
    } <span class="hljs-keyword">catch</span> (Throwable t) {
      <span class="hljs-keyword">throw</span> ExceptionUtil.unwrapThrowable(t);
    }
    <span class="hljs-keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);
    <span class="hljs-keyword">return</span> mapperMethod.execute(sqlSession, args);
  }
</code></pre>
<p>mapperMethod.execute(sqlSession, args)：是相应的插入，更新，删除，查询方法。</p>
<pre><code class="language-java">
 <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">execute</span><span class="hljs-params">(SqlSession sqlSession, Object[] args)</span> </span>{
    Object result;
    <span class="hljs-keyword">switch</span> (command.getType()) {
      <span class="hljs-keyword">case</span> INSERT: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.insert(command.getName(), param));
        <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">case</span> UPDATE: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.update(command.getName(), param));
        <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">case</span> DELETE: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.delete(command.getName(), param));
        <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">case</span> SELECT:
        <span class="hljs-keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {
          executeWithResultHandler(sqlSession, args);
          result = <span class="hljs-keyword">null</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsMany()) {
          result = executeForMany(sqlSession, args);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsMap()) {
          result = executeForMap(sqlSession, args);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsCursor()) {
          result = executeForCursor(sqlSession, args);
        } <span class="hljs-keyword">else</span> {
          Object param = method.convertArgsToSqlCommandParam(args);
          result = sqlSession.selectOne(command.getName(), param);
          <span class="hljs-keyword">if</span> (method.returnsOptional()
              &amp;&amp; (result == <span class="hljs-keyword">null</span> || !method.getReturnType().equals(result.getClass()))) {
            result = Optional.ofNullable(result);
          }
        }
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> FLUSH:
        result = sqlSession.flushStatements();
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">"Unknown execution method for: "</span> + command.getName());
    }
    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">"Mapper method '"</span> + command.getName()
          + <span class="hljs-string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="hljs-string">")."</span>);
    }
    <span class="hljs-keyword">return</span> result;
  }
</code></pre>
<p>以select查询为例，真正执行sql的是sqlSession.selectList方法</p>
<pre><code class="language-java">  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">selectList</span><span class="hljs-params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>{
    <span class="hljs-keyword">try</span> {
      MappedStatement ms = configuration.getMappedStatement(statement);
      <span class="hljs-keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    } <span class="hljs-keyword">catch</span> (Exception e) {
      <span class="hljs-keyword">throw</span> ExceptionFactory.wrapException(<span class="hljs-string">"Error querying database.  Cause: "</span> + e, e);
    } <span class="hljs-keyword">finally</span> {
      ErrorContext.instance().reset();
    }
  }


    <span class="hljs-keyword">private</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">queryFromDatabase</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
    List&lt;E&gt; list;
    localCache.putObject(key, EXECUTION_PLACEHOLDER);
    <span class="hljs-keyword">try</span> {
      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
    } <span class="hljs-keyword">finally</span> {
      localCache.removeObject(key);
    }
    localCache.putObject(key, list);
    <span class="hljs-keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) {
      localOutputParameterCache.putObject(key, parameter);
    }
    <span class="hljs-keyword">return</span> list;
  }
</code></pre>
<p>真正核心的是doQuery方法，其实也是对于jdbc的连接做了一次二次封装。</p>
<pre><code class="language-java"> <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">doQuery</span><span class="hljs-params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span>
      <span class="hljs-keyword">throws</span> SQLException </span>{
    Statement stmt = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> {
      flushStatements();
      Configuration configuration = ms.getConfiguration();
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameterObject, rowBounds, resultHandler, boundSql);
      <span class="hljs-comment">//获取Statementhandle对象---&gt;对jdbc的statement的封装</span>
      Connection connection = getConnection(ms.getStatementLog());
      <span class="hljs-comment">//获取连接</span>
      stmt = handler.prepare(connection, transaction.getTimeout());
      handler.parameterize(stmt);
      <span class="hljs-comment">//执行 statement.executeQuery(sql);，resultHandler 是对结果集的封装，这倆步都在handler.query()里进行处理。</span>
      <span class="hljs-keyword">return</span> handler.query(stmt, resultHandler);
    } <span class="hljs-keyword">finally</span> {
      closeStatement(stmt);
    }
  }

   <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(Statement statement, ResultHandler resultHandler)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
    String sql = boundSql.getSql();
    <span class="hljs-comment">//执行 statement.executeQuery(sql);</span>
    statement.execute(sql); 
    <span class="hljs-comment">//这里是在处理结果集，对结果集的封装</span>
    <span class="hljs-keyword">return</span> resultSetHandler.handleResultSets(statement);
  }
</code></pre>
<p>总结：</p>
<p>mybatis的实际操作过程就是jdbc的连接过程，只不过中间用到了代理模式，对mybatis的接口文件进行一个代理，解析sql语句，执行响应的jdbc流程，中间对statement，resultSet等进行了封装。</p>
</div></section><footer class="footer-container"><div class="footer-body"><div class="cols-container"><div class="col col-12"><h3>码农阿华</h3><p>联系邮箱：alfredhua@aliyun.com</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/demo1.html" target="_self">概览</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd></dl></div></div><div class="copyright"><span>CopyRight©2019 版权所有 码农阿华 京ICP备19044364号</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>