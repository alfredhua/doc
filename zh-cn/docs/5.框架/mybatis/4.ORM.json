{
  "filename": "4.ORM.md",
  "__html": "<h3 id=\"dbutils\">DBUtils <a class=\"header-anchor\" href=\"#dbutils\">#</a></h3>\n<p>如果项目中操作数据库比较少，使用DBUtils</p>\n<p>DbUtils 提供了一个QueryRunner类它对数据库的增删改查的方法进行了封装，那么我们操作数据库就可以直接使用它提供的方法。</p>\n<pre><code>queryRunner = new QueryRunner(dataSource);\n</code></pre>\n<p>在 QueryRunner的构造函数里面，我们又可以传入一个数据源，比如在这里我们Hikari，这样我们就不需要再去写各种创建和释放连接的代码了。</p>\n<p>调用 QueryRunner 的查询方法，传入这个 Handler，它就可以 自动把结果集转换成实体类 Bean 或者 List 或者 Map。</p>\n<pre><code>String sql = &quot;select * from blog&quot;;\nList&lt;BlogDto&gt; list = queryRunner.query(sql, new BeanListHandler&lt;&gt;(BlogDto.class));\n</code></pre>\n<p>DbUtils 要求数据库的字段跟对象 的属性名称完全一致，才可以实现自动映射。</p>\n<h3 id=\"spring-jdbc\">Spring JDBC <a class=\"header-anchor\" href=\"#spring-jdbc\">#</a></h3>\n<p>第一个，我们不再需要去关心资源管理的问题。</p>\n<p>第二个，对于结果集的处理，Spring JDBC 也提供了一个 RowMapper 接口，可以\n把结果集转换成 Java 对象。</p>\n<p>比如我们要把结果集转换成 Employee 对象，就可以针对一个 Employee\n创建一个 RowMapper 对象，实现 RowMapper 接口，并且重写 mapRow()方法。我们 在 mapRow()方法里面完成对结果集的处理。</p>\n<pre><code>public class EmployeeRowMapper implements RowMapper { \n    @Override\n    public Object mapRow(ResultSet resultSet, int i) throws SQLException {\n        Employee employee = new Employee();\n        employee.setEmpId(resultSet.getInt(&quot;emp_id&quot;));\n        employee.setEmpName(resultSet.getString(&quot;emp_name&quot;));\n        employee.setEmail(resultSet.getString(&quot;emial&quot;));\n        return employee;\n    }\n}\n</code></pre>\n<h3 id=\"dbutils-%E5%92%8Cspring-jdbc%E5%AF%B9%E6%AF%94\">DBUtils 和Spring JDBC对比 <a class=\"header-anchor\" href=\"#dbutils-%E5%92%8Cspring-jdbc%E5%AF%B9%E6%AF%94\">#</a></h3>\n<p>1、 无论是 QueryRunner 还是 JdbcTemplate，都可以传入一个数据源进行初始 化，也就是资源管理这一部分的事情，可以交给专门的数据源组件去做，不用 我们手动创建和关闭;</p>\n<p>2、 对操作数据的增删改查的方法进行了封装;</p>\n<p>3、 可以帮助我们映射结果集，无论是映射成 List、Map 还是实体类。</p>\n<h5 id=\"%E7%BC%BA%E7%82%B9\">缺点 <a class=\"header-anchor\" href=\"#%E7%BC%BA%E7%82%B9\">#</a></h5>\n<p>1、 SQL 语句都是写死在代码里面的，依旧存在硬编码的问题;\n2、 参数只能按固定位置的顺序传入(数组)，它是通过占位符去替换的，\n不能自动映射;\n3、 在方法里面，可以把结果集映射成实体类，但是不能直接把实体类映射\n成数据库的记录(没有自动生成 SQL 的功能);\n4、 查询没有缓存的功能。</p>\n<h3 id=\"mybatis\">MyBatis <a class=\"header-anchor\" href=\"#mybatis\">#</a></h3>\n<h4 id=\"%E7%89%B9%E6%80%A7\">特性 <a class=\"header-anchor\" href=\"#%E7%89%B9%E6%80%A7\">#</a></h4>\n<p>1、 使用连接池对连接进行管理</p>\n<p>2、 SQL 和代码分离，集中管理</p>\n<p>3、 结果集映射</p>\n<p>4、 参数映射和动态 SQL</p>\n<p>5、 重复 SQL 的提取</p>\n<p>6、 缓存管理</p>\n<p>7、 插件机制</p>\n<table>\n<thead>\n<tr>\n<th>对象</th>\n<th>生命周期</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SqlSessionFactoryBuiler</td>\n<td>方法局部(method)</td>\n</tr>\n<tr>\n<td>SqlSessionFactory(单例)</td>\n<td>应用级别(application)</td>\n</tr>\n<tr>\n<td>SqlSession</td>\n<td>请求和操作(request/method)</td>\n</tr>\n<tr>\n<td>Mapper</td>\n<td>方法(method)</td>\n</tr>\n</tbody>\n</table>\n<p>三种执行器Execute：\nBatch Simple Reuse</p>\n<p>1、resultType 和 resultMap 的区别?</p>\n<p>resultMap：当使用resultMap做SQL语句返回结果类型处理时，通常需要在mapper.xml中定义resultMap进行pojo和相应表字段的对应。对于单表查询的话用resultType是最合适的</p>\n<p>resultMap对于一对一表连接的处理方式通常为在主表的pojo中添加嵌套另一个表的pojo，然后在mapper.xml中采用association节点元素进行对另一个表的连接处理。</p>\n<p>2、collection 和 association 的区别?</p>\n",
  "link": "/zh-cn/docs/5.框架/mybatis/4.ORM.html",
  "meta": {}
}