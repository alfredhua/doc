<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="3.IOC的注解方式源码解析" />
	<meta name="description" content="3.IOC的注解方式源码解析" />
	<!-- 网页标签标题 -->
	<title>3.IOC的注解方式源码解析</title>
	<link rel="shortcut icon" href="/img/docsite.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a class="logo" href="/zh-cn/index.html"><span class="logo-normal">码农阿华| <span class="logo-desc">玩玩技术，说说产品</span></span></a><div class="search search-normal"><span class="icon-search"></span></div><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/begin.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/system/docs.png" class="front-img"/><span>文档</span><img src="/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>设计模式</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>设计原则<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/2.开闭原则.html" target="_self">开闭原则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/3.接口隔离原则.html" target="_self">接口隔离原则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>JAVA</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>目录<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dir/demo3.html" target="_self">示例3</a></li></ul></li></ul></li></ul></div><div class="doc-content markdown-body"><h2 id="%E5%AE%9A%E4%BD%8D-bean-%E6%89%AB%E6%8F%8F%E8%B7%AF%E5%BE%84">定位 Bean 扫描路径 <a class="header-anchor" href="#%E5%AE%9A%E4%BD%8D-bean-%E6%89%AB%E6%8F%8F%E8%B7%AF%E5%BE%84">#</a></h2>
<p>在 Spring 中 管 理 注 解 Bean 定 义 的 容 器 有 两 个 : AnnotationConfigApplicationContext 和 AnnotationConfigWebApplicationContext。这两个类是专门处理 Spring 注解方式配置的容器，直接 依赖于注解作为容器配置信息来源的 IOC 容器。AnnotationConfigWebApplicationContext 是 AnnotationConfigApplicationContext 的 Web 版本，两者的用法以及对注解的处理方式几乎没有差别。</p>
<pre><code class="language-java">	<span class="hljs-comment">//保存一个读取注解的 Bean 定义读取器，并将其设置到容器中 </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AnnotatedBeanDefinitionReader reader;

    <span class="hljs-comment">//保存一个扫描指定类路径中注解 Bean 定义的扫描器，并将其设置到容器中 </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassPathBeanDefinitionScanner scanner;

    <span class="hljs-comment">//默认构造函数，初始化一个空容器，容器不包含任何 Bean 信息，需要在稍后通过调用其 register() </span>
	<span class="hljs-comment">//方法注册配置类，并调用 refresh()方法刷新容器，触发容器对注解 Bean 的载入、解析和注册过程</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotationConfigApplicationContext</span><span class="hljs-params">()</span> </span>{
		<span class="hljs-keyword">this</span>.reader = <span class="hljs-keyword">new</span> AnnotatedBeanDefinitionReader(<span class="hljs-keyword">this</span>);
		<span class="hljs-keyword">this</span>.scanner = <span class="hljs-keyword">new</span> ClassPathBeanDefinitionScanner(<span class="hljs-keyword">this</span>);
	}

    <span class="hljs-comment">//为容器的注解 Bean 读取器和注解 Bean 扫描器设置 Bean 名称产生器</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanNameGenerator</span><span class="hljs-params">(BeanNameGenerator beanNameGenerator)</span> </span>{
		<span class="hljs-keyword">this</span>.reader.setBeanNameGenerator(beanNameGenerator);
		<span class="hljs-keyword">this</span>.scanner.setBeanNameGenerator(beanNameGenerator);
		getBeanFactory().registerSingleton(
				AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);
	}

    <span class="hljs-comment">//为容器的注解 Bean 读取器和注解 Bean 扫描器设置作用范围元信息解析器</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScopeMetadataResolver</span><span class="hljs-params">(ScopeMetadataResolver scopeMetadataResolver)</span> </span>{
		<span class="hljs-keyword">this</span>.reader.setScopeMetadataResolver(scopeMetadataResolver);
		<span class="hljs-keyword">this</span>.scanner.setScopeMetadataResolver(scopeMetadataResolver);
	}

    <span class="hljs-comment">//扫描指定包路径及其子包下的注解类，为了使新添加的类被处理，必须手动调用 </span>
    <span class="hljs-comment">//refresh()方法刷新容器</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scan</span><span class="hljs-params">(String... basePackages)</span> </span>{
        Assert.notEmpty(basePackages, <span class="hljs-string">"At least one base package must be specified"</span>);
        <span class="hljs-keyword">this</span>.scanner.scan(basePackages);
    }



</code></pre>
<p>通过上面的源码分析，我们可以看啊到 Spring 对注解的处理分为两种方式:</p>
<ol>
<li>直接将注解 Bean 注册到容器中 可以在初始化容器时注册;也可以在容器创建之后手动调用注册方法向容器注册，然后通过手动刷新容 器，使得容器对注册的注解 Bean 进行处理。</li>
<li>通过扫描指定的包及其子包下的所有类 在初始化注解容器时指定要自动扫描的路径，如果容器创建以后向给定路径动态添加了注解 Bean，则 需要手动调用容器扫描的方法，然后手动刷新容器，使得容器对所注册的 Bean 进行处理。 接下来，将会对两种处理方式详细分析其实现过程。</li>
</ol>
<h2 id="%E8%AF%BB%E5%8F%96-annotation-%E5%85%83%E6%95%B0%E6%8D%AE">读取 Annotation 元数据 <a class="header-anchor" href="#%E8%AF%BB%E5%8F%96-annotation-%E5%85%83%E6%95%B0%E6%8D%AE">#</a></h2>
<pre><code class="language-java">    <span class="hljs-comment">//注册多个注解 Bean 定义类</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBean</span><span class="hljs-params">(Class&lt;?&gt; annotatedClass, String name, Class&lt;? extends Annotation&gt;... qualifiers)</span> </span>{
		doRegisterBean(annotatedClass, <span class="hljs-keyword">null</span>, name, qualifiers);
	}

	<span class="hljs-comment">/**
	 * Register a bean from the given bean class, deriving its metadata from
	 * class-declared annotations.
	 * <span class="hljs-doctag">@param</span> annotatedClass the class of the bean
	 * <span class="hljs-doctag">@param</span> instanceSupplier a callback for creating an instance of the bean
	 * (may be {<span class="hljs-doctag">@code</span> null})
	 * <span class="hljs-doctag">@param</span> name an explicit name for the bean
	 * <span class="hljs-doctag">@param</span> qualifiers specific qualifier annotations to consider, if any,
	 * in addition to qualifiers at the bean class level
	 * <span class="hljs-doctag">@param</span> definitionCustomizers one or more callbacks for customizing the
	 * factory's {<span class="hljs-doctag">@link</span> BeanDefinition}, e.g. setting a lazy-init or primary flag
	 * <span class="hljs-doctag">@since</span> 5.0
	 */</span>
     <span class="hljs-comment">//Bean 定义读取器向容器注册注解 Bean 定义类</span>
	&lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doRegisterBean</span><span class="hljs-params">(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,
			@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> </span>{

		AnnotatedGenericBeanDefinition abd = <span class="hljs-keyword">new</span> AnnotatedGenericBeanDefinition(annotatedClass);
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) {
			<span class="hljs-keyword">return</span>;
		}

		abd.setInstanceSupplier(instanceSupplier);
        <span class="hljs-comment">//解析注解 Bean 定义的作用域，若@Scope("prototype")，则 Bean 为原型类型; </span>
        <span class="hljs-comment">//若@Scope("singleton")，则 Bean 为单态类型</span>

		ScopeMetadata scopeMetadata = <span class="hljs-keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);
        <span class="hljs-comment">//为注解 Bean 定义设置作用域</span>
		abd.setScope(scopeMetadata.getScopeName());
        <span class="hljs-comment">//为注解 Bean 定义生成 Bean 名称</span>
		String beanName = (name != <span class="hljs-keyword">null</span> ? name : <span class="hljs-keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="hljs-keyword">this</span>.registry));
        <span class="hljs-comment">//如果在向容器注册注解 Bean 定义时，使用了额外的限定符注解，则解析限定符注解。</span>
        <span class="hljs-comment">//主要是配置的关于 autowiring 自动依赖注入装配的限定条件，即@Qualifier 注解 </span>
        <span class="hljs-comment">//Spring 自动依赖注入装配默认是按类型装配，如果使用@Qualifier 则按名称</span>
		AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
		<span class="hljs-keyword">if</span> (qualifiers != <span class="hljs-keyword">null</span>) {
			<span class="hljs-keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) {
				<span class="hljs-keyword">if</span> (Primary<span class="hljs-class">.<span class="hljs-keyword">class</span> </span>== qualifier) {
					abd.setPrimary(<span class="hljs-keyword">true</span>);
				}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Lazy<span class="hljs-class">.<span class="hljs-keyword">class</span> </span>== qualifier) {
					abd.setLazyInit(<span class="hljs-keyword">true</span>);
				}<span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">//如果使用了除@Primary 和@Lazy 以外的其他注解，则为该 Bean 添加一 </span>
                    <span class="hljs-comment">//个 autowiring 自动依赖注入装配限定符，该 Bean 在进 autowiring </span>
                    <span class="hljs-comment">//自动依赖注入装配时，根据名称装配限定符指定的 Bean</span>
					abd.addQualifier(<span class="hljs-keyword">new</span> AutowireCandidateQualifier(qualifier));
				}
			}
		}
		<span class="hljs-keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) {
			customizer.customize(abd);
		}
        <span class="hljs-comment">//创建一个指定 Bean 名称的 Bean 定义对象，封装注解 Bean 定义类数据</span>
		BeanDefinitionHolder definitionHolder = <span class="hljs-keyword">new</span> BeanDefinitionHolder(abd, beanName);
        <span class="hljs-comment">//根据注解 Bean 定义类中配置的作用域，创建相应的代理对象</span>
		definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-keyword">this</span>.registry);
        <span class="hljs-comment">//向 IOC 容器注册注解 Bean 类定义对象</span>
		BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="hljs-keyword">this</span>.registry);
	}
</code></pre>
<p>从上面的源码我们可以看出，注册注解 Bean 定义类的基本步骤:</p>
<ol>
<li>需要使用注解元数据解析器解析注解 Bean 中关于作用域的配置。</li>
<li>使用 AnnotationConfigUtils 的 processCommonDefinitionAnnotations()方法处理注解 Bean 定 义类中通用的注解。</li>
<li>使用 AnnotationConfigUtils 的 applyScopedProxyMode()方法创建对于作用域的代理对象。</li>
<li>通过 BeanDefinitionReaderUtils 向容器注册 Bean。</li>
</ol>
<ul>
<li>AnnotationScopeMetadataResolver 解析作用域元数据</li>
</ul>
<p>AnnotationScopeMetadataResolver 通过 resolveScopeMetadata()方法解析注解 Bean 定义类的作 用域元信息，即判断注册的 Bean 是原生类型(prototype)还是单态(singleton)类型</p>
<pre><code class="language-java">	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> ScopeMetadata <span class="hljs-title">resolveScopeMetadata</span><span class="hljs-params">(BeanDefinition definition)</span> </span>{
		ScopeMetadata metadata = <span class="hljs-keyword">new</span> ScopeMetadata();
		<span class="hljs-keyword">if</span> (definition <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) {
			AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;
            <span class="hljs-comment">//从注解 Bean 定义类的属性中查找属性为”Scope”的值，即@Scope 注解的值 </span>
            <span class="hljs-comment">//annDef.getMetadata().getAnnotationAttributes 方法将 Bean 中所有的注解和注解的值存放在一个 map 集合中</span>
			AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(
					annDef.getMetadata(), <span class="hljs-keyword">this</span>.scopeAnnotationType);
            <span class="hljs-comment">//将获取到的@Scope 注解的值设置到要返回的对象中</span>
			<span class="hljs-keyword">if</span> (attributes != <span class="hljs-keyword">null</span>) {
				metadata.setScopeName(attributes.getString(<span class="hljs-string">"value"</span>));
                <span class="hljs-comment">//获取@Scope 注解中的 proxyMode 属性值，在创建代理对象时会用到</span>
				ScopedProxyMode proxyMode = attributes.getEnum(<span class="hljs-string">"proxyMode"</span>);
                <span class="hljs-comment">//如果@Scope 的 proxyMode 属性为 DEFAULT 或者 NO</span>
				<span class="hljs-keyword">if</span> (proxyMode == ScopedProxyMode.DEFAULT) {
					proxyMode = <span class="hljs-keyword">this</span>.defaultProxyMode;
				}
				metadata.setScopedProxyMode(proxyMode);
			}
		}
		<span class="hljs-keyword">return</span> metadata;
	}
</code></pre>
<ul>
<li>AnnotationConfigUtils 处理注解 Bean 定义类中的通用注解</li>
</ul>
<pre><code class="language-java">
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCommonDefinitionAnnotations</span><span class="hljs-params">(AnnotatedBeanDefinition abd)</span> </span>{
		processCommonDefinitionAnnotations(abd, abd.getMetadata());
	}
    <span class="hljs-comment">//处理 Bean 定义中通用注解</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCommonDefinitionAnnotations</span><span class="hljs-params">(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)</span> </span>{
		AnnotationAttributes lazy = attributesFor(metadata, Lazy<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        <span class="hljs-comment">//如果 Bean 定义中有@Lazy 注解，则将该 Bean 预实例化属性设置为@lazy 注解的值</span>
		<span class="hljs-keyword">if</span> (lazy != <span class="hljs-keyword">null</span>) {
			abd.setLazyInit(lazy.getBoolean(<span class="hljs-string">"value"</span>));
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (abd.getMetadata() != metadata) {
			lazy = attributesFor(abd.getMetadata(), Lazy<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
			<span class="hljs-keyword">if</span> (lazy != <span class="hljs-keyword">null</span>) {
				abd.setLazyInit(lazy.getBoolean(<span class="hljs-string">"value"</span>));
			}
		}
        <span class="hljs-comment">//如果 Bean 定义中有@Primary 注解，则为该 Bean 设置为 autowiring 自动依赖注入装配的首选对象</span>
		<span class="hljs-keyword">if</span> (metadata.isAnnotated(Primary<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())) </span>{
			abd.setPrimary(<span class="hljs-keyword">true</span>);
		}
        <span class="hljs-comment">//如果 Bean 定义中有@ DependsOn 注解，则为该 Bean 设置所依赖的 Bean 名称， </span>
        <span class="hljs-comment">//容器将确保在实例化该 Bean 之前首先实例化所依赖的 Bean</span>
		AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
		<span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-keyword">null</span>) {
			abd.setDependsOn(dependsOn.getStringArray(<span class="hljs-string">"value"</span>));
		}

		AnnotationAttributes role = attributesFor(metadata, Role<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
		<span class="hljs-keyword">if</span> (role != <span class="hljs-keyword">null</span>) {
			abd.setRole(role.getNumber(<span class="hljs-string">"value"</span>).intValue());
		}
		AnnotationAttributes description = attributesFor(metadata, Description<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
		<span class="hljs-keyword">if</span> (description != <span class="hljs-keyword">null</span>) {
			abd.setDescription(description.getString(<span class="hljs-string">"value"</span>));
		}
	}
</code></pre>
<ul>
<li>AnnotationConfigUtils 根据注解 Bean 定义类中配置的作用域为其应用相应的代理策略</li>
</ul>
<p>AnnotationConfigUtils 类的 applyScopedProxyMode()方法根据注解 Bean 定义类中配置的作用域 @Scope 注解的值，为 Bean 定义应用相应的代理模式，主要是在 Spring 面向切面编程(AOP)中使用。 源码如下:</p>
<pre><code class="language-java">
<span class="hljs-function"><span class="hljs-keyword">static</span> BeanDefinitionHolder <span class="hljs-title">applyScopedProxyMode</span><span class="hljs-params">(
			ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry)</span> </span>{
        <span class="hljs-comment">//获取注解 Bean 定义类中@Scope 注解的 proxyMode 属性值</span>
		ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();
        <span class="hljs-comment">//如果配置的@Scope 注解的 proxyMode 属性值为 NO，则不应用代理模式</span>
		<span class="hljs-keyword">if</span> (scopedProxyMode.equals(ScopedProxyMode.NO)) {
			<span class="hljs-keyword">return</span> definition;
		}
        <span class="hljs-comment">//获取配置的@Scope 注解的 proxyMode 属性值，如果为 TARGET_CLASS</span>
        <span class="hljs-comment">//则返回 true，如果为 INTERFACES，则返回 false  </span>
		<span class="hljs-keyword">boolean</span> proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);
        <span class="hljs-comment">//为注册的 Bean 创建相应模式的代理对象</span>
		<span class="hljs-keyword">return</span> ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);
	}


</code></pre>
<ul>
<li>BeanDefinitionReaderUtils 向容器注册 Bean</li>
</ul>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(
			BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span>
			<span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>{

		<span class="hljs-comment">// Register bean definition under primary name.</span>
		String beanName = definitionHolder.getBeanName();
		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

		<span class="hljs-comment">// Register aliases for bean name, if any.</span>
		String[] aliases = definitionHolder.getAliases();
		<span class="hljs-keyword">if</span> (aliases != <span class="hljs-keyword">null</span>) {
			<span class="hljs-keyword">for</span> (String alias : aliases) {
				registry.registerAlias(beanName, alias);
			}
		}
	}
	
	<span class="hljs-comment">//这里注册BeanDefinition 和 xml方式注册方式一模一样</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span>
			<span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>{

		Assert.hasText(beanName, <span class="hljs-string">"Bean name must not be empty"</span>);
		Assert.notNull(beanDefinition, <span class="hljs-string">"BeanDefinition must not be null"</span>);

		<span class="hljs-keyword">if</span> (beanDefinition <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) {
			<span class="hljs-keyword">try</span> {
				((AbstractBeanDefinition) beanDefinition).validate();
			}
			<span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) {
				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
						<span class="hljs-string">"Validation of bean definition failed"</span>, ex);
			}
		}

		BeanDefinition existingDefinition = <span class="hljs-keyword">this</span>.beanDefinitionMap.get(beanName);
		<span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-keyword">null</span>) {
			<span class="hljs-keyword">if</span> (!isAllowBeanDefinitionOverriding()) {
				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) {
				<span class="hljs-comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span>
				<span class="hljs-keyword">if</span> (logger.isInfoEnabled()) {
					logger.info(<span class="hljs-string">"Overriding user-defined bean definition for bean '"</span> + beanName +
							<span class="hljs-string">"' with a framework-generated bean definition: replacing ["</span> +
							existingDefinition + <span class="hljs-string">"] with ["</span> + beanDefinition + <span class="hljs-string">"]"</span>);
				}
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!beanDefinition.equals(existingDefinition)) {
				<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
					logger.debug(<span class="hljs-string">"Overriding bean definition for bean '"</span> + beanName +
							<span class="hljs-string">"' with a different definition: replacing ["</span> + existingDefinition +
							<span class="hljs-string">"] with ["</span> + beanDefinition + <span class="hljs-string">"]"</span>);
				}
			}
			<span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
					logger.trace(<span class="hljs-string">"Overriding bean definition for bean '"</span> + beanName +
							<span class="hljs-string">"' with an equivalent definition: replacing ["</span> + existingDefinition +
							<span class="hljs-string">"] with ["</span> + beanDefinition + <span class="hljs-string">"]"</span>);
				}
			}
			<span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);
		}
		<span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">if</span> (hasBeanCreationStarted()) {
				<span class="hljs-comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span>
				<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.beanDefinitionMap) {
					<span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);
					List&lt;String&gt; updatedDefinitions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames.size() + <span class="hljs-number">1</span>);
					updatedDefinitions.addAll(<span class="hljs-keyword">this</span>.beanDefinitionNames);
					updatedDefinitions.add(beanName);
					<span class="hljs-keyword">this</span>.beanDefinitionNames = updatedDefinitions;
					removeManualSingletonName(beanName);
				}
			}
			<span class="hljs-keyword">else</span> {
				<span class="hljs-comment">// Still in startup registration phase</span>
				<span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);
				<span class="hljs-keyword">this</span>.beanDefinitionNames.add(beanName);
				removeManualSingletonName(beanName);
			}
			<span class="hljs-keyword">this</span>.frozenBeanDefinitionNames = <span class="hljs-keyword">null</span>;
		}

		<span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-keyword">null</span> || containsSingleton(beanName)) {
			resetBeanDefinition(beanName);
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isConfigurationFrozen()) {
			clearByTypeCache();
		}
	}
</code></pre>
<p>BeanDefinitionReaderUtils 主要是校验 BeanDefinition 信息，然后将 Bean 添加到容器中一个管理BeanDefinition 的 HashMap 中。</p>
<h2 id="%E6%89%AB%E6%8F%8F%E6%8C%87%E5%AE%9A%E5%8C%85%E5%B9%B6%E8%A7%A3%E6%9E%90%E4%B8%BA-beandefinition">扫描指定包并解析为 BeanDefinition <a class="header-anchor" href="#%E6%89%AB%E6%8F%8F%E6%8C%87%E5%AE%9A%E5%8C%85%E5%B9%B6%E8%A7%A3%E6%9E%90%E4%B8%BA-beandefinition">#</a></h2>
<p>当创建注解处理容器时，如果传入的初始参数是注解 Bean 定义类所在的包时，注解容器将扫描给定的 包及其子包，将扫描到的注解 Bean 定义载入并注册。</p>
<ul>
<li>ClassPathBeanDefinitionScanner 扫描给定的包及其子包</li>
</ul>
<p>ClassPathBeanDefinitionScanner与ClassPathScanningCandidateComponentProvider是父子关系</p>
<p>入口在AnnotationConfigApplicationContext类中，扫描指定的包路径。</p>
<pre><code class="language-java">	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scan</span><span class="hljs-params">(String... basePackages)</span> </span>{
		Assert.notEmpty(basePackages, <span class="hljs-string">"At least one base package must be specified"</span>);
		<span class="hljs-keyword">this</span>.scanner.scan(basePackages);
	}
</code></pre>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">scan</span><span class="hljs-params">(String... basePackages)</span> </span>{
		<span class="hljs-keyword">int</span> beanCountAtScanStart = <span class="hljs-keyword">this</span>.registry.getBeanDefinitionCount();
		doScan(basePackages);
		<span class="hljs-comment">// Register annotation config processors, if necessary.</span>
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.includeAnnotationConfig) {
			AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="hljs-keyword">this</span>.registry);
		}
		<span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);
	}

	<span class="hljs-comment">/**
	 * Perform a scan within the specified base packages,
	 * returning the registered bean definitions.
	 * &lt;p&gt;This method does &lt;i&gt;not&lt;/i&gt; register an annotation config processor
	 * but rather leaves this up to the caller.
	 * <span class="hljs-doctag">@param</span> basePackages the packages to check for annotated classes
	 * <span class="hljs-doctag">@return</span> set of beans registered if any for tooling registration purposes (never {<span class="hljs-doctag">@code</span> null})
	 */</span>
	 <span class="hljs-comment">//这里的方式和XML的扫描指定的路径包其实一样。</span>
	 <span class="hljs-comment">//调用链路，和AnnotationConfigApplicationContext 中的register类似。</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">doScan</span><span class="hljs-params">(String... basePackages)</span> </span>{
		Assert.notEmpty(basePackages, <span class="hljs-string">"At least one base package must be specified"</span>);
		Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();
		<span class="hljs-keyword">for</span> (String basePackage : basePackages) {
			<span class="hljs-comment">//ClassPathScanningCandidateComponentProvider中的findCandidateComponents()方法，他们是父子关系</span>
			Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
			<span class="hljs-keyword">for</span> (BeanDefinition candidate : candidates) {
				ScopeMetadata scopeMetadata = <span class="hljs-keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);
				candidate.setScope(scopeMetadata.getScopeName());
				String beanName = <span class="hljs-keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="hljs-keyword">this</span>.registry);
				<span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) {
					postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
				}
				<span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) {
					AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
				}
				<span class="hljs-keyword">if</span> (checkCandidate(beanName, candidate)) {
					BeanDefinitionHolder definitionHolder = <span class="hljs-keyword">new</span> BeanDefinitionHolder(candidate, beanName);
					definitionHolder =
							AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-keyword">this</span>.registry);
					beanDefinitions.add(definitionHolder);
					registerBeanDefinition(definitionHolder, <span class="hljs-keyword">this</span>.registry);
				}
			}
		}
		<span class="hljs-keyword">return</span> beanDefinitions;
	}
</code></pre>
<ul>
<li>ClassPathScanningCandidateComponentProvider 扫描给定包及其子包的类</li>
</ul>
<pre><code class="language-java">	<span class="hljs-comment">//核心的扫描方法。</span>
	<span class="hljs-function"><span class="hljs-keyword">private</span> Set&lt;BeanDefinition&gt; <span class="hljs-title">scanCandidateComponents</span><span class="hljs-params">(String basePackage)</span> </span>{
		Set&lt;BeanDefinition&gt; candidates = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();
		<span class="hljs-keyword">try</span> {
			String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
					resolveBasePackage(basePackage) + <span class="hljs-string">'/'</span> + <span class="hljs-keyword">this</span>.resourcePattern;
			Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
			<span class="hljs-keyword">boolean</span> traceEnabled = logger.isTraceEnabled();
			<span class="hljs-keyword">boolean</span> debugEnabled = logger.isDebugEnabled();
			<span class="hljs-keyword">for</span> (Resource resource : resources) {
				<span class="hljs-keyword">if</span> (traceEnabled) {
					logger.trace(<span class="hljs-string">"Scanning "</span> + resource);
				}
				<span class="hljs-keyword">if</span> (resource.isReadable()) {
					<span class="hljs-keyword">try</span> {
						MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
						<span class="hljs-keyword">if</span> (isCandidateComponent(metadataReader)) {
							ScannedGenericBeanDefinition sbd = <span class="hljs-keyword">new</span> ScannedGenericBeanDefinition(metadataReader);
							sbd.setSource(resource);
							<span class="hljs-keyword">if</span> (isCandidateComponent(sbd)) {
								<span class="hljs-keyword">if</span> (debugEnabled) {
									logger.debug(<span class="hljs-string">"Identified candidate component class: "</span> + resource);
								}
								candidates.add(sbd);
							}
							<span class="hljs-keyword">else</span> {
								<span class="hljs-keyword">if</span> (debugEnabled) {
									logger.debug(<span class="hljs-string">"Ignored because not a concrete top-level class: "</span> + resource);
								}
							}
						}
						<span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">if</span> (traceEnabled) {
								logger.trace(<span class="hljs-string">"Ignored because not matching any filter: "</span> + resource);
							}
						}
					}
					<span class="hljs-keyword">catch</span> (Throwable ex) {
						<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(
								<span class="hljs-string">"Failed to read candidate component class: "</span> + resource, ex);
					}
				}
				<span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">if</span> (traceEnabled) {
						logger.trace(<span class="hljs-string">"Ignored because not readable: "</span> + resource);
					}
				}
			}
		}
		<span class="hljs-keyword">catch</span> (IOException ex) {
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(<span class="hljs-string">"I/O failure during classpath scanning"</span>, ex);
		}
		<span class="hljs-keyword">return</span> candidates;
	}

</code></pre>
<h2 id="%E6%B3%A8%E5%86%8C%E6%B3%A8%E8%A7%A3-beandefinition">注册注解 BeanDefinition <a class="header-anchor" href="#%E6%B3%A8%E5%86%8C%E6%B3%A8%E8%A7%A3-beandefinition">#</a></h2>
<p>AnnotationConfigWebApplicationContext 是 AnnotationConfigApplicationContext 的 Web 版， 它们对于注解 Bean 的注册和扫描是基本相同的，但是 AnnotationConfigWebApplicationContext 对注解 Bean 定义的载入稍有不同，AnnotationConfigWebApplicationContext 注入注解 Bean 定义</p>
<pre><code class="language-java">
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span>
			<span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>{

		Assert.hasText(beanName, <span class="hljs-string">"Bean name must not be empty"</span>);
		Assert.notNull(beanDefinition, <span class="hljs-string">"BeanDefinition must not be null"</span>);

		<span class="hljs-keyword">if</span> (beanDefinition <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) {
			<span class="hljs-keyword">try</span> {
				((AbstractBeanDefinition) beanDefinition).validate();
			}
			<span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) {
				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
						<span class="hljs-string">"Validation of bean definition failed"</span>, ex);
			}
		}

		BeanDefinition existingDefinition = <span class="hljs-keyword">this</span>.beanDefinitionMap.get(beanName);
		<span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-keyword">null</span>) {
			<span class="hljs-keyword">if</span> (!isAllowBeanDefinitionOverriding()) {
				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) {
				<span class="hljs-comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span>
				<span class="hljs-keyword">if</span> (logger.isInfoEnabled()) {
					logger.info(<span class="hljs-string">"Overriding user-defined bean definition for bean '"</span> + beanName +
							<span class="hljs-string">"' with a framework-generated bean definition: replacing ["</span> +
							existingDefinition + <span class="hljs-string">"] with ["</span> + beanDefinition + <span class="hljs-string">"]"</span>);
				}
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!beanDefinition.equals(existingDefinition)) {
				<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
					logger.debug(<span class="hljs-string">"Overriding bean definition for bean '"</span> + beanName +
							<span class="hljs-string">"' with a different definition: replacing ["</span> + existingDefinition +
							<span class="hljs-string">"] with ["</span> + beanDefinition + <span class="hljs-string">"]"</span>);
				}
			}
			<span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
					logger.trace(<span class="hljs-string">"Overriding bean definition for bean '"</span> + beanName +
							<span class="hljs-string">"' with an equivalent definition: replacing ["</span> + existingDefinition +
							<span class="hljs-string">"] with ["</span> + beanDefinition + <span class="hljs-string">"]"</span>);
				}
			}
			<span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);
		}
		<span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">if</span> (hasBeanCreationStarted()) {
				<span class="hljs-comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span>
				<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.beanDefinitionMap) {
					<span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);
					List&lt;String&gt; updatedDefinitions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames.size() + <span class="hljs-number">1</span>);
					updatedDefinitions.addAll(<span class="hljs-keyword">this</span>.beanDefinitionNames);
					updatedDefinitions.add(beanName);
					<span class="hljs-keyword">this</span>.beanDefinitionNames = updatedDefinitions;
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.manualSingletonNames.contains(beanName)) {
						Set&lt;String&gt; updatedSingletons = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-keyword">this</span>.manualSingletonNames);
						updatedSingletons.remove(beanName);
						<span class="hljs-keyword">this</span>.manualSingletonNames = updatedSingletons;
					}
				}
			}
			<span class="hljs-keyword">else</span> {
				<span class="hljs-comment">// Still in startup registration phase</span>
				<span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);
				<span class="hljs-keyword">this</span>.beanDefinitionNames.add(beanName);
				<span class="hljs-keyword">this</span>.manualSingletonNames.remove(beanName);
			}
			<span class="hljs-keyword">this</span>.frozenBeanDefinitionNames = <span class="hljs-keyword">null</span>;
		}

		<span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-keyword">null</span> || containsSingleton(beanName)) {
			resetBeanDefinition(beanName);
		}
	}
</code></pre>
<h2 id="%E6%80%BB%E7%BB%93">总结 <a class="header-anchor" href="#%E6%80%BB%E7%BB%93">#</a></h2>
<p>IOC 容器初始化的基本步骤:</p>
<p>1、初始化的入口在容器实现中的 refresh()调用来完成。</p>
<p>2、对 Bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition(),其中的大致过程如下:通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader 是默认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统,URL 等 方式来定为资源位置。如果是 XmlBeanFactory 作为 IOC 容器，那么需要为它指定 Bean 定义的资源， 也就是说 Bean 定义文件时通过抽象成 Resource 来被 IOC 容器处理的，容器通过 BeanDefinitionReader 来完成定义信息的解析和 Bean 信息的注册,往往使用的是XmlBeanDefinitionReader 来解析 Bean 的 XML 定义文件-实际的处理过程是委托给 BeanDefinitionParserDelegate 来完成的，从而得到 bean 的定义信息，这些信息在 Spring 中使用 BeanDefinition 对象来表示-这个名字可以让我们想到 loadBeanDefinition(),registerBeanDefinition() 这些相关方法。它们都是为处理 BeanDefinitin 服务的，容器解析得到 BeanDefinition 以后，需要把 它在 IOC 容器中注册，这由 IOC 实现 BeanDefinitionRegistry 接口来实现。注册过程就是在 IOC 容器 内部维护的一个 HashMap 来保存得到的 BeanDefinition 的过程。这个 HashMap 是 IOC 容器持有 Bean 信息的场所，以后对 Bean 的操作都是围绕这个 HashMap 来实现的。</p>
<p>然后我们就可以通过 BeanFactory 和 ApplicationContext 来享受到 Spring IOC 的服务了,在使用 IOC 容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IOC 风格编写的应用程序代码完全不用关 心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已 知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。Spring 本身提供了对声明式载入 web 应用程序用法的应用程序上下文,并将其存储在 ServletContext 中的框架 实现。</p>
</div></section><footer class="footer-container"><div class="footer-body"><div class="cols-container"><div class="col col-12"><h3>码农阿华</h3><p>联系邮箱：alfredhua@aliyun.com</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/demo1.html" target="_self">概览</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd></dl></div></div><div class="copyright"><span>CopyRight©2019 版权所有 码农阿华 京ICP备19044364号</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>