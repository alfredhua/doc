{
  "filename": "3.IOC的注解方式源码解析.md",
  "__html": "<h2 id=\"%E5%AE%9A%E4%BD%8D-bean-%E6%89%AB%E6%8F%8F%E8%B7%AF%E5%BE%84\">定位 Bean 扫描路径 <a class=\"header-anchor\" href=\"#%E5%AE%9A%E4%BD%8D-bean-%E6%89%AB%E6%8F%8F%E8%B7%AF%E5%BE%84\">#</a></h2>\n<p>在 Spring 中 管 理 注 解 Bean 定 义 的 容 器 有 两 个 : AnnotationConfigApplicationContext 和 AnnotationConfigWebApplicationContext。这两个类是专门处理 Spring 注解方式配置的容器，直接 依赖于注解作为容器配置信息来源的 IOC 容器。AnnotationConfigWebApplicationContext 是 AnnotationConfigApplicationContext 的 Web 版本，两者的用法以及对注解的处理方式几乎没有差别。</p>\n<pre><code class=\"language-java\">\t<span class=\"hljs-comment\">//保存一个读取注解的 Bean 定义读取器，并将其设置到容器中 </span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> AnnotatedBeanDefinitionReader reader;\n\n    <span class=\"hljs-comment\">//保存一个扫描指定类路径中注解 Bean 定义的扫描器，并将其设置到容器中 </span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ClassPathBeanDefinitionScanner scanner;\n\n    <span class=\"hljs-comment\">//默认构造函数，初始化一个空容器，容器不包含任何 Bean 信息，需要在稍后通过调用其 register() </span>\n\t<span class=\"hljs-comment\">//方法注册配置类，并调用 refresh()方法刷新容器，触发容器对注解 Bean 的载入、解析和注册过程</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">AnnotationConfigApplicationContext</span><span class=\"hljs-params\">()</span> </span>{\n\t\t<span class=\"hljs-keyword\">this</span>.reader = <span class=\"hljs-keyword\">new</span> AnnotatedBeanDefinitionReader(<span class=\"hljs-keyword\">this</span>);\n\t\t<span class=\"hljs-keyword\">this</span>.scanner = <span class=\"hljs-keyword\">new</span> ClassPathBeanDefinitionScanner(<span class=\"hljs-keyword\">this</span>);\n\t}\n\n    <span class=\"hljs-comment\">//为容器的注解 Bean 读取器和注解 Bean 扫描器设置 Bean 名称产生器</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setBeanNameGenerator</span><span class=\"hljs-params\">(BeanNameGenerator beanNameGenerator)</span> </span>{\n\t\t<span class=\"hljs-keyword\">this</span>.reader.setBeanNameGenerator(beanNameGenerator);\n\t\t<span class=\"hljs-keyword\">this</span>.scanner.setBeanNameGenerator(beanNameGenerator);\n\t\tgetBeanFactory().registerSingleton(\n\t\t\t\tAnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);\n\t}\n\n    <span class=\"hljs-comment\">//为容器的注解 Bean 读取器和注解 Bean 扫描器设置作用范围元信息解析器</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setScopeMetadataResolver</span><span class=\"hljs-params\">(ScopeMetadataResolver scopeMetadataResolver)</span> </span>{\n\t\t<span class=\"hljs-keyword\">this</span>.reader.setScopeMetadataResolver(scopeMetadataResolver);\n\t\t<span class=\"hljs-keyword\">this</span>.scanner.setScopeMetadataResolver(scopeMetadataResolver);\n\t}\n\n    <span class=\"hljs-comment\">//扫描指定包路径及其子包下的注解类，为了使新添加的类被处理，必须手动调用 </span>\n    <span class=\"hljs-comment\">//refresh()方法刷新容器</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">scan</span><span class=\"hljs-params\">(String... basePackages)</span> </span>{\n        Assert.notEmpty(basePackages, <span class=\"hljs-string\">\"At least one base package must be specified\"</span>);\n        <span class=\"hljs-keyword\">this</span>.scanner.scan(basePackages);\n    }\n\n\n\n</code></pre>\n<p>通过上面的源码分析，我们可以看啊到 Spring 对注解的处理分为两种方式:</p>\n<ol>\n<li>直接将注解 Bean 注册到容器中 可以在初始化容器时注册;也可以在容器创建之后手动调用注册方法向容器注册，然后通过手动刷新容 器，使得容器对注册的注解 Bean 进行处理。</li>\n<li>通过扫描指定的包及其子包下的所有类 在初始化注解容器时指定要自动扫描的路径，如果容器创建以后向给定路径动态添加了注解 Bean，则 需要手动调用容器扫描的方法，然后手动刷新容器，使得容器对所注册的 Bean 进行处理。 接下来，将会对两种处理方式详细分析其实现过程。</li>\n</ol>\n<h2 id=\"%E8%AF%BB%E5%8F%96-annotation-%E5%85%83%E6%95%B0%E6%8D%AE\">读取 Annotation 元数据 <a class=\"header-anchor\" href=\"#%E8%AF%BB%E5%8F%96-annotation-%E5%85%83%E6%95%B0%E6%8D%AE\">#</a></h2>\n<pre><code class=\"language-java\">    <span class=\"hljs-comment\">//注册多个注解 Bean 定义类</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerBean</span><span class=\"hljs-params\">(Class&lt;?&gt; annotatedClass, String name, Class&lt;? extends Annotation&gt;... qualifiers)</span> </span>{\n\t\tdoRegisterBean(annotatedClass, <span class=\"hljs-keyword\">null</span>, name, qualifiers);\n\t}\n\n\t<span class=\"hljs-comment\">/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * <span class=\"hljs-doctag\">@param</span> annotatedClass the class of the bean\n\t * <span class=\"hljs-doctag\">@param</span> instanceSupplier a callback for creating an instance of the bean\n\t * (may be {<span class=\"hljs-doctag\">@code</span> null})\n\t * <span class=\"hljs-doctag\">@param</span> name an explicit name for the bean\n\t * <span class=\"hljs-doctag\">@param</span> qualifiers specific qualifier annotations to consider, if any,\n\t * in addition to qualifiers at the bean class level\n\t * <span class=\"hljs-doctag\">@param</span> definitionCustomizers one or more callbacks for customizing the\n\t * factory's {<span class=\"hljs-doctag\">@link</span> BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * <span class=\"hljs-doctag\">@since</span> 5.0\n\t */</span>\n     <span class=\"hljs-comment\">//Bean 定义读取器向容器注册注解 Bean 定义类</span>\n\t&lt;T&gt; <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doRegisterBean</span><span class=\"hljs-params\">(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,\n\t\t\t@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> </span>{\n\n\t\tAnnotatedGenericBeanDefinition abd = <span class=\"hljs-keyword\">new</span> AnnotatedGenericBeanDefinition(annotatedClass);\n\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) {\n\t\t\t<span class=\"hljs-keyword\">return</span>;\n\t\t}\n\n\t\tabd.setInstanceSupplier(instanceSupplier);\n        <span class=\"hljs-comment\">//解析注解 Bean 定义的作用域，若@Scope(\"prototype\")，则 Bean 为原型类型; </span>\n        <span class=\"hljs-comment\">//若@Scope(\"singleton\")，则 Bean 为单态类型</span>\n\n\t\tScopeMetadata scopeMetadata = <span class=\"hljs-keyword\">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);\n        <span class=\"hljs-comment\">//为注解 Bean 定义设置作用域</span>\n\t\tabd.setScope(scopeMetadata.getScopeName());\n        <span class=\"hljs-comment\">//为注解 Bean 定义生成 Bean 名称</span>\n\t\tString beanName = (name != <span class=\"hljs-keyword\">null</span> ? name : <span class=\"hljs-keyword\">this</span>.beanNameGenerator.generateBeanName(abd, <span class=\"hljs-keyword\">this</span>.registry));\n        <span class=\"hljs-comment\">//如果在向容器注册注解 Bean 定义时，使用了额外的限定符注解，则解析限定符注解。</span>\n        <span class=\"hljs-comment\">//主要是配置的关于 autowiring 自动依赖注入装配的限定条件，即@Qualifier 注解 </span>\n        <span class=\"hljs-comment\">//Spring 自动依赖注入装配默认是按类型装配，如果使用@Qualifier 则按名称</span>\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(abd);\n\t\t<span class=\"hljs-keyword\">if</span> (qualifiers != <span class=\"hljs-keyword\">null</span>) {\n\t\t\t<span class=\"hljs-keyword\">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) {\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (Primary<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span> </span>== qualifier) {\n\t\t\t\t\tabd.setPrimary(<span class=\"hljs-keyword\">true</span>);\n\t\t\t\t}<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (Lazy<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span> </span>== qualifier) {\n\t\t\t\t\tabd.setLazyInit(<span class=\"hljs-keyword\">true</span>);\n\t\t\t\t}<span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-comment\">//如果使用了除@Primary 和@Lazy 以外的其他注解，则为该 Bean 添加一 </span>\n                    <span class=\"hljs-comment\">//个 autowiring 自动依赖注入装配限定符，该 Bean 在进 autowiring </span>\n                    <span class=\"hljs-comment\">//自动依赖注入装配时，根据名称装配限定符指定的 Bean</span>\n\t\t\t\t\tabd.addQualifier(<span class=\"hljs-keyword\">new</span> AutowireCandidateQualifier(qualifier));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t<span class=\"hljs-keyword\">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) {\n\t\t\tcustomizer.customize(abd);\n\t\t}\n        <span class=\"hljs-comment\">//创建一个指定 Bean 名称的 Bean 定义对象，封装注解 Bean 定义类数据</span>\n\t\tBeanDefinitionHolder definitionHolder = <span class=\"hljs-keyword\">new</span> BeanDefinitionHolder(abd, beanName);\n        <span class=\"hljs-comment\">//根据注解 Bean 定义类中配置的作用域，创建相应的代理对象</span>\n\t\tdefinitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class=\"hljs-keyword\">this</span>.registry);\n        <span class=\"hljs-comment\">//向 IOC 容器注册注解 Bean 类定义对象</span>\n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class=\"hljs-keyword\">this</span>.registry);\n\t}\n</code></pre>\n<p>从上面的源码我们可以看出，注册注解 Bean 定义类的基本步骤:</p>\n<ol>\n<li>需要使用注解元数据解析器解析注解 Bean 中关于作用域的配置。</li>\n<li>使用 AnnotationConfigUtils 的 processCommonDefinitionAnnotations()方法处理注解 Bean 定 义类中通用的注解。</li>\n<li>使用 AnnotationConfigUtils 的 applyScopedProxyMode()方法创建对于作用域的代理对象。</li>\n<li>通过 BeanDefinitionReaderUtils 向容器注册 Bean。</li>\n</ol>\n<ul>\n<li>AnnotationScopeMetadataResolver 解析作用域元数据</li>\n</ul>\n<p>AnnotationScopeMetadataResolver 通过 resolveScopeMetadata()方法解析注解 Bean 定义类的作 用域元信息，即判断注册的 Bean 是原生类型(prototype)还是单态(singleton)类型</p>\n<pre><code class=\"language-java\">\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ScopeMetadata <span class=\"hljs-title\">resolveScopeMetadata</span><span class=\"hljs-params\">(BeanDefinition definition)</span> </span>{\n\t\tScopeMetadata metadata = <span class=\"hljs-keyword\">new</span> ScopeMetadata();\n\t\t<span class=\"hljs-keyword\">if</span> (definition <span class=\"hljs-keyword\">instanceof</span> AnnotatedBeanDefinition) {\n\t\t\tAnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;\n            <span class=\"hljs-comment\">//从注解 Bean 定义类的属性中查找属性为”Scope”的值，即@Scope 注解的值 </span>\n            <span class=\"hljs-comment\">//annDef.getMetadata().getAnnotationAttributes 方法将 Bean 中所有的注解和注解的值存放在一个 map 集合中</span>\n\t\t\tAnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(\n\t\t\t\t\tannDef.getMetadata(), <span class=\"hljs-keyword\">this</span>.scopeAnnotationType);\n            <span class=\"hljs-comment\">//将获取到的@Scope 注解的值设置到要返回的对象中</span>\n\t\t\t<span class=\"hljs-keyword\">if</span> (attributes != <span class=\"hljs-keyword\">null</span>) {\n\t\t\t\tmetadata.setScopeName(attributes.getString(<span class=\"hljs-string\">\"value\"</span>));\n                <span class=\"hljs-comment\">//获取@Scope 注解中的 proxyMode 属性值，在创建代理对象时会用到</span>\n\t\t\t\tScopedProxyMode proxyMode = attributes.getEnum(<span class=\"hljs-string\">\"proxyMode\"</span>);\n                <span class=\"hljs-comment\">//如果@Scope 的 proxyMode 属性为 DEFAULT 或者 NO</span>\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (proxyMode == ScopedProxyMode.DEFAULT) {\n\t\t\t\t\tproxyMode = <span class=\"hljs-keyword\">this</span>.defaultProxyMode;\n\t\t\t\t}\n\t\t\t\tmetadata.setScopedProxyMode(proxyMode);\n\t\t\t}\n\t\t}\n\t\t<span class=\"hljs-keyword\">return</span> metadata;\n\t}\n</code></pre>\n<ul>\n<li>AnnotationConfigUtils 处理注解 Bean 定义类中的通用注解</li>\n</ul>\n<pre><code class=\"language-java\">\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">processCommonDefinitionAnnotations</span><span class=\"hljs-params\">(AnnotatedBeanDefinition abd)</span> </span>{\n\t\tprocessCommonDefinitionAnnotations(abd, abd.getMetadata());\n\t}\n    <span class=\"hljs-comment\">//处理 Bean 定义中通用注解</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">processCommonDefinitionAnnotations</span><span class=\"hljs-params\">(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)</span> </span>{\n\t\tAnnotationAttributes lazy = attributesFor(metadata, Lazy<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n        <span class=\"hljs-comment\">//如果 Bean 定义中有@Lazy 注解，则将该 Bean 预实例化属性设置为@lazy 注解的值</span>\n\t\t<span class=\"hljs-keyword\">if</span> (lazy != <span class=\"hljs-keyword\">null</span>) {\n\t\t\tabd.setLazyInit(lazy.getBoolean(<span class=\"hljs-string\">\"value\"</span>));\n\t\t}\n\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (abd.getMetadata() != metadata) {\n\t\t\tlazy = attributesFor(abd.getMetadata(), Lazy<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\t\t\t<span class=\"hljs-keyword\">if</span> (lazy != <span class=\"hljs-keyword\">null</span>) {\n\t\t\t\tabd.setLazyInit(lazy.getBoolean(<span class=\"hljs-string\">\"value\"</span>));\n\t\t\t}\n\t\t}\n        <span class=\"hljs-comment\">//如果 Bean 定义中有@Primary 注解，则为该 Bean 设置为 autowiring 自动依赖注入装配的首选对象</span>\n\t\t<span class=\"hljs-keyword\">if</span> (metadata.isAnnotated(Primary<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>.<span class=\"hljs-title\">getName</span>())) </span>{\n\t\t\tabd.setPrimary(<span class=\"hljs-keyword\">true</span>);\n\t\t}\n        <span class=\"hljs-comment\">//如果 Bean 定义中有@ DependsOn 注解，则为该 Bean 设置所依赖的 Bean 名称， </span>\n        <span class=\"hljs-comment\">//容器将确保在实例化该 Bean 之前首先实例化所依赖的 Bean</span>\n\t\tAnnotationAttributes dependsOn = attributesFor(metadata, DependsOn<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\t\t<span class=\"hljs-keyword\">if</span> (dependsOn != <span class=\"hljs-keyword\">null</span>) {\n\t\t\tabd.setDependsOn(dependsOn.getStringArray(<span class=\"hljs-string\">\"value\"</span>));\n\t\t}\n\n\t\tAnnotationAttributes role = attributesFor(metadata, Role<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\t\t<span class=\"hljs-keyword\">if</span> (role != <span class=\"hljs-keyword\">null</span>) {\n\t\t\tabd.setRole(role.getNumber(<span class=\"hljs-string\">\"value\"</span>).intValue());\n\t\t}\n\t\tAnnotationAttributes description = attributesFor(metadata, Description<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\t\t<span class=\"hljs-keyword\">if</span> (description != <span class=\"hljs-keyword\">null</span>) {\n\t\t\tabd.setDescription(description.getString(<span class=\"hljs-string\">\"value\"</span>));\n\t\t}\n\t}\n</code></pre>\n<ul>\n<li>AnnotationConfigUtils 根据注解 Bean 定义类中配置的作用域为其应用相应的代理策略</li>\n</ul>\n<p>AnnotationConfigUtils 类的 applyScopedProxyMode()方法根据注解 Bean 定义类中配置的作用域 @Scope 注解的值，为 Bean 定义应用相应的代理模式，主要是在 Spring 面向切面编程(AOP)中使用。 源码如下:</p>\n<pre><code class=\"language-java\">\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> BeanDefinitionHolder <span class=\"hljs-title\">applyScopedProxyMode</span><span class=\"hljs-params\">(\n\t\t\tScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry)</span> </span>{\n        <span class=\"hljs-comment\">//获取注解 Bean 定义类中@Scope 注解的 proxyMode 属性值</span>\n\t\tScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();\n        <span class=\"hljs-comment\">//如果配置的@Scope 注解的 proxyMode 属性值为 NO，则不应用代理模式</span>\n\t\t<span class=\"hljs-keyword\">if</span> (scopedProxyMode.equals(ScopedProxyMode.NO)) {\n\t\t\t<span class=\"hljs-keyword\">return</span> definition;\n\t\t}\n        <span class=\"hljs-comment\">//获取配置的@Scope 注解的 proxyMode 属性值，如果为 TARGET_CLASS</span>\n        <span class=\"hljs-comment\">//则返回 true，如果为 INTERFACES，则返回 false  </span>\n\t\t<span class=\"hljs-keyword\">boolean</span> proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);\n        <span class=\"hljs-comment\">//为注册的 Bean 创建相应模式的代理对象</span>\n\t\t<span class=\"hljs-keyword\">return</span> ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);\n\t}\n\n\n</code></pre>\n<ul>\n<li>BeanDefinitionReaderUtils 向容器注册 Bean</li>\n</ul>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerBeanDefinition</span><span class=\"hljs-params\">(\n\t\t\tBeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span>\n\t\t\t<span class=\"hljs-keyword\">throws</span> BeanDefinitionStoreException </span>{\n\n\t\t<span class=\"hljs-comment\">// Register bean definition under primary name.</span>\n\t\tString beanName = definitionHolder.getBeanName();\n\t\tregistry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());\n\n\t\t<span class=\"hljs-comment\">// Register aliases for bean name, if any.</span>\n\t\tString[] aliases = definitionHolder.getAliases();\n\t\t<span class=\"hljs-keyword\">if</span> (aliases != <span class=\"hljs-keyword\">null</span>) {\n\t\t\t<span class=\"hljs-keyword\">for</span> (String alias : aliases) {\n\t\t\t\tregistry.registerAlias(beanName, alias);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t<span class=\"hljs-comment\">//这里注册BeanDefinition 和 xml方式注册方式一模一样</span>\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerBeanDefinition</span><span class=\"hljs-params\">(String beanName, BeanDefinition beanDefinition)</span>\n\t\t\t<span class=\"hljs-keyword\">throws</span> BeanDefinitionStoreException </span>{\n\n\t\tAssert.hasText(beanName, <span class=\"hljs-string\">\"Bean name must not be empty\"</span>);\n\t\tAssert.notNull(beanDefinition, <span class=\"hljs-string\">\"BeanDefinition must not be null\"</span>);\n\n\t\t<span class=\"hljs-keyword\">if</span> (beanDefinition <span class=\"hljs-keyword\">instanceof</span> AbstractBeanDefinition) {\n\t\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\t\t((AbstractBeanDefinition) beanDefinition).validate();\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">catch</span> (BeanDefinitionValidationException ex) {\n\t\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t<span class=\"hljs-string\">\"Validation of bean definition failed\"</span>, ex);\n\t\t\t}\n\t\t}\n\n\t\tBeanDefinition existingDefinition = <span class=\"hljs-keyword\">this</span>.beanDefinitionMap.get(beanName);\n\t\t<span class=\"hljs-keyword\">if</span> (existingDefinition != <span class=\"hljs-keyword\">null</span>) {\n\t\t\t<span class=\"hljs-keyword\">if</span> (!isAllowBeanDefinitionOverriding()) {\n\t\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) {\n\t\t\t\t<span class=\"hljs-comment\">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span>\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(<span class=\"hljs-string\">\"Overriding user-defined bean definition for bean '\"</span> + beanName +\n\t\t\t\t\t\t\t<span class=\"hljs-string\">\"' with a framework-generated bean definition: replacing [\"</span> +\n\t\t\t\t\t\t\texistingDefinition + <span class=\"hljs-string\">\"] with [\"</span> + beanDefinition + <span class=\"hljs-string\">\"]\"</span>);\n\t\t\t\t}\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!beanDefinition.equals(existingDefinition)) {\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(<span class=\"hljs-string\">\"Overriding bean definition for bean '\"</span> + beanName +\n\t\t\t\t\t\t\t<span class=\"hljs-string\">\"' with a different definition: replacing [\"</span> + existingDefinition +\n\t\t\t\t\t\t\t<span class=\"hljs-string\">\"] with [\"</span> + beanDefinition + <span class=\"hljs-string\">\"]\"</span>);\n\t\t\t\t}\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">else</span> {\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(<span class=\"hljs-string\">\"Overriding bean definition for bean '\"</span> + beanName +\n\t\t\t\t\t\t\t<span class=\"hljs-string\">\"' with an equivalent definition: replacing [\"</span> + existingDefinition +\n\t\t\t\t\t\t\t<span class=\"hljs-string\">\"] with [\"</span> + beanDefinition + <span class=\"hljs-string\">\"]\"</span>);\n\t\t\t\t}\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">this</span>.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t}\n\t\t<span class=\"hljs-keyword\">else</span> {\n\t\t\t<span class=\"hljs-keyword\">if</span> (hasBeanCreationStarted()) {\n\t\t\t\t<span class=\"hljs-comment\">// Cannot modify startup-time collection elements anymore (for stable iteration)</span>\n\t\t\t\t<span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>.beanDefinitionMap) {\n\t\t\t\t\t<span class=\"hljs-keyword\">this</span>.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\t\tList&lt;String&gt; updatedDefinitions = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;(<span class=\"hljs-keyword\">this</span>.beanDefinitionNames.size() + <span class=\"hljs-number\">1</span>);\n\t\t\t\t\tupdatedDefinitions.addAll(<span class=\"hljs-keyword\">this</span>.beanDefinitionNames);\n\t\t\t\t\tupdatedDefinitions.add(beanName);\n\t\t\t\t\t<span class=\"hljs-keyword\">this</span>.beanDefinitionNames = updatedDefinitions;\n\t\t\t\t\tremoveManualSingletonName(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">else</span> {\n\t\t\t\t<span class=\"hljs-comment\">// Still in startup registration phase</span>\n\t\t\t\t<span class=\"hljs-keyword\">this</span>.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\t<span class=\"hljs-keyword\">this</span>.beanDefinitionNames.add(beanName);\n\t\t\t\tremoveManualSingletonName(beanName);\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">this</span>.frozenBeanDefinitionNames = <span class=\"hljs-keyword\">null</span>;\n\t\t}\n\n\t\t<span class=\"hljs-keyword\">if</span> (existingDefinition != <span class=\"hljs-keyword\">null</span> || containsSingleton(beanName)) {\n\t\t\tresetBeanDefinition(beanName);\n\t\t}\n\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isConfigurationFrozen()) {\n\t\t\tclearByTypeCache();\n\t\t}\n\t}\n</code></pre>\n<p>BeanDefinitionReaderUtils 主要是校验 BeanDefinition 信息，然后将 Bean 添加到容器中一个管理BeanDefinition 的 HashMap 中。</p>\n<h2 id=\"%E6%89%AB%E6%8F%8F%E6%8C%87%E5%AE%9A%E5%8C%85%E5%B9%B6%E8%A7%A3%E6%9E%90%E4%B8%BA-beandefinition\">扫描指定包并解析为 BeanDefinition <a class=\"header-anchor\" href=\"#%E6%89%AB%E6%8F%8F%E6%8C%87%E5%AE%9A%E5%8C%85%E5%B9%B6%E8%A7%A3%E6%9E%90%E4%B8%BA-beandefinition\">#</a></h2>\n<p>当创建注解处理容器时，如果传入的初始参数是注解 Bean 定义类所在的包时，注解容器将扫描给定的 包及其子包，将扫描到的注解 Bean 定义载入并注册。</p>\n<ul>\n<li>ClassPathBeanDefinitionScanner 扫描给定的包及其子包</li>\n</ul>\n<p>ClassPathBeanDefinitionScanner与ClassPathScanningCandidateComponentProvider是父子关系</p>\n<p>入口在AnnotationConfigApplicationContext类中，扫描指定的包路径。</p>\n<pre><code class=\"language-java\">\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">scan</span><span class=\"hljs-params\">(String... basePackages)</span> </span>{\n\t\tAssert.notEmpty(basePackages, <span class=\"hljs-string\">\"At least one base package must be specified\"</span>);\n\t\t<span class=\"hljs-keyword\">this</span>.scanner.scan(basePackages);\n\t}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">scan</span><span class=\"hljs-params\">(String... basePackages)</span> </span>{\n\t\t<span class=\"hljs-keyword\">int</span> beanCountAtScanStart = <span class=\"hljs-keyword\">this</span>.registry.getBeanDefinitionCount();\n\t\tdoScan(basePackages);\n\t\t<span class=\"hljs-comment\">// Register annotation config processors, if necessary.</span>\n\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.includeAnnotationConfig) {\n\t\t\tAnnotationConfigUtils.registerAnnotationConfigProcessors(<span class=\"hljs-keyword\">this</span>.registry);\n\t\t}\n\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);\n\t}\n\n\t<span class=\"hljs-comment\">/**\n\t * Perform a scan within the specified base packages,\n\t * returning the registered bean definitions.\n\t * &lt;p&gt;This method does &lt;i&gt;not&lt;/i&gt; register an annotation config processor\n\t * but rather leaves this up to the caller.\n\t * <span class=\"hljs-doctag\">@param</span> basePackages the packages to check for annotated classes\n\t * <span class=\"hljs-doctag\">@return</span> set of beans registered if any for tooling registration purposes (never {<span class=\"hljs-doctag\">@code</span> null})\n\t */</span>\n\t <span class=\"hljs-comment\">//这里的方式和XML的扫描指定的路径包其实一样。</span>\n\t <span class=\"hljs-comment\">//调用链路，和AnnotationConfigApplicationContext 中的register类似。</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class=\"hljs-title\">doScan</span><span class=\"hljs-params\">(String... basePackages)</span> </span>{\n\t\tAssert.notEmpty(basePackages, <span class=\"hljs-string\">\"At least one base package must be specified\"</span>);\n\t\tSet&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class=\"hljs-keyword\">new</span> LinkedHashSet&lt;&gt;();\n\t\t<span class=\"hljs-keyword\">for</span> (String basePackage : basePackages) {\n\t\t\t<span class=\"hljs-comment\">//ClassPathScanningCandidateComponentProvider中的findCandidateComponents()方法，他们是父子关系</span>\n\t\t\tSet&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);\n\t\t\t<span class=\"hljs-keyword\">for</span> (BeanDefinition candidate : candidates) {\n\t\t\t\tScopeMetadata scopeMetadata = <span class=\"hljs-keyword\">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);\n\t\t\t\tcandidate.setScope(scopeMetadata.getScopeName());\n\t\t\t\tString beanName = <span class=\"hljs-keyword\">this</span>.beanNameGenerator.generateBeanName(candidate, <span class=\"hljs-keyword\">this</span>.registry);\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (candidate <span class=\"hljs-keyword\">instanceof</span> AbstractBeanDefinition) {\n\t\t\t\t\tpostProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);\n\t\t\t\t}\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (candidate <span class=\"hljs-keyword\">instanceof</span> AnnotatedBeanDefinition) {\n\t\t\t\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);\n\t\t\t\t}\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (checkCandidate(beanName, candidate)) {\n\t\t\t\t\tBeanDefinitionHolder definitionHolder = <span class=\"hljs-keyword\">new</span> BeanDefinitionHolder(candidate, beanName);\n\t\t\t\t\tdefinitionHolder =\n\t\t\t\t\t\t\tAnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class=\"hljs-keyword\">this</span>.registry);\n\t\t\t\t\tbeanDefinitions.add(definitionHolder);\n\t\t\t\t\tregisterBeanDefinition(definitionHolder, <span class=\"hljs-keyword\">this</span>.registry);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t<span class=\"hljs-keyword\">return</span> beanDefinitions;\n\t}\n</code></pre>\n<ul>\n<li>ClassPathScanningCandidateComponentProvider 扫描给定包及其子包的类</li>\n</ul>\n<pre><code class=\"language-java\">\t<span class=\"hljs-comment\">//核心的扫描方法。</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> Set&lt;BeanDefinition&gt; <span class=\"hljs-title\">scanCandidateComponents</span><span class=\"hljs-params\">(String basePackage)</span> </span>{\n\t\tSet&lt;BeanDefinition&gt; candidates = <span class=\"hljs-keyword\">new</span> LinkedHashSet&lt;&gt;();\n\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\tString packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +\n\t\t\t\t\tresolveBasePackage(basePackage) + <span class=\"hljs-string\">'/'</span> + <span class=\"hljs-keyword\">this</span>.resourcePattern;\n\t\t\tResource[] resources = getResourcePatternResolver().getResources(packageSearchPath);\n\t\t\t<span class=\"hljs-keyword\">boolean</span> traceEnabled = logger.isTraceEnabled();\n\t\t\t<span class=\"hljs-keyword\">boolean</span> debugEnabled = logger.isDebugEnabled();\n\t\t\t<span class=\"hljs-keyword\">for</span> (Resource resource : resources) {\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (traceEnabled) {\n\t\t\t\t\tlogger.trace(<span class=\"hljs-string\">\"Scanning \"</span> + resource);\n\t\t\t\t}\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (resource.isReadable()) {\n\t\t\t\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\t\t\t\tMetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);\n\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (isCandidateComponent(metadataReader)) {\n\t\t\t\t\t\t\tScannedGenericBeanDefinition sbd = <span class=\"hljs-keyword\">new</span> ScannedGenericBeanDefinition(metadataReader);\n\t\t\t\t\t\t\tsbd.setSource(resource);\n\t\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (isCandidateComponent(sbd)) {\n\t\t\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (debugEnabled) {\n\t\t\t\t\t\t\t\t\tlogger.debug(<span class=\"hljs-string\">\"Identified candidate component class: \"</span> + resource);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcandidates.add(sbd);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t<span class=\"hljs-keyword\">else</span> {\n\t\t\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (debugEnabled) {\n\t\t\t\t\t\t\t\t\tlogger.debug(<span class=\"hljs-string\">\"Ignored because not a concrete top-level class: \"</span> + resource);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t<span class=\"hljs-keyword\">else</span> {\n\t\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (traceEnabled) {\n\t\t\t\t\t\t\t\tlogger.trace(<span class=\"hljs-string\">\"Ignored because not matching any filter: \"</span> + resource);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t<span class=\"hljs-keyword\">catch</span> (Throwable ex) {\n\t\t\t\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> BeanDefinitionStoreException(\n\t\t\t\t\t\t\t\t<span class=\"hljs-string\">\"Failed to read candidate component class: \"</span> + resource, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t<span class=\"hljs-keyword\">else</span> {\n\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (traceEnabled) {\n\t\t\t\t\t\tlogger.trace(<span class=\"hljs-string\">\"Ignored because not readable: \"</span> + resource);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t<span class=\"hljs-keyword\">catch</span> (IOException ex) {\n\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> BeanDefinitionStoreException(<span class=\"hljs-string\">\"I/O failure during classpath scanning\"</span>, ex);\n\t\t}\n\t\t<span class=\"hljs-keyword\">return</span> candidates;\n\t}\n\n</code></pre>\n<h2 id=\"%E6%B3%A8%E5%86%8C%E6%B3%A8%E8%A7%A3-beandefinition\">注册注解 BeanDefinition <a class=\"header-anchor\" href=\"#%E6%B3%A8%E5%86%8C%E6%B3%A8%E8%A7%A3-beandefinition\">#</a></h2>\n<p>AnnotationConfigWebApplicationContext 是 AnnotationConfigApplicationContext 的 Web 版， 它们对于注解 Bean 的注册和扫描是基本相同的，但是 AnnotationConfigWebApplicationContext 对注解 Bean 定义的载入稍有不同，AnnotationConfigWebApplicationContext 注入注解 Bean 定义</p>\n<pre><code class=\"language-java\">\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerBeanDefinition</span><span class=\"hljs-params\">(String beanName, BeanDefinition beanDefinition)</span>\n\t\t\t<span class=\"hljs-keyword\">throws</span> BeanDefinitionStoreException </span>{\n\n\t\tAssert.hasText(beanName, <span class=\"hljs-string\">\"Bean name must not be empty\"</span>);\n\t\tAssert.notNull(beanDefinition, <span class=\"hljs-string\">\"BeanDefinition must not be null\"</span>);\n\n\t\t<span class=\"hljs-keyword\">if</span> (beanDefinition <span class=\"hljs-keyword\">instanceof</span> AbstractBeanDefinition) {\n\t\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\t\t((AbstractBeanDefinition) beanDefinition).validate();\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">catch</span> (BeanDefinitionValidationException ex) {\n\t\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t<span class=\"hljs-string\">\"Validation of bean definition failed\"</span>, ex);\n\t\t\t}\n\t\t}\n\n\t\tBeanDefinition existingDefinition = <span class=\"hljs-keyword\">this</span>.beanDefinitionMap.get(beanName);\n\t\t<span class=\"hljs-keyword\">if</span> (existingDefinition != <span class=\"hljs-keyword\">null</span>) {\n\t\t\t<span class=\"hljs-keyword\">if</span> (!isAllowBeanDefinitionOverriding()) {\n\t\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) {\n\t\t\t\t<span class=\"hljs-comment\">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span>\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(<span class=\"hljs-string\">\"Overriding user-defined bean definition for bean '\"</span> + beanName +\n\t\t\t\t\t\t\t<span class=\"hljs-string\">\"' with a framework-generated bean definition: replacing [\"</span> +\n\t\t\t\t\t\t\texistingDefinition + <span class=\"hljs-string\">\"] with [\"</span> + beanDefinition + <span class=\"hljs-string\">\"]\"</span>);\n\t\t\t\t}\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!beanDefinition.equals(existingDefinition)) {\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(<span class=\"hljs-string\">\"Overriding bean definition for bean '\"</span> + beanName +\n\t\t\t\t\t\t\t<span class=\"hljs-string\">\"' with a different definition: replacing [\"</span> + existingDefinition +\n\t\t\t\t\t\t\t<span class=\"hljs-string\">\"] with [\"</span> + beanDefinition + <span class=\"hljs-string\">\"]\"</span>);\n\t\t\t\t}\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">else</span> {\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(<span class=\"hljs-string\">\"Overriding bean definition for bean '\"</span> + beanName +\n\t\t\t\t\t\t\t<span class=\"hljs-string\">\"' with an equivalent definition: replacing [\"</span> + existingDefinition +\n\t\t\t\t\t\t\t<span class=\"hljs-string\">\"] with [\"</span> + beanDefinition + <span class=\"hljs-string\">\"]\"</span>);\n\t\t\t\t}\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">this</span>.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t}\n\t\t<span class=\"hljs-keyword\">else</span> {\n\t\t\t<span class=\"hljs-keyword\">if</span> (hasBeanCreationStarted()) {\n\t\t\t\t<span class=\"hljs-comment\">// Cannot modify startup-time collection elements anymore (for stable iteration)</span>\n\t\t\t\t<span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>.beanDefinitionMap) {\n\t\t\t\t\t<span class=\"hljs-keyword\">this</span>.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\t\tList&lt;String&gt; updatedDefinitions = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;(<span class=\"hljs-keyword\">this</span>.beanDefinitionNames.size() + <span class=\"hljs-number\">1</span>);\n\t\t\t\t\tupdatedDefinitions.addAll(<span class=\"hljs-keyword\">this</span>.beanDefinitionNames);\n\t\t\t\t\tupdatedDefinitions.add(beanName);\n\t\t\t\t\t<span class=\"hljs-keyword\">this</span>.beanDefinitionNames = updatedDefinitions;\n\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.manualSingletonNames.contains(beanName)) {\n\t\t\t\t\t\tSet&lt;String&gt; updatedSingletons = <span class=\"hljs-keyword\">new</span> LinkedHashSet&lt;&gt;(<span class=\"hljs-keyword\">this</span>.manualSingletonNames);\n\t\t\t\t\t\tupdatedSingletons.remove(beanName);\n\t\t\t\t\t\t<span class=\"hljs-keyword\">this</span>.manualSingletonNames = updatedSingletons;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">else</span> {\n\t\t\t\t<span class=\"hljs-comment\">// Still in startup registration phase</span>\n\t\t\t\t<span class=\"hljs-keyword\">this</span>.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\t<span class=\"hljs-keyword\">this</span>.beanDefinitionNames.add(beanName);\n\t\t\t\t<span class=\"hljs-keyword\">this</span>.manualSingletonNames.remove(beanName);\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">this</span>.frozenBeanDefinitionNames = <span class=\"hljs-keyword\">null</span>;\n\t\t}\n\n\t\t<span class=\"hljs-keyword\">if</span> (existingDefinition != <span class=\"hljs-keyword\">null</span> || containsSingleton(beanName)) {\n\t\t\tresetBeanDefinition(beanName);\n\t\t}\n\t}\n</code></pre>\n<h2 id=\"%E6%80%BB%E7%BB%93\">总结 <a class=\"header-anchor\" href=\"#%E6%80%BB%E7%BB%93\">#</a></h2>\n<p>IOC 容器初始化的基本步骤:</p>\n<p>1、初始化的入口在容器实现中的 refresh()调用来完成。</p>\n<p>2、对 Bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition(),其中的大致过程如下:通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader 是默认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统,URL 等 方式来定为资源位置。如果是 XmlBeanFactory 作为 IOC 容器，那么需要为它指定 Bean 定义的资源， 也就是说 Bean 定义文件时通过抽象成 Resource 来被 IOC 容器处理的，容器通过 BeanDefinitionReader 来完成定义信息的解析和 Bean 信息的注册,往往使用的是XmlBeanDefinitionReader 来解析 Bean 的 XML 定义文件-实际的处理过程是委托给 BeanDefinitionParserDelegate 来完成的，从而得到 bean 的定义信息，这些信息在 Spring 中使用 BeanDefinition 对象来表示-这个名字可以让我们想到 loadBeanDefinition(),registerBeanDefinition() 这些相关方法。它们都是为处理 BeanDefinitin 服务的，容器解析得到 BeanDefinition 以后，需要把 它在 IOC 容器中注册，这由 IOC 实现 BeanDefinitionRegistry 接口来实现。注册过程就是在 IOC 容器 内部维护的一个 HashMap 来保存得到的 BeanDefinition 的过程。这个 HashMap 是 IOC 容器持有 Bean 信息的场所，以后对 Bean 的操作都是围绕这个 HashMap 来实现的。</p>\n<p>然后我们就可以通过 BeanFactory 和 ApplicationContext 来享受到 Spring IOC 的服务了,在使用 IOC 容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IOC 风格编写的应用程序代码完全不用关 心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已 知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。Spring 本身提供了对声明式载入 web 应用程序用法的应用程序上下文,并将其存储在 ServletContext 中的框架 实现。</p>\n",
  "link": "/zh-cn/docs/5.框架/spring/3.IOC的注解方式源码解析.html",
  "meta": {}
}