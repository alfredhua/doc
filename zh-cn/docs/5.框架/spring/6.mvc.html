<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="6.mvc" />
	<meta name="description" content="6.mvc" />
	<!-- 网页标签标题 -->
	<title>6.mvc</title>
	<link rel="shortcut icon" href="/product/img/docsite.ico"/>
	<link rel="stylesheet" href="/product/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a class="logo" href="/product/zh-cn/index.html"><span class="logo-normal">码农阿华| <span class="logo-desc">玩玩技术，说说产品</span></span></a><div class="search search-normal"><span class="icon-search"></span></div><div class="header-menu"><img class="header-menu-toggle" src="/product/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/product/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/product/zh-cn/docs/begin.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/product/zh-cn/blog/index.html" target="_self">博客</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/product/img/system/docs.png" class="front-img"/><span>文档</span><img src="/product/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>设计模式</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>设计原则<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/1.设计模式/2.开闭原则.html" target="_self">开闭原则</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/1.设计模式/3.接口隔离原则.html" target="_self">接口隔离原则</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/1.设计模式/4.工厂模式.html" target="_self">工厂模式</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/1.设计模式/5.单例模式.html" target="_self">单例模式</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/1.设计模式/6.原型模式.html" target="_self">原型模式</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/1.设计模式/7.代理模式.html" target="_self">代理模式</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/1.设计模式/8.策略模式.html" target="_self">策略模式</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/1.设计模式/9.委派模式和适配器模式.html" target="_self">委派模式和适配器模式</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/1.设计模式/10.装饰器模式.html" target="_self">装饰器模式</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>JAVA</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>基础<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/基础/1.HashMap.html" target="_self">HashMap</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/基础/2.integer.html" target="_self">integer</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/基础/3.calculations.html" target="_self">calculations</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/基础/4.LinkedHashMap.html" target="_self">LinkedHashMap</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/基础/5.list.html" target="_self">list</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/基础/6.reference.html" target="_self">reference</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/基础/7.synchronized.html" target="_self">synchronized</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/基础/8.volatile.html" target="_self">volatile</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>JVM<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/jvm/1.jvm类加载.html" target="_self">jvm类加载</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/jvm/2.栈帧.html" target="_self">栈帧</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/jvm/3.内存模型.html" target="_self">内存模型</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/jvm/4.垃圾回收.html" target="_self">垃圾回收</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/jvm/5.垃圾收集器.html" target="_self">垃圾收集器</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/jvm/6.JVM参数.html" target="_self">JVM参数</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/jvm/7.JVM常用命令.html" target="_self">JVM常用命令</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/jvm/8.JVM常用工具.html" target="_self">JVM常用工具</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/jvm/9.常见问题.html" target="_self">常见问题</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>网络编程<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/网络编程/1.Http.html" target="_self">Http</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/网络编程/2.Socket.html" target="_self">Socket</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>并发编程<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/并发/1.并发基本概念.html" target="_self">并发基本概念</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/并发/2.并发级别.html" target="_self">并发级别</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/并发/3.CountDownLatch.html" target="_self">CountDownLatch</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/并发/4.CyclicBarrier.html" target="_self">CyclicBarrier</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/并发/5.线程池.html" target="_self">线程池</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/并发/6.原子类.html" target="_self">原子类</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/2.java/并发/7.锁.html" target="_self">锁</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>数据库</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>MySQL<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/mysql/1.mysql安装与卸载.html" target="_self">mysql安装与卸载</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/mysql/2.忘记和修改密码.html" target="_self">忘记和修改密码</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/mysql/3.Mysql的基本语法.html" target="_self">Mysql的基本语法</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/mysql/4.mysql索引.html" target="_self">mysql索引</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/mysql/5.SQL的执行流程.html" target="_self">SQL的执行流程</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/mysql/6.MySQL的存储结构.html" target="_self">MySQL的存储结构</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/mysql/7.MySQL事务.html" target="_self">MySQL事务</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/mysql/8.MySQL锁.html" target="_self">MySQL锁</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/mysql/9.性能优化.html" target="_self">性能优化</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>ElasticSearch<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/elasticsearch/1.安装.html" target="_self">安装</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/elasticsearch/2.基本概念.html" target="_self">基本概念</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/elasticsearch/3.logstash导入数据.html" target="_self">logstash导入数据</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/elasticsearch/4.基本操作.html" target="_self">基本操作</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/elasticsearch/5.Index操作.html" target="_self">Index操作</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/elasticsearch/6.CRUD.html" target="_self">CRUD</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/elasticsearch/7.集群操作.html" target="_self">集群操作</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/elasticsearch/8.多字段特性及自定义Analyzer.html" target="_self">多字段特性及自定义Analyzer</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/elasticsearch/.DS_Stohtml" target="_self">S_St</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/elasticsearch/9.IndexTemplate.html" target="_self">IndexTemplate</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/elasticsearch/10.聚合.html" target="_self">.聚合</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/elasticsearch/11.Term和全文本查询.html" target="_self">.Term和全文本查询</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/elasticsearch/12.错误.html" target="_self">.错误</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>ClickHouse<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/clickhouse/1.介绍.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/clickhouse/2.安装教程.html" target="_self">安装教程</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/clickhouse/3.JAVA接入.html" target="_self">JAVA接入</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/clickhouse/4.SQL语法.html" target="_self">SQL语法</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/clickhouse/5.Mysql迁移.html" target="_self">Mysql迁移</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/clickhouse/5.引擎engine.html" target="_self">引擎engine</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/3.数据库/clickhouse/6.HDFS.html" target="_self">HDFS</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>MQ</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>RabbitMQ<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/4.mq/rabbitmq/1.安装.html" target="_self">安装</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/4.mq/rabbitmq/2.消息模式.html" target="_self">消息模式</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/4.mq/rabbitmq/3.基本操作.html" target="_self">基本操作</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/4.mq/rabbitmq/4.消息可靠性投递.html" target="_self">消息可靠性投递</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/4.mq/rabbitmq/5.重复消费.html" target="_self">重复消费</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/4.mq/rabbitmq/6.消息丢失问题.html" target="_self">消息丢失问题</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/4.mq/rabbitmq/7.高可用.html" target="_self">高可用</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/4.mq/rabbitmq/8.消息积压.html" target="_self">消息积压</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/4.mq/rabbitmq/9.死信队列.html" target="_self">死信队列</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/4.mq/rabbitmq/10.如何设计一个MQ.html" target="_self">.如何设计一个MQ</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>框架</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>MyBatis<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/mybatis/1.jdbc连接流程.html" target="_self">jdbc连接流程</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/mybatis/2.源码解读.html" target="_self">源码解读</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/mybatis/3.手写mybatis.html" target="_self">手写mybatis</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/mybatis/4.ORM.html" target="_self">ORM</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>Spring<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/spring/1.基本教程.html" target="_self">基本教程</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/spring/2.IOC的XML方式源码分析.html" target="_self">IOC的XML方式源码分析</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/spring/3.IOC的注解方式源码解析.html" target="_self">IOC的注解方式源码解析</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/spring/4.DI源码解析.html" target="_self">DI源码解析</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/spring/5.AOP源码分析.html" target="_self">AOP源码分析</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/spring/6.mvc.html" target="_self">mvc</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/spring/7.事务.html" target="_self">事务</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>spring-boot<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/spring-boot/1.SpringBoot初识.html" target="_self">SpringBoot初识</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/spring-boot/2.源码解读.html" target="_self">源码解读</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>spring-cloud<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/spring-cloud/1.consul.html" target="_self">consul</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/spring-cloud/2.Ribbon.html" target="_self">Ribbon</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/spring-cloud/3.feign.html" target="_self">feign</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/spring-cloud/4.Config.html" target="_self">Config</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/5.框架/spring-cloud/5.Hystrix.html" target="_self">Hystrix</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>缓存</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>Redis<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/6.缓存/redis/1.安装.html" target="_self">安装</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/6.缓存/redis/2.数据类型.html" target="_self">数据类型</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/6.缓存/redis/3.应用场景.html" target="_self">应用场景</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/6.缓存/redis/4.单线程模型.html" target="_self">单线程模型</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/6.缓存/redis/5.过期策略.html" target="_self">过期策略</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/6.缓存/redis/6.数据恢复.html" target="_self">数据恢复</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/6.缓存/redis/7.哨兵模式.html" target="_self">哨兵模式</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/6.缓存/redis/8.缓冲.html" target="_self">缓冲</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/6.缓存/redis/9.RedisTemplate.html" target="_self">RedisTemplate</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/6.缓存/redis/10.集群.html" target="_self">集群</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/6.缓存/redis/11.lock.html" target="_self">lock</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>分布式</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>zookeeper<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/7.分布式/zookeeper/1.基本概念.html" target="_self">基本概念</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/7.分布式/zookeeper/2.操作.html" target="_self">操作</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/7.分布式/zookeeper/3.使用场景.html" target="_self">使用场景</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/7.分布式/zookeeper/4.分布式锁.html" target="_self">分布式锁</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/7.分布式/zookeeper/5.分布式一致性.html" target="_self">分布式一致性</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/7.分布式/zookeeper/6.集群搭建.html" target="_self">集群搭建</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>服务器</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/product/zh-cn/docs/8.服务器/1.centos下软件安装.html" target="_self">centos下软件安装</a></li></ul></li><li class="menu-item menu-item-level-1"><span>算法</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>算法<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/9.算法/1.递归.html" target="_self">递归</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/9.算法/2.排序.html" target="_self">排序</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/9.算法/3.双子针.html" target="_self">双子针</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/9.算法/4.回溯.html" target="_self">回溯</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>工具</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>arthas<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/10.工具/arthas/1.安装.html" target="_self">安装</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/10.工具/arthas/2.dashboard.html" target="_self">dashboard</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/10.工具/arthas/3.thread.html" target="_self">thread</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/10.工具/arthas/4.JVM.html" target="_self">JVM</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>docker<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/10.工具/docker/1.安装.html" target="_self">安装</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>k8s<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/10.工具/k8s/1.环境搭建.html" target="_self">环境搭建</a></li><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/10.工具/k8s/2.kubectl.html" target="_self">kubectl</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>maven<img style="transform:rotate(-90deg)" class="menu-toggle" src="/product/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/product/zh-cn/docs/10.工具/maven/1.解决依赖冲突.html" target="_self">解决依赖冲突</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>面试</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/product/zh-cn/docs/面试/java基础.html" target="_self">java基础</a></li></ul></li></ul></div><div class="doc-content markdown-body"><h1 id="mvc">MVC <a class="header-anchor" href="#mvc">#</a></h1>
<p>首先引用《Spring in Action》上 的一张图来了解 Spring MVC 的核心组件和大致处理流程：
<img src="http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/b31bdbab09eb4d9f9720f31bd92e8ba1.png" alt="image"></p>
<p>从上图中看到</p>
<ol>
<li>DispatcherServlet 是 SpringMVC 中的前端控制器(Front Controller), 负责接收 Request 并将 Request 转发给对应的处理组件。</li>
<li>HanlerMapping 是 SpringMVC 中完成 url 到 Controller 映射的组件。 DispatcherServlet 接收 Request,然后从 HandlerMapping 查找处理 Request 的 Controller。</li>
<li>Controller 处理 Request,并返回 ModelAndView 对象,Controller 是 SpringMVC 中负责处理 Request 的组件(类似于 Struts2 中的 Action),ModelAndView 是封装结果 视图的组件。</li>
<li>第4，5，6步视图解析器解析 ModelAndView 对象并返回对应的视图给客户端。</li>
</ol>
<p>容器初始化时会建立所有 url 和 Controller 中的 Method 的对应关系，保存到 HandlerMapping 中，用户请求是根据 Request 请求的 url 快速定位到 Controller 中的某个方法。在 Spring 中先将 url 和 Controller 的对应关 系,保存到 Map&lt;url,Controller&gt;中。Web 容器启动时会通知 Spring 初始化容器(加载 Bean 的定义信息和初始化所有单例 Bean),然后 SpringMVC 会遍历容器中的 Bean，获 取每一个 Controller 中的所有方法访问的 url，然后将 url 和 Controller 保存到一个 Map 中;这样就可以根据 Request 快速定位到 Controller，因为最终处理 Request 的是 Controller 中的方法，Map 中只保留了 url 和 Controller 中的对应关系，所以要根据 Request 的 url 进一步确认 Controller 中的 Method，这一步工作的原理就是拼接 Controller 的 url(Controller 上@RequestMapping 的值)和方法的 url(Method 上 @RequestMapping 的值)，与 request 的 url 进行匹配，找到匹配的那个方法;确定处 理请求的 Method 后，接下来的任务就是参数绑定，把 Request 中参数绑定到方法的形 式参数上，这一步是整个请求处理过程中最复杂的一个步骤。</p>
<h1 id="%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">源码分析 <a class="header-anchor" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">#</a></h1>
<p>根据上面分析的 Spring MVC 工作机制，从三个部分来分析 Spring MVC 的源代码。 其一，ApplicationContext 初始化时用 Map 保存所有 url 和 Controller 类的对应关系; 其二，根据请求 url 找到对应的 Controller，并从 Controller 中找到处理请求的方法; 其三，Request 参数绑定到方法的形参，执行方法处理请求，并返回结果视图。</p>
<h2 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5">初始化阶段 <a class="header-anchor" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5">#</a></h2>
<p>我们首先找到 DispatcherServlet 这个类，必然是寻找 init()方法。然后，我们发现其 init 方法其实在父类 HttpServletBean 中，其源码如下:</p>
<pre><code class="language-java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>{

		<span class="hljs-comment">// Set bean properties from init parameters.</span>
		PropertyValues pvs = <span class="hljs-keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="hljs-keyword">this</span>.requiredProperties);
		<span class="hljs-keyword">if</span> (!pvs.isEmpty()) {
			<span class="hljs-keyword">try</span> {
				BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="hljs-keyword">this</span>);
				ResourceLoader resourceLoader = <span class="hljs-keyword">new</span> ServletContextResourceLoader(getServletContext());
				bw.registerCustomEditor(Resource<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">new</span> <span class="hljs-title">ResourceEditor</span>(<span class="hljs-title">resourceLoader</span>, <span class="hljs-title">getEnvironment</span>()))</span>;
				initBeanWrapper(bw);
				bw.setPropertyValues(pvs, <span class="hljs-keyword">true</span>);
			}
			<span class="hljs-keyword">catch</span> (BeansException ex) {
				<span class="hljs-keyword">if</span> (logger.isErrorEnabled()) {
					logger.error(<span class="hljs-string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="hljs-string">"'"</span>, ex);
				}
				<span class="hljs-keyword">throw</span> ex;
			}
		}

		<span class="hljs-comment">// Let subclasses do whatever initialization they like.</span>
		initServletBean();
	}

    <span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initServletBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>{
		getServletContext().log(<span class="hljs-string">"Initializing Spring "</span> + getClass().getSimpleName() + <span class="hljs-string">" '"</span> + getServletName() + <span class="hljs-string">"'"</span>);
		<span class="hljs-keyword">if</span> (logger.isInfoEnabled()) {
			logger.info(<span class="hljs-string">"Initializing Servlet '"</span> + getServletName() + <span class="hljs-string">"'"</span>);
		}
		<span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();

		<span class="hljs-keyword">try</span> {
			<span class="hljs-keyword">this</span>.webApplicationContext = initWebApplicationContext();
			initFrameworkServlet();
		}
		<span class="hljs-keyword">catch</span> (ServletException | RuntimeException ex) {
			logger.error(<span class="hljs-string">"Context initialization failed"</span>, ex);
			<span class="hljs-keyword">throw</span> ex;
		}

		<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
			String value = <span class="hljs-keyword">this</span>.enableLoggingRequestDetails ?
					<span class="hljs-string">"shown which may lead to unsafe logging of potentially sensitive data"</span> :
					<span class="hljs-string">"masked to prevent unsafe logging of potentially sensitive data"</span>;
			logger.debug(<span class="hljs-string">"enableLoggingRequestDetails='"</span> + <span class="hljs-keyword">this</span>.enableLoggingRequestDetails +
					<span class="hljs-string">"': request parameters and headers will be "</span> + value);
		}

		<span class="hljs-keyword">if</span> (logger.isInfoEnabled()) {
			logger.info(<span class="hljs-string">"Completed initialization in "</span> + (System.currentTimeMillis() - startTime) + <span class="hljs-string">" ms"</span>);
		}
	}

</code></pre>
<p>这段代码中最主要的逻辑就是初始化 IOC 容器，最终会调用 refresh()方法.</p>
<pre><code class="language-java">
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">(ApplicationContext context)</span> </span>{
		initStrategies(context);
	}
	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initStrategies</span><span class="hljs-params">(ApplicationContext context)</span> </span>{
		<span class="hljs-comment">//本地文件上传</span>
		initMultipartResolver(context);
		<span class="hljs-comment">//本地化解析</span>
		initLocaleResolver(context);
		<span class="hljs-comment">//主题解析</span>
		initThemeResolver(context);
		<span class="hljs-comment">//通过HandlerMapping，将请求映射到处理器</span>
		initHandlerMappings(context);
		<span class="hljs-comment">//通过HandlerAdapter进行多类型的参数动态匹配</span>
		initHandlerAdapters(context);
		<span class="hljs-comment">//如果执行过程中遇到异常，将交给HandlerExceptionResolver来解析</span>
		initHandlerExceptionResolvers(context);
		<span class="hljs-comment">//直接解析请求到视图名</span>
		initRequestToViewNameTranslator(context);
		<span class="hljs-comment">//通过viewResolver解析逻辑视图到具体视图实现</span>
		initViewResolvers(context);
		<span class="hljs-comment">//flash映射管理器</span>
		initFlashMapManager(context);
	}

</code></pre>
<p>到这一步就完成了 Spring MVC 的九大组件的初始化。接下来，我们来看 url 和 Controller 的 关 系 是 如 何 建 立 的 呢 ? HandlerMapping 的 子 类 AbstractDetectingUrlHandlerMapping 实现了 initApplicationContext()方法，所以 我们直接看子类中的初始化容器方法。</p>
<pre><code class="language-java">
    @Override
	public void initApplicationContext() throws ApplicationContextException {
		super.initApplicationContext();
		detectHandlers();
	}

	protected void detectHandlers() throws BeansException {
		ApplicationContext applicationContext = obtainApplicationContext();
		String[] beanNames = (this.detectHandlersInAncestorContexts ?
				BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class) :
				applicationContext.getBeanNamesForType(Object.class));

		// Take any bean name that we can determine URLs for.
		for (String beanName : beanNames) {
			String[] urls = determineUrlsForHandler(beanName);
			if (!ObjectUtils.isEmpty(urls)) {
				// URL paths found: Let's consider it a handler.
				registerHandler(urls, beanName);
			}
		}

		if ((logger.isDebugEnabled() &amp;&amp; !getHandlerMap().isEmpty()) || logger.isTraceEnabled()) {
			logger.debug("Detected " + getHandlerMap().size() + " mappings in " + formatMappingName());
		}
	}
</code></pre>
<h2 id="%E8%BF%90%E8%A1%8C%E8%B0%83%E7%94%A8%E9%98%B6%E6%AE%B5">运行调用阶段 <a class="header-anchor" href="#%E8%BF%90%E8%A1%8C%E8%B0%83%E7%94%A8%E9%98%B6%E6%AE%B5">#</a></h2>
<p>这一步步是由请求触发的，所以入口为 DispatcherServlet 的核心方法为 doService()， doService()中的核心逻辑由 doDispatch()实现，源代码如下:</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>{
		HttpServletRequest processedRequest = request;
		HandlerExecutionChain mappedHandler = <span class="hljs-keyword">null</span>;
		<span class="hljs-keyword">boolean</span> multipartRequestParsed = <span class="hljs-keyword">false</span>;

		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

		<span class="hljs-keyword">try</span> {
			ModelAndView mv = <span class="hljs-keyword">null</span>;
			Exception dispatchException = <span class="hljs-keyword">null</span>;

			<span class="hljs-keyword">try</span> {
				processedRequest = checkMultipart(request);
				multipartRequestParsed = (processedRequest != request);

				<span class="hljs-comment">// Determine handler for the current request.</span>
                <span class="hljs-comment">// 2.取得处理当前请求的 Controller,这里也称为 hanlder,处理器,</span>
                <span class="hljs-comment">// 第一个步骤的意义就在这里体现了.这里并不是直接返回 Controller,</span>
                <span class="hljs-comment">// 而是返回的 HandlerExecutionChain 请求处理器链对象,</span>
                <span class="hljs-comment">// 该对象封装了 handler 和 interceptors.</span>
				mappedHandler = getHandler(processedRequest);
                <span class="hljs-comment">// 如果 handler 为空,则返回 404</span>
				<span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-keyword">null</span>) {
					noHandlerFound(processedRequest, response);
					<span class="hljs-keyword">return</span>;
				}

				<span class="hljs-comment">// Determine handler adapter for the current request.</span>
                <span class="hljs-comment">//3. 获取处理 request 的处理器适配器 handler adapter</span>
				HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

				<span class="hljs-comment">// Process last-modified header, if supported by the handler.</span>
				String method = request.getMethod();
				<span class="hljs-keyword">boolean</span> isGet = <span class="hljs-string">"GET"</span>.equals(method);
				<span class="hljs-keyword">if</span> (isGet || <span class="hljs-string">"HEAD"</span>.equals(method)) {
					<span class="hljs-keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) {
						<span class="hljs-keyword">return</span>;
					}
				}

				<span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) {
					<span class="hljs-keyword">return</span>;
				}

				<span class="hljs-comment">// Actually invoke the handler.</span>
                <span class="hljs-comment">//4.实际的处理器处理请求,返回结果视图对象</span>
				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

				<span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {
					<span class="hljs-keyword">return</span>;
				}

				applyDefaultViewName(processedRequest, mv);
				mappedHandler.applyPostHandle(processedRequest, response, mv);
			}
			<span class="hljs-keyword">catch</span> (Exception ex) {
				dispatchException = ex;
			}
			<span class="hljs-keyword">catch</span> (Throwable err) {
				<span class="hljs-comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span>
				<span class="hljs-comment">// making them available for @ExceptionHandler methods and other scenarios.</span>
				dispatchException = <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Handler dispatch failed"</span>, err);
			}
			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
		}
		<span class="hljs-keyword">catch</span> (Exception ex) {
			triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
		}
		<span class="hljs-keyword">catch</span> (Throwable err) {
			triggerAfterCompletion(processedRequest, response, mappedHandler,
					<span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Handler processing failed"</span>, err));
		}
		<span class="hljs-keyword">finally</span> {
			<span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {
				<span class="hljs-comment">// Instead of postHandle and afterCompletion</span>
				<span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-keyword">null</span>) {
					mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
				}
			}
			<span class="hljs-keyword">else</span> {
				<span class="hljs-comment">// Clean up any resources used by a multipart request.</span>
				<span class="hljs-keyword">if</span> (multipartRequestParsed) {
					cleanupMultipart(processedRequest);
				}
			}
		}
	}

<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>{
		logRequest(request);

		<span class="hljs-comment">// Keep a snapshot of the request attributes in case of an include,</span>
		<span class="hljs-comment">// to be able to restore the original attributes after the include.</span>
		Map&lt;String, Object&gt; attributesSnapshot = <span class="hljs-keyword">null</span>;
		<span class="hljs-keyword">if</span> (WebUtils.isIncludeRequest(request)) {
			attributesSnapshot = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
			Enumeration&lt;?&gt; attrNames = request.getAttributeNames();
			<span class="hljs-keyword">while</span> (attrNames.hasMoreElements()) {
				String attrName = (String) attrNames.nextElement();
				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {
					attributesSnapshot.put(attrName, request.getAttribute(attrName));
				}
			}
		}

		<span class="hljs-comment">// Make framework objects available to handlers and view objects.</span>
		request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
		request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="hljs-keyword">this</span>.localeResolver);
		request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="hljs-keyword">this</span>.themeResolver);
		request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());

		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.flashMapManager != <span class="hljs-keyword">null</span>) {
			FlashMap inputFlashMap = <span class="hljs-keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);
			<span class="hljs-keyword">if</span> (inputFlashMap != <span class="hljs-keyword">null</span>) {
				request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));
			}
			request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="hljs-keyword">new</span> FlashMap());
			request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="hljs-keyword">this</span>.flashMapManager);
		}

		<span class="hljs-keyword">try</span> {
			doDispatch(request, response);
		}
		<span class="hljs-keyword">finally</span> {
			<span class="hljs-keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
				<span class="hljs-comment">// Restore the original attribute snapshot, in case of an include.</span>
				<span class="hljs-keyword">if</span> (attributesSnapshot != <span class="hljs-keyword">null</span>) {
					restoreAttributesAfterInclude(request, attributesSnapshot);
				}
			}
		}
	}
</code></pre>
<p>getHandler(processedRequest)方法实际上就是从 HandlerMapping 中找到 url 和 Controller 的对应关系。也就是 Map&lt;url,Controller&gt;。我们知道，最终处理 Request 的是 Controller 中的方法，我们现在只是知道了 Controller，我们如何确认 Controller 中处理 Request 的方法呢?继续往下看。
从 Map&lt;urls,beanName&gt;中取得 Controller 后，经过拦截器的预处理方法，再通过反 射获取该方法上的注解和参数，解析方法和参数上的注解，然后反射调用方法获取ModelAndView 结果视图。最后，调用的就是 RequestMappingHandlerAdapter 的 handle()中的核心逻辑由 handleInternal(request, response, handler)实现。</p>
<pre><code class="language-java">
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">handleInternal</span><span class="hljs-params">(HttpServletRequest request,
			HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="hljs-keyword">throws</span> Exception </span>{

		ModelAndView mav;
		checkRequest(request);

		<span class="hljs-comment">// Execute invokeHandlerMethod in synchronized block if required.</span>
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.synchronizeOnSession) {
			HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);
			<span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span>) {
				Object mutex = WebUtils.getSessionMutex(session);
				<span class="hljs-keyword">synchronized</span> (mutex) {
					mav = invokeHandlerMethod(request, response, handlerMethod);
				}
			}
			<span class="hljs-keyword">else</span> {
				<span class="hljs-comment">// No HttpSession available -&gt; no mutex necessary</span>
				mav = invokeHandlerMethod(request, response, handlerMethod);
			}
		}
		<span class="hljs-keyword">else</span> {
			<span class="hljs-comment">// No synchronization on session demanded at all...</span>
			mav = invokeHandlerMethod(request, response, handlerMethod);
		}

		<span class="hljs-keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) {
			<span class="hljs-keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {
				applyCacheSeconds(response, <span class="hljs-keyword">this</span>.cacheSecondsForSessionAttributeHandlers);
			}
			<span class="hljs-keyword">else</span> {
				prepareResponse(response);
			}
		}

		<span class="hljs-keyword">return</span> mav;
	}
</code></pre>
<p>通过上面的代码分析，已经可以找到处理 Request 的 Controller 中的方法了，现在看如 何解析该方法上的参数，并反射调用该方法。</p>
<pre><code class="language-java"><span class="hljs-meta">@Nullable</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">invokeHandlerMethod</span><span class="hljs-params">(HttpServletRequest request,
			HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="hljs-keyword">throws</span> Exception </span>{

		ServletWebRequest webRequest = <span class="hljs-keyword">new</span> ServletWebRequest(request, response);
		<span class="hljs-keyword">try</span> {
			WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
			ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);

			ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.argumentResolvers != <span class="hljs-keyword">null</span>) {
				invocableMethod.setHandlerMethodArgumentResolvers(<span class="hljs-keyword">this</span>.argumentResolvers);
			}
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.returnValueHandlers != <span class="hljs-keyword">null</span>) {
				invocableMethod.setHandlerMethodReturnValueHandlers(<span class="hljs-keyword">this</span>.returnValueHandlers);
			}
			invocableMethod.setDataBinderFactory(binderFactory);
			invocableMethod.setParameterNameDiscoverer(<span class="hljs-keyword">this</span>.parameterNameDiscoverer);

			ModelAndViewContainer mavContainer = <span class="hljs-keyword">new</span> ModelAndViewContainer();
			mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));
			modelFactory.initModel(webRequest, mavContainer, invocableMethod);
			mavContainer.setIgnoreDefaultModelOnRedirect(<span class="hljs-keyword">this</span>.ignoreDefaultModelOnRedirect);

			AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);
			asyncWebRequest.setTimeout(<span class="hljs-keyword">this</span>.asyncRequestTimeout);

			WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
			asyncManager.setTaskExecutor(<span class="hljs-keyword">this</span>.taskExecutor);
			asyncManager.setAsyncWebRequest(asyncWebRequest);
			asyncManager.registerCallableInterceptors(<span class="hljs-keyword">this</span>.callableInterceptors);
			asyncManager.registerDeferredResultInterceptors(<span class="hljs-keyword">this</span>.deferredResultInterceptors);

			<span class="hljs-keyword">if</span> (asyncManager.hasConcurrentResult()) {
				Object result = asyncManager.getConcurrentResult();
				mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="hljs-number">0</span>];
				asyncManager.clearConcurrentResult();
				LogFormatUtils.traceDebug(logger, traceOn -&gt; {
					String formatted = LogFormatUtils.formatValue(result, !traceOn);
					<span class="hljs-keyword">return</span> <span class="hljs-string">"Resume with async result ["</span> + formatted + <span class="hljs-string">"]"</span>;
				});
				invocableMethod = invocableMethod.wrapConcurrentResult(result);
			}

			invocableMethod.invokeAndHandle(webRequest, mavContainer);
			<span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
			}

			<span class="hljs-keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);
		}
		<span class="hljs-keyword">finally</span> {
			webRequest.requestCompleted();
		}
	}


</code></pre>
<p>invocableMethod.invokeAndHandle()最终要实现的目的就是:完成 Request 中的参 数和方法参数上数据的绑定。Spring MVC 中提供两种 Request 参数到方法中参数的绑 定方式:</p>
<p>1、通过注解进行绑定，@RequestParam。</p>
<p>2、通过参数名称进行绑定。</p>
<p>使用注解进行绑定，我们只要在方法参数前面声明@RequestParam(&quot;name&quot;)，就可以 将 request 中参数 name 的值绑定到方法的该参数上。使用参数名称进行绑定的前提是 必须要获取方法中参数的名称，Java 反射只提供了获取方法的参数的类型，并没有提供 获取参数名称的方法。SpringMVC 解决这个问题的方法是用 asm 框架读取字节码文件， 来获取方法的参数名称。asm 框架是一个字节码操作框架，关于 asm 更多介绍可以参考 其官网。个人建议，使用注解来完成参数绑定，这样就可以省去 asm 框架的读取字节码 的操作。</p>
<p>调用时序图：</p>
<p><img src="http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/2f34427cabe349b4ba51ed8ce86d91af.png" alt="image"></p>
<h1 id="spring-mvc-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE">Spring MVC 使用优化建议 <a class="header-anchor" href="#spring-mvc-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE">#</a></h1>
<h2 id="controller-%E5%A6%82%E6%9E%9C%E8%83%BD%E4%BF%9D%E6%8C%81%E5%8D%95%E4%BE%8B%EF%BC%8C%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E5%8D%95%E4%BE%8B">Controller 如果能保持单例，尽量使用单例 <a class="header-anchor" href="#controller-%E5%A6%82%E6%9E%9C%E8%83%BD%E4%BF%9D%E6%8C%81%E5%8D%95%E4%BE%8B%EF%BC%8C%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E5%8D%95%E4%BE%8B">#</a></h2>
<p>这样可以减少创建对象和回收对象的开销。也就是说，如果 Controller 的类变量和实例 变量可以以方法形参声明的尽量以方法的形参声明，不要以类变量和实例变量声明，这 样可以避免线程安全问题。</p>
<h2 id="%E5%A4%84%E7%90%86-request-%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%BD%A2%E5%8F%82%E5%8A%A1%E5%BF%85%E5%8A%A0%E4%B8%8A%40requestparam-%E6%B3%A8%E8%A7%A3">处理 Request 的方法中的形参务必加上@RequestParam 注解 <a class="header-anchor" href="#%E5%A4%84%E7%90%86-request-%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%BD%A2%E5%8F%82%E5%8A%A1%E5%BF%85%E5%8A%A0%E4%B8%8A%40requestparam-%E6%B3%A8%E8%A7%A3">#</a></h2>
<p>这样可以避免 Spring MVC 使用 asm 框架读取 class 文件获取方法参数名的过程。即便 Spring MVC 对读取出的方法参数名进行了缓存，如果不要读取 class 文件当然是更好。</p>
<h2 id="%E7%BC%93%E5%AD%98-url">缓存 URL <a class="header-anchor" href="#%E7%BC%93%E5%AD%98-url">#</a></h2>
<p>阅读源码的过程中，我们发现 Spring MVC 并没有对处理 url 的方法进行缓存，也就是 说每次都要根据请求 url 去匹配 Controller 中的方法 url，如果把 url 和 Method 的关系缓存起来，会不会带来性能上的提升呢?有点恶心的是，负责解析 url 和 Method 对应 关系的 ServletHandlerMethodResolver 是一个 private 的内部类，不能直接继承该类 增强代码，必须要该代码后重新编译。当然，如果缓存起来，必须要考虑缓存的线程安 全问题。</p>
</div></section><footer class="footer-container"><div class="footer-body"><div class="cols-container"><div class="col col-12"><h3>码农阿华</h3><p>联系邮箱：alfredhua@aliyun.com</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/product/zh-cn/docs/demo1.html" target="_self">概览</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/product/zh-cn/blog/index.html" target="_self">博客</a></dd></dl></div></div><div class="copyright"><span>CopyRight©2019 版权所有 码农阿华 京ICP备19044364号</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '/product';
  </script>
	<script src="/product/build/documentation.js"></script>
</body>
</html>