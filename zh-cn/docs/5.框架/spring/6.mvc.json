{
  "filename": "6.mvc.md",
  "__html": "<h1 id=\"mvc\">MVC <a class=\"header-anchor\" href=\"#mvc\">#</a></h1>\n<p>首先引用《Spring in Action》上 的一张图来了解 Spring MVC 的核心组件和大致处理流程：\n<img src=\"http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/b31bdbab09eb4d9f9720f31bd92e8ba1.png\" alt=\"image\"></p>\n<p>从上图中看到</p>\n<ol>\n<li>DispatcherServlet 是 SpringMVC 中的前端控制器(Front Controller), 负责接收 Request 并将 Request 转发给对应的处理组件。</li>\n<li>HanlerMapping 是 SpringMVC 中完成 url 到 Controller 映射的组件。 DispatcherServlet 接收 Request,然后从 HandlerMapping 查找处理 Request 的 Controller。</li>\n<li>Controller 处理 Request,并返回 ModelAndView 对象,Controller 是 SpringMVC 中负责处理 Request 的组件(类似于 Struts2 中的 Action),ModelAndView 是封装结果 视图的组件。</li>\n<li>第4，5，6步视图解析器解析 ModelAndView 对象并返回对应的视图给客户端。</li>\n</ol>\n<p>容器初始化时会建立所有 url 和 Controller 中的 Method 的对应关系，保存到 HandlerMapping 中，用户请求是根据 Request 请求的 url 快速定位到 Controller 中的某个方法。在 Spring 中先将 url 和 Controller 的对应关 系,保存到 Map&lt;url,Controller&gt;中。Web 容器启动时会通知 Spring 初始化容器(加载 Bean 的定义信息和初始化所有单例 Bean),然后 SpringMVC 会遍历容器中的 Bean，获 取每一个 Controller 中的所有方法访问的 url，然后将 url 和 Controller 保存到一个 Map 中;这样就可以根据 Request 快速定位到 Controller，因为最终处理 Request 的是 Controller 中的方法，Map 中只保留了 url 和 Controller 中的对应关系，所以要根据 Request 的 url 进一步确认 Controller 中的 Method，这一步工作的原理就是拼接 Controller 的 url(Controller 上@RequestMapping 的值)和方法的 url(Method 上 @RequestMapping 的值)，与 request 的 url 进行匹配，找到匹配的那个方法;确定处 理请求的 Method 后，接下来的任务就是参数绑定，把 Request 中参数绑定到方法的形 式参数上，这一步是整个请求处理过程中最复杂的一个步骤。</p>\n<h1 id=\"%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\">源码分析 <a class=\"header-anchor\" href=\"#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\">#</a></h1>\n<p>根据上面分析的 Spring MVC 工作机制，从三个部分来分析 Spring MVC 的源代码。 其一，ApplicationContext 初始化时用 Map 保存所有 url 和 Controller 类的对应关系; 其二，根据请求 url 找到对应的 Controller，并从 Controller 中找到处理请求的方法; 其三，Request 参数绑定到方法的形参，执行方法处理请求，并返回结果视图。</p>\n<h2 id=\"%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5\">初始化阶段 <a class=\"header-anchor\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5\">#</a></h2>\n<p>我们首先找到 DispatcherServlet 这个类，必然是寻找 init()方法。然后，我们发现其 init 方法其实在父类 HttpServletBean 中，其源码如下:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> ServletException </span>{\n\n\t\t<span class=\"hljs-comment\">// Set bean properties from init parameters.</span>\n\t\tPropertyValues pvs = <span class=\"hljs-keyword\">new</span> ServletConfigPropertyValues(getServletConfig(), <span class=\"hljs-keyword\">this</span>.requiredProperties);\n\t\t<span class=\"hljs-keyword\">if</span> (!pvs.isEmpty()) {\n\t\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\t\tBeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class=\"hljs-keyword\">this</span>);\n\t\t\t\tResourceLoader resourceLoader = <span class=\"hljs-keyword\">new</span> ServletContextResourceLoader(getServletContext());\n\t\t\t\tbw.registerCustomEditor(Resource<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">new</span> <span class=\"hljs-title\">ResourceEditor</span>(<span class=\"hljs-title\">resourceLoader</span>, <span class=\"hljs-title\">getEnvironment</span>()))</span>;\n\t\t\t\tinitBeanWrapper(bw);\n\t\t\t\tbw.setPropertyValues(pvs, <span class=\"hljs-keyword\">true</span>);\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">catch</span> (BeansException ex) {\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (logger.isErrorEnabled()) {\n\t\t\t\t\tlogger.error(<span class=\"hljs-string\">\"Failed to set bean properties on servlet '\"</span> + getServletName() + <span class=\"hljs-string\">\"'\"</span>, ex);\n\t\t\t\t}\n\t\t\t\t<span class=\"hljs-keyword\">throw</span> ex;\n\t\t\t}\n\t\t}\n\n\t\t<span class=\"hljs-comment\">// Let subclasses do whatever initialization they like.</span>\n\t\tinitServletBean();\n\t}\n\n    <span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initServletBean</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> ServletException </span>{\n\t\tgetServletContext().log(<span class=\"hljs-string\">\"Initializing Spring \"</span> + getClass().getSimpleName() + <span class=\"hljs-string\">\" '\"</span> + getServletName() + <span class=\"hljs-string\">\"'\"</span>);\n\t\t<span class=\"hljs-keyword\">if</span> (logger.isInfoEnabled()) {\n\t\t\tlogger.info(<span class=\"hljs-string\">\"Initializing Servlet '\"</span> + getServletName() + <span class=\"hljs-string\">\"'\"</span>);\n\t\t}\n\t\t<span class=\"hljs-keyword\">long</span> startTime = System.currentTimeMillis();\n\n\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\t<span class=\"hljs-keyword\">this</span>.webApplicationContext = initWebApplicationContext();\n\t\t\tinitFrameworkServlet();\n\t\t}\n\t\t<span class=\"hljs-keyword\">catch</span> (ServletException | RuntimeException ex) {\n\t\t\tlogger.error(<span class=\"hljs-string\">\"Context initialization failed\"</span>, ex);\n\t\t\t<span class=\"hljs-keyword\">throw</span> ex;\n\t\t}\n\n\t\t<span class=\"hljs-keyword\">if</span> (logger.isDebugEnabled()) {\n\t\t\tString value = <span class=\"hljs-keyword\">this</span>.enableLoggingRequestDetails ?\n\t\t\t\t\t<span class=\"hljs-string\">\"shown which may lead to unsafe logging of potentially sensitive data\"</span> :\n\t\t\t\t\t<span class=\"hljs-string\">\"masked to prevent unsafe logging of potentially sensitive data\"</span>;\n\t\t\tlogger.debug(<span class=\"hljs-string\">\"enableLoggingRequestDetails='\"</span> + <span class=\"hljs-keyword\">this</span>.enableLoggingRequestDetails +\n\t\t\t\t\t<span class=\"hljs-string\">\"': request parameters and headers will be \"</span> + value);\n\t\t}\n\n\t\t<span class=\"hljs-keyword\">if</span> (logger.isInfoEnabled()) {\n\t\t\tlogger.info(<span class=\"hljs-string\">\"Completed initialization in \"</span> + (System.currentTimeMillis() - startTime) + <span class=\"hljs-string\">\" ms\"</span>);\n\t\t}\n\t}\n\n</code></pre>\n<p>这段代码中最主要的逻辑就是初始化 IOC 容器，最终会调用 refresh()方法.</p>\n<pre><code class=\"language-java\">\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onRefresh</span><span class=\"hljs-params\">(ApplicationContext context)</span> </span>{\n\t\tinitStrategies(context);\n\t}\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initStrategies</span><span class=\"hljs-params\">(ApplicationContext context)</span> </span>{\n\t\t<span class=\"hljs-comment\">//本地文件上传</span>\n\t\tinitMultipartResolver(context);\n\t\t<span class=\"hljs-comment\">//本地化解析</span>\n\t\tinitLocaleResolver(context);\n\t\t<span class=\"hljs-comment\">//主题解析</span>\n\t\tinitThemeResolver(context);\n\t\t<span class=\"hljs-comment\">//通过HandlerMapping，将请求映射到处理器</span>\n\t\tinitHandlerMappings(context);\n\t\t<span class=\"hljs-comment\">//通过HandlerAdapter进行多类型的参数动态匹配</span>\n\t\tinitHandlerAdapters(context);\n\t\t<span class=\"hljs-comment\">//如果执行过程中遇到异常，将交给HandlerExceptionResolver来解析</span>\n\t\tinitHandlerExceptionResolvers(context);\n\t\t<span class=\"hljs-comment\">//直接解析请求到视图名</span>\n\t\tinitRequestToViewNameTranslator(context);\n\t\t<span class=\"hljs-comment\">//通过viewResolver解析逻辑视图到具体视图实现</span>\n\t\tinitViewResolvers(context);\n\t\t<span class=\"hljs-comment\">//flash映射管理器</span>\n\t\tinitFlashMapManager(context);\n\t}\n\n</code></pre>\n<p>到这一步就完成了 Spring MVC 的九大组件的初始化。接下来，我们来看 url 和 Controller 的 关 系 是 如 何 建 立 的 呢 ? HandlerMapping 的 子 类 AbstractDetectingUrlHandlerMapping 实现了 initApplicationContext()方法，所以 我们直接看子类中的初始化容器方法。</p>\n<pre><code class=\"language-java\">\n    @Override\n\tpublic void initApplicationContext() throws ApplicationContextException {\n\t\tsuper.initApplicationContext();\n\t\tdetectHandlers();\n\t}\n\n\tprotected void detectHandlers() throws BeansException {\n\t\tApplicationContext applicationContext = obtainApplicationContext();\n\t\tString[] beanNames = (this.detectHandlersInAncestorContexts ?\n\t\t\t\tBeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class) :\n\t\t\t\tapplicationContext.getBeanNamesForType(Object.class));\n\n\t\t// Take any bean name that we can determine URLs for.\n\t\tfor (String beanName : beanNames) {\n\t\t\tString[] urls = determineUrlsForHandler(beanName);\n\t\t\tif (!ObjectUtils.isEmpty(urls)) {\n\t\t\t\t// URL paths found: Let's consider it a handler.\n\t\t\t\tregisterHandler(urls, beanName);\n\t\t\t}\n\t\t}\n\n\t\tif ((logger.isDebugEnabled() &amp;&amp; !getHandlerMap().isEmpty()) || logger.isTraceEnabled()) {\n\t\t\tlogger.debug(\"Detected \" + getHandlerMap().size() + \" mappings in \" + formatMappingName());\n\t\t}\n\t}\n</code></pre>\n<h2 id=\"%E8%BF%90%E8%A1%8C%E8%B0%83%E7%94%A8%E9%98%B6%E6%AE%B5\">运行调用阶段 <a class=\"header-anchor\" href=\"#%E8%BF%90%E8%A1%8C%E8%B0%83%E7%94%A8%E9%98%B6%E6%AE%B5\">#</a></h2>\n<p>这一步步是由请求触发的，所以入口为 DispatcherServlet 的核心方法为 doService()， doService()中的核心逻辑由 doDispatch()实现，源代码如下:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doDispatch</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n\t\tHttpServletRequest processedRequest = request;\n\t\tHandlerExecutionChain mappedHandler = <span class=\"hljs-keyword\">null</span>;\n\t\t<span class=\"hljs-keyword\">boolean</span> multipartRequestParsed = <span class=\"hljs-keyword\">false</span>;\n\n\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\tModelAndView mv = <span class=\"hljs-keyword\">null</span>;\n\t\t\tException dispatchException = <span class=\"hljs-keyword\">null</span>;\n\n\t\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\t\tprocessedRequest = checkMultipart(request);\n\t\t\t\tmultipartRequestParsed = (processedRequest != request);\n\n\t\t\t\t<span class=\"hljs-comment\">// Determine handler for the current request.</span>\n                <span class=\"hljs-comment\">// 2.取得处理当前请求的 Controller,这里也称为 hanlder,处理器,</span>\n                <span class=\"hljs-comment\">// 第一个步骤的意义就在这里体现了.这里并不是直接返回 Controller,</span>\n                <span class=\"hljs-comment\">// 而是返回的 HandlerExecutionChain 请求处理器链对象,</span>\n                <span class=\"hljs-comment\">// 该对象封装了 handler 和 interceptors.</span>\n\t\t\t\tmappedHandler = getHandler(processedRequest);\n                <span class=\"hljs-comment\">// 如果 handler 为空,则返回 404</span>\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (mappedHandler == <span class=\"hljs-keyword\">null</span>) {\n\t\t\t\t\tnoHandlerFound(processedRequest, response);\n\t\t\t\t\t<span class=\"hljs-keyword\">return</span>;\n\t\t\t\t}\n\n\t\t\t\t<span class=\"hljs-comment\">// Determine handler adapter for the current request.</span>\n                <span class=\"hljs-comment\">//3. 获取处理 request 的处理器适配器 handler adapter</span>\n\t\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n\t\t\t\t<span class=\"hljs-comment\">// Process last-modified header, if supported by the handler.</span>\n\t\t\t\tString method = request.getMethod();\n\t\t\t\t<span class=\"hljs-keyword\">boolean</span> isGet = <span class=\"hljs-string\">\"GET\"</span>.equals(method);\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (isGet || <span class=\"hljs-string\">\"HEAD\"</span>.equals(method)) {\n\t\t\t\t\t<span class=\"hljs-keyword\">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) {\n\t\t\t\t\t\t<span class=\"hljs-keyword\">return</span>;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) {\n\t\t\t\t\t<span class=\"hljs-keyword\">return</span>;\n\t\t\t\t}\n\n\t\t\t\t<span class=\"hljs-comment\">// Actually invoke the handler.</span>\n                <span class=\"hljs-comment\">//4.实际的处理器处理请求,返回结果视图对象</span>\n\t\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t\t<span class=\"hljs-keyword\">return</span>;\n\t\t\t\t}\n\n\t\t\t\tapplyDefaultViewName(processedRequest, mv);\n\t\t\t\tmappedHandler.applyPostHandle(processedRequest, response, mv);\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">catch</span> (Exception ex) {\n\t\t\t\tdispatchException = ex;\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">catch</span> (Throwable err) {\n\t\t\t\t<span class=\"hljs-comment\">// As of 4.3, we're processing Errors thrown from handler methods as well,</span>\n\t\t\t\t<span class=\"hljs-comment\">// making them available for @ExceptionHandler methods and other scenarios.</span>\n\t\t\t\tdispatchException = <span class=\"hljs-keyword\">new</span> NestedServletException(<span class=\"hljs-string\">\"Handler dispatch failed\"</span>, err);\n\t\t\t}\n\t\t\tprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n\t\t}\n\t\t<span class=\"hljs-keyword\">catch</span> (Exception ex) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n\t\t}\n\t\t<span class=\"hljs-keyword\">catch</span> (Throwable err) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler,\n\t\t\t\t\t<span class=\"hljs-keyword\">new</span> NestedServletException(<span class=\"hljs-string\">\"Handler processing failed\"</span>, err));\n\t\t}\n\t\t<span class=\"hljs-keyword\">finally</span> {\n\t\t\t<span class=\"hljs-keyword\">if</span> (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t<span class=\"hljs-comment\">// Instead of postHandle and afterCompletion</span>\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (mappedHandler != <span class=\"hljs-keyword\">null</span>) {\n\t\t\t\t\tmappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n\t\t\t\t}\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">else</span> {\n\t\t\t\t<span class=\"hljs-comment\">// Clean up any resources used by a multipart request.</span>\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (multipartRequestParsed) {\n\t\t\t\t\tcleanupMultipart(processedRequest);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doService</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n\t\tlogRequest(request);\n\n\t\t<span class=\"hljs-comment\">// Keep a snapshot of the request attributes in case of an include,</span>\n\t\t<span class=\"hljs-comment\">// to be able to restore the original attributes after the include.</span>\n\t\tMap&lt;String, Object&gt; attributesSnapshot = <span class=\"hljs-keyword\">null</span>;\n\t\t<span class=\"hljs-keyword\">if</span> (WebUtils.isIncludeRequest(request)) {\n\t\t\tattributesSnapshot = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();\n\t\t\tEnumeration&lt;?&gt; attrNames = request.getAttributeNames();\n\t\t\t<span class=\"hljs-keyword\">while</span> (attrNames.hasMoreElements()) {\n\t\t\t\tString attrName = (String) attrNames.nextElement();\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {\n\t\t\t\t\tattributesSnapshot.put(attrName, request.getAttribute(attrName));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t<span class=\"hljs-comment\">// Make framework objects available to handlers and view objects.</span>\n\t\trequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());\n\t\trequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class=\"hljs-keyword\">this</span>.localeResolver);\n\t\trequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class=\"hljs-keyword\">this</span>.themeResolver);\n\t\trequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.flashMapManager != <span class=\"hljs-keyword\">null</span>) {\n\t\t\tFlashMap inputFlashMap = <span class=\"hljs-keyword\">this</span>.flashMapManager.retrieveAndUpdate(request, response);\n\t\t\t<span class=\"hljs-keyword\">if</span> (inputFlashMap != <span class=\"hljs-keyword\">null</span>) {\n\t\t\t\trequest.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));\n\t\t\t}\n\t\t\trequest.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class=\"hljs-keyword\">new</span> FlashMap());\n\t\t\trequest.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class=\"hljs-keyword\">this</span>.flashMapManager);\n\t\t}\n\n\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\tdoDispatch(request, response);\n\t\t}\n\t\t<span class=\"hljs-keyword\">finally</span> {\n\t\t\t<span class=\"hljs-keyword\">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n\t\t\t\t<span class=\"hljs-comment\">// Restore the original attribute snapshot, in case of an include.</span>\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (attributesSnapshot != <span class=\"hljs-keyword\">null</span>) {\n\t\t\t\t\trestoreAttributesAfterInclude(request, attributesSnapshot);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n</code></pre>\n<p>getHandler(processedRequest)方法实际上就是从 HandlerMapping 中找到 url 和 Controller 的对应关系。也就是 Map&lt;url,Controller&gt;。我们知道，最终处理 Request 的是 Controller 中的方法，我们现在只是知道了 Controller，我们如何确认 Controller 中处理 Request 的方法呢?继续往下看。\n从 Map&lt;urls,beanName&gt;中取得 Controller 后，经过拦截器的预处理方法，再通过反 射获取该方法上的注解和参数，解析方法和参数上的注解，然后反射调用方法获取ModelAndView 结果视图。最后，调用的就是 RequestMappingHandlerAdapter 的 handle()中的核心逻辑由 handleInternal(request, response, handler)实现。</p>\n<pre><code class=\"language-java\">\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> ModelAndView <span class=\"hljs-title\">handleInternal</span><span class=\"hljs-params\">(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n\n\t\tModelAndView mav;\n\t\tcheckRequest(request);\n\n\t\t<span class=\"hljs-comment\">// Execute invokeHandlerMethod in synchronized block if required.</span>\n\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.synchronizeOnSession) {\n\t\t\tHttpSession session = request.getSession(<span class=\"hljs-keyword\">false</span>);\n\t\t\t<span class=\"hljs-keyword\">if</span> (session != <span class=\"hljs-keyword\">null</span>) {\n\t\t\t\tObject mutex = WebUtils.getSessionMutex(session);\n\t\t\t\t<span class=\"hljs-keyword\">synchronized</span> (mutex) {\n\t\t\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t\t\t}\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">else</span> {\n\t\t\t\t<span class=\"hljs-comment\">// No HttpSession available -&gt; no mutex necessary</span>\n\t\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t\t}\n\t\t}\n\t\t<span class=\"hljs-keyword\">else</span> {\n\t\t\t<span class=\"hljs-comment\">// No synchronization on session demanded at all...</span>\n\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t}\n\n\t\t<span class=\"hljs-keyword\">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) {\n\t\t\t<span class=\"hljs-keyword\">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {\n\t\t\t\tapplyCacheSeconds(response, <span class=\"hljs-keyword\">this</span>.cacheSecondsForSessionAttributeHandlers);\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">else</span> {\n\t\t\t\tprepareResponse(response);\n\t\t\t}\n\t\t}\n\n\t\t<span class=\"hljs-keyword\">return</span> mav;\n\t}\n</code></pre>\n<p>通过上面的代码分析，已经可以找到处理 Request 的 Controller 中的方法了，现在看如 何解析该方法上的参数，并反射调用该方法。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Nullable</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> ModelAndView <span class=\"hljs-title\">invokeHandlerMethod</span><span class=\"hljs-params\">(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n\n\t\tServletWebRequest webRequest = <span class=\"hljs-keyword\">new</span> ServletWebRequest(request, response);\n\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\tWebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);\n\t\t\tModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);\n\n\t\t\tServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\n\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.argumentResolvers != <span class=\"hljs-keyword\">null</span>) {\n\t\t\t\tinvocableMethod.setHandlerMethodArgumentResolvers(<span class=\"hljs-keyword\">this</span>.argumentResolvers);\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.returnValueHandlers != <span class=\"hljs-keyword\">null</span>) {\n\t\t\t\tinvocableMethod.setHandlerMethodReturnValueHandlers(<span class=\"hljs-keyword\">this</span>.returnValueHandlers);\n\t\t\t}\n\t\t\tinvocableMethod.setDataBinderFactory(binderFactory);\n\t\t\tinvocableMethod.setParameterNameDiscoverer(<span class=\"hljs-keyword\">this</span>.parameterNameDiscoverer);\n\n\t\t\tModelAndViewContainer mavContainer = <span class=\"hljs-keyword\">new</span> ModelAndViewContainer();\n\t\t\tmavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));\n\t\t\tmodelFactory.initModel(webRequest, mavContainer, invocableMethod);\n\t\t\tmavContainer.setIgnoreDefaultModelOnRedirect(<span class=\"hljs-keyword\">this</span>.ignoreDefaultModelOnRedirect);\n\n\t\t\tAsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);\n\t\t\tasyncWebRequest.setTimeout(<span class=\"hljs-keyword\">this</span>.asyncRequestTimeout);\n\n\t\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\t\t\tasyncManager.setTaskExecutor(<span class=\"hljs-keyword\">this</span>.taskExecutor);\n\t\t\tasyncManager.setAsyncWebRequest(asyncWebRequest);\n\t\t\tasyncManager.registerCallableInterceptors(<span class=\"hljs-keyword\">this</span>.callableInterceptors);\n\t\t\tasyncManager.registerDeferredResultInterceptors(<span class=\"hljs-keyword\">this</span>.deferredResultInterceptors);\n\n\t\t\t<span class=\"hljs-keyword\">if</span> (asyncManager.hasConcurrentResult()) {\n\t\t\t\tObject result = asyncManager.getConcurrentResult();\n\t\t\t\tmavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class=\"hljs-number\">0</span>];\n\t\t\t\tasyncManager.clearConcurrentResult();\n\t\t\t\tLogFormatUtils.traceDebug(logger, traceOn -&gt; {\n\t\t\t\t\tString formatted = LogFormatUtils.formatValue(result, !traceOn);\n\t\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Resume with async result [\"</span> + formatted + <span class=\"hljs-string\">\"]\"</span>;\n\t\t\t\t});\n\t\t\t\tinvocableMethod = invocableMethod.wrapConcurrentResult(result);\n\t\t\t}\n\n\t\t\tinvocableMethod.invokeAndHandle(webRequest, mavContainer);\n\t\t\t<span class=\"hljs-keyword\">if</span> (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n\t\t\t}\n\n\t\t\t<span class=\"hljs-keyword\">return</span> getModelAndView(mavContainer, modelFactory, webRequest);\n\t\t}\n\t\t<span class=\"hljs-keyword\">finally</span> {\n\t\t\twebRequest.requestCompleted();\n\t\t}\n\t}\n\n\n</code></pre>\n<p>invocableMethod.invokeAndHandle()最终要实现的目的就是:完成 Request 中的参 数和方法参数上数据的绑定。Spring MVC 中提供两种 Request 参数到方法中参数的绑 定方式:</p>\n<p>1、通过注解进行绑定，@RequestParam。</p>\n<p>2、通过参数名称进行绑定。</p>\n<p>使用注解进行绑定，我们只要在方法参数前面声明@RequestParam(&quot;name&quot;)，就可以 将 request 中参数 name 的值绑定到方法的该参数上。使用参数名称进行绑定的前提是 必须要获取方法中参数的名称，Java 反射只提供了获取方法的参数的类型，并没有提供 获取参数名称的方法。SpringMVC 解决这个问题的方法是用 asm 框架读取字节码文件， 来获取方法的参数名称。asm 框架是一个字节码操作框架，关于 asm 更多介绍可以参考 其官网。个人建议，使用注解来完成参数绑定，这样就可以省去 asm 框架的读取字节码 的操作。</p>\n<p>调用时序图：</p>\n<p><img src=\"http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/2f34427cabe349b4ba51ed8ce86d91af.png\" alt=\"image\"></p>\n<h1 id=\"spring-mvc-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE\">Spring MVC 使用优化建议 <a class=\"header-anchor\" href=\"#spring-mvc-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE\">#</a></h1>\n<h2 id=\"controller-%E5%A6%82%E6%9E%9C%E8%83%BD%E4%BF%9D%E6%8C%81%E5%8D%95%E4%BE%8B%EF%BC%8C%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E5%8D%95%E4%BE%8B\">Controller 如果能保持单例，尽量使用单例 <a class=\"header-anchor\" href=\"#controller-%E5%A6%82%E6%9E%9C%E8%83%BD%E4%BF%9D%E6%8C%81%E5%8D%95%E4%BE%8B%EF%BC%8C%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E5%8D%95%E4%BE%8B\">#</a></h2>\n<p>这样可以减少创建对象和回收对象的开销。也就是说，如果 Controller 的类变量和实例 变量可以以方法形参声明的尽量以方法的形参声明，不要以类变量和实例变量声明，这 样可以避免线程安全问题。</p>\n<h2 id=\"%E5%A4%84%E7%90%86-request-%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%BD%A2%E5%8F%82%E5%8A%A1%E5%BF%85%E5%8A%A0%E4%B8%8A%40requestparam-%E6%B3%A8%E8%A7%A3\">处理 Request 的方法中的形参务必加上@RequestParam 注解 <a class=\"header-anchor\" href=\"#%E5%A4%84%E7%90%86-request-%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%BD%A2%E5%8F%82%E5%8A%A1%E5%BF%85%E5%8A%A0%E4%B8%8A%40requestparam-%E6%B3%A8%E8%A7%A3\">#</a></h2>\n<p>这样可以避免 Spring MVC 使用 asm 框架读取 class 文件获取方法参数名的过程。即便 Spring MVC 对读取出的方法参数名进行了缓存，如果不要读取 class 文件当然是更好。</p>\n<h2 id=\"%E7%BC%93%E5%AD%98-url\">缓存 URL <a class=\"header-anchor\" href=\"#%E7%BC%93%E5%AD%98-url\">#</a></h2>\n<p>阅读源码的过程中，我们发现 Spring MVC 并没有对处理 url 的方法进行缓存，也就是 说每次都要根据请求 url 去匹配 Controller 中的方法 url，如果把 url 和 Method 的关系缓存起来，会不会带来性能上的提升呢?有点恶心的是，负责解析 url 和 Method 对应 关系的 ServletHandlerMethodResolver 是一个 private 的内部类，不能直接继承该类 增强代码，必须要该代码后重新编译。当然，如果缓存起来，必须要考虑缓存的线程安 全问题。</p>\n",
  "link": "/zh-cn/docs/5.框架/spring/6.mvc.html",
  "meta": {}
}