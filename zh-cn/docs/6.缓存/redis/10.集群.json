{
  "filename": "10.集群.md",
  "__html": "<h2 id=\"%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6\">主从复制 <a class=\"header-anchor\" href=\"#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6\">#</a></h2>\n<p>redis 主从复制的核心原理</p>\n<p>当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node。</p>\n<p>如果这是 slave node 初次连接到 master node，那么会触发一次 full resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件，</p>\n<p>同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，</p>\n<p>接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</p>\n<p>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据</p>\n<p>过程原理</p>\n<ol>\n<li>当从库和主库建立MS关系后，会向主数据库发送SYNC命令</li>\n<li>主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来</li>\n<li>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis</li>\n<li>从Redis接收到后，会载入快照文件并且执行收到的缓存的命令</li>\n<li>之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致</li>\n</ol>\n<h2 id=\"docker%E4%B8%8Bredis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA\">docker下redis集群搭建 <a class=\"header-anchor\" href=\"#docker%E4%B8%8Bredis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA\">#</a></h2>\n<p><a href=\"https://github.com/alfredhua/docker/tree/master/redis\">github地址</a></p>\n<ol>\n<li>\n<p>修改redis的配置文件：</p>\n<p>​\tcluster-enabled yes</p>\n</li>\n<li>\n<p>如果是单台机器。修改每个redis服务的端口号。</p>\n</li>\n<li>\n<p>启动每个机器。</p>\n</li>\n<li>\n<p>执行命令：加入各个节点，注意替换自己的ip地址</p>\n<pre><code class=\"language-java\"> redis-cli --cluster create <span class=\"hljs-number\">10.5</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.3</span>:<span class=\"hljs-number\">6391</span> <span class=\"hljs-number\">10.5</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.3</span>:<span class=\"hljs-number\">6392</span> <span class=\"hljs-number\">10.5</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.3</span>:<span class=\"hljs-number\">6393</span> <span class=\"hljs-number\">10.5</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.3</span>:<span class=\"hljs-number\">6394</span> <span class=\"hljs-number\">10.5</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.3</span>:<span class=\"hljs-number\">6395</span> <span class=\"hljs-number\">10.5</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.3</span>:<span class=\"hljs-number\">6396</span> --cluster-replicas <span class=\"hljs-number\">1</span> \n</code></pre>\n</li>\n<li>\n<p>连接测试： redis-cli -c -h 172.30.0.4 -p 6396   （-c 会在set和get的时候自动寻找对应的节点存储）</p>\n</li>\n<li>\n<p>执行 cluster nodes 查看节点信息。</p>\n</li>\n</ol>\n<h2 id=\"redis%E5%93%88%E5%B8%8C%E6%A7%BD\">Redis哈希槽 <a class=\"header-anchor\" href=\"#redis%E5%93%88%E5%B8%8C%E6%A7%BD\">#</a></h2>\n<p><strong>一个 redis 集群包含2^14（16384）个哈希槽（hash slot）</strong>，数据库中的每个数据都属于这16384个哈希槽中的一个。集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽。集群中的每一个节点负责处理一部分哈希槽。</p>\n<p>所有的master节点都会有一个槽区比如0～1000，槽数是可以迁移的。master节点的slave节点不分配槽，只拥有读权限。但是注意在代码中redis cluster执行读写操作的都是master节点，并不是你想 的读是从节点，写是主节点。第一次新建redis cluster时，16384个槽是被master节点均匀分布的。</p>\n<h2 id=\"%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF16384%EF%BC%882%5E14%EF%BC%89%E4%B8%AA%EF%BC%9F\"><strong>为什么是16384（2^14）个？</strong> <a class=\"header-anchor\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF16384%EF%BC%882%5E14%EF%BC%89%E4%B8%AA%EF%BC%9F\">#</a></h2>\n<p>在redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，16384=16k，在发送心跳包时使用bitmap压缩后是2k（<code>2 * 8 (8 bit) * 1024(1k) = 2K</code>），也就是说使用2k的空间创建了16k的槽数。</p>\n<p>虽然使用CRC16算法最多可以分配65535（2^16-1）个槽位，65535=65k，压缩后就是8k（<code>8 * 8 (8 bit) * 1024(1k) = 8K</code>），也就是说需要需要8k的心跳包，作者认为这样做不太值得；并且一般情况下一个redis集群不会有超过1000个master节点，所以16k的槽位是个比较合适的选择。</p>\n",
  "link": "/zh-cn/docs/6.缓存/redis/10.集群.html",
  "meta": {}
}