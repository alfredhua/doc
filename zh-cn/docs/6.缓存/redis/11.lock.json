{
  "filename": "11.lock.md",
  "__html": "<h2 id=\"redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\">Redis实现分布式锁 <a class=\"header-anchor\" href=\"#redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\">#</a></h2>\n<p>Redis实现分布式锁利用 SETNX 和 SETEX</p>\n<p>基本命令主要有：</p>\n<ul>\n<li>SETNX(SET If Not Exists)：</li>\n</ul>\n<p>当且仅当 Key 不存在时，则可以设置，否则不做任何动作。</p>\n<p>当且仅当 key 不存在，将 key 的值设为 value ，并返回1；若给定的 key 已经存在，则 SETNX 不做任何动作，并返回0。</p>\n<ul>\n<li>SETEX：</li>\n</ul>\n<p>基于SETNX功能外,还可以设置超时时间，防止死锁。</p>\n<p>分布式锁其实大白话，本质上要实现的目标(客户端)在redis中占一个位置，等到这个客户试用，别的人进来就必须得等着，等我试用完了，走了，你再来。感觉跟多线程锁一样，意思大致是一样的，多线程是针对单机的，在同一个Jvm中，但是分布式石锁，是跨机器的，多个进程不同机器上发来得请求，去对同一个数据进行操作。</p>\n<p>比如，分布式架构下的秒杀系统，几万人对10个商品进行抢购，10个商品存在redis中，就是表示10个位置，第一个人进来了，商品就剩9个了，第二个人进来就剩8个，在第一个人进来的时候，其他人必须等到10个商品数量成功减去1之后你才能进来。</p>\n<p>这个过程中第一个人进来的时候还没操作减1然后异常了，没有释放锁，然后后面人一直等待着，这就是死锁。真对这种情况可以设置超时时间，如果超过10s中还是没出来，就让他超时失效。</p>\n<pre><code class=\"language-java\">\n<span class=\"hljs-comment\">/**\n * 获取锁\n * <span class=\"hljs-doctag\">@param</span> lockKey 锁\n * <span class=\"hljs-doctag\">@param</span> identity 身份标识（保证锁不会被其他人释放）\n * <span class=\"hljs-doctag\">@param</span> expireTime 锁的过期时间（单位：秒）\n * <span class=\"hljs-doctag\">@return</span>\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">lock</span><span class=\"hljs-params\">(String lockKey, String identity, <span class=\"hljs-keyword\">long</span> expireTime)</span></span>{\n  <span class=\"hljs-keyword\">boolean</span> lockResult = redisTemplate.opsForValue().setIfAbsent(lockKey, identity, expireTime, TimeUnit.SECONDS);\n  <span class=\"hljs-keyword\">return</span> opsForValue;\n}\n\n<span class=\"hljs-comment\">/**\n * 释放锁\n * <span class=\"hljs-doctag\">@param</span> lockKey 锁\n * <span class=\"hljs-doctag\">@param</span> identity 身份标识（保证锁不会被其他人释放）\n * <span class=\"hljs-doctag\">@return</span>\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">releaseLock</span><span class=\"hljs-params\">(String lockKey, String identity)</span></span>{\n  String luaScript =\n    <span class=\"hljs-string\">\"if \"</span> +\n    <span class=\"hljs-string\">\"  redis.call('get', KEYS[1]) == ARGV[1] \"</span> +\n    <span class=\"hljs-string\">\"then \"</span> +\n    <span class=\"hljs-string\">\"  return redis.call('del', KEYS[1]) \"</span> +\n    <span class=\"hljs-string\">\"else \"</span> +\n    <span class=\"hljs-string\">\"  return 0 \"</span> +\n    <span class=\"hljs-string\">\"end\"</span>;\n  DefaultRedisScript&lt;Boolean&gt; redisScript = <span class=\"hljs-keyword\">new</span> DefaultRedisScript&lt;&gt;();\n  redisScript.setResultType(Boolean<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n  redisScript.setScriptText(luaScript);\n  List&lt;String&gt; keys = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n  keys.add(lockKey);\n  <span class=\"hljs-keyword\">boolean</span> result = redisTemplate.execute(redisScript, keys, identity);\n  <span class=\"hljs-keyword\">return</span> result;\n}\n</code></pre>\n<p>解锁的方法只需两个参数：lockKey、identity。</p>\n<ul>\n<li>第一个参数lockKey为key，一个资源对应一个唯一的key。</li>\n<li>第二个参数identity为身份标识，作为此key对应的value存储，为了判断在释放锁时是不是和加锁的身份相同，防止别人释放锁。</li>\n</ul>\n<p>此处使用Lua脚本来判断身份，身份相同就删除，身份不同就不对数据做操作并返回失败。为什么要使用Lua脚本呢？这是为了要保证操作的原子性，redis在执行Lua脚本的时候是把脚本当作一个命令来执行的，我们都知道redis的命令是都是原子操作，这样就保证了操作的原子性。</p>\n",
  "link": "/zh-cn/docs/6.缓存/redis/11.lock.html",
  "meta": {}
}