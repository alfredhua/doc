{
  "filename": "5.过期策略.md",
  "__html": "<h1 id=\"redis%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5\">redis数据过期策略 <a class=\"header-anchor\" href=\"#redis%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5\">#</a></h1>\n<p>解决问题：</p>\n<ol>\n<li>往redis里写的数据怎么没了？</li>\n<li>数据明明都过期了，怎么还占用着内存啊？</li>\n</ol>\n<h2 id=\"%E9%97%AE%E9%A2%981%EF%BC%9A%E5%BE%80redis%E9%87%8C%E5%86%99%E7%9A%84%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E6%B2%A1%E4%BA%86%EF%BC%9F%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4\">问题1：往redis里写的数据怎么没了？设置过期时间 <a class=\"header-anchor\" href=\"#%E9%97%AE%E9%A2%981%EF%BC%9A%E5%BE%80redis%E9%87%8C%E5%86%99%E7%9A%84%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E6%B2%A1%E4%BA%86%EF%BC%9F%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4\">#</a></h2>\n<p>我们set key的时候，都可以给一个expire time，就是过期时间，指定这个key比如说只能存活1个小时？10分钟？这个很有用，我们自己可以指定缓存到期就失效。</p>\n<p>如果假设你设置一个一批key只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？</p>\n<p>答案:</p>\n<blockquote>\n<p>定期删除+惰性删除</p>\n</blockquote>\n<ul>\n<li>定期删除</li>\n</ul>\n<blockquote>\n<p>指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。</p>\n</blockquote>\n<ul>\n<li>惰性删除</li>\n</ul>\n<blockquote>\n<p>定期删除可能会导致很多过期key到了时间并没有被删除掉，那咋整呢？此时会用到惰性删除。这就是说，在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。</p>\n</blockquote>\n<p>并不是key到时间就被删除掉，而是你查询这个key的时候，redis再懒惰的检查一下。</p>\n<p>通过上述两种手段结合起来，保证过期的key一定会被干掉。</p>\n<h3 id=\"%E9%97%AE%E9%A2%982-%EF%BC%9A-%E6%95%B0%E6%8D%AE%E6%98%8E%E6%98%8E%E9%83%BD%E8%BF%87%E6%9C%9F%E4%BA%86%EF%BC%8C%E6%80%8E%E4%B9%88%E8%BF%98%E5%8D%A0%E7%94%A8%E7%9D%80%E5%86%85%E5%AD%98%E5%95%8A%EF%BC%9F\">问题2 ： 数据明明都过期了，怎么还占用着内存啊？ <a class=\"header-anchor\" href=\"#%E9%97%AE%E9%A2%982-%EF%BC%9A-%E6%95%B0%E6%8D%AE%E6%98%8E%E6%98%8E%E9%83%BD%E8%BF%87%E6%9C%9F%E4%BA%86%EF%BC%8C%E6%80%8E%E4%B9%88%E8%BF%98%E5%8D%A0%E7%94%A8%E7%9D%80%E5%86%85%E5%AD%98%E5%95%8A%EF%BC%9F\">#</a></h3>\n<p>你的过期key，靠定期删除没有被删除掉，还停留在内存里，占用着你的内存呢，除非你的系统去查一下那个key，才会被redis给删除掉。</p>\n<p>但是实际上这还是有问题的，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？</p>\n<p>答案是：</p>\n<blockquote>\n<p>走内存淘汰机制。</p>\n</blockquote>\n<ol>\n<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了</li>\n<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li>\n<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊</li>\n<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）</li>\n<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key</li>\n<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>\n</ol>\n",
  "link": "/zh-cn/docs/6.缓存/redis/5.过期策略.html",
  "meta": {}
}