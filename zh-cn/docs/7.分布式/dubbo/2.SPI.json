{
  "filename": "2.SPI.md",
  "__html": "<h2 id=\"%E5%A6%82%E4%BD%95%E5%8E%BB%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E7%9A%84-spi-%E5%8F%91%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%91%A2%3F\">如何去实现一个标准的 SPI 发现机制呢? <a class=\"header-anchor\" href=\"#%E5%A6%82%E4%BD%95%E5%8E%BB%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E7%9A%84-spi-%E5%8F%91%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%91%A2%3F\">#</a></h2>\n<ol>\n<li>需要在 classpath 下创建一个目录，该目录命名必须是:META-INF/service</li>\n<li>在该目录下创建一个 properties 文件，该文件需要满足以下几个条件</li>\n</ol>\n<blockquote>\n<ol>\n<li>文件名必须是扩展的接口的全路径名称</li>\n<li>文件内部描述的是该扩展接口的所有实现类</li>\n<li>文件的编码格式是 UTF-8</li>\n</ol>\n</blockquote>\n<ol start=\"3\">\n<li>通过 java.util.ServiceLoader 的加载机制来发现</li>\n</ol>\n<h2 id=\"spi%E7%BC%BA%E7%82%B9\">SPI缺点 <a class=\"header-anchor\" href=\"#spi%E7%BC%BA%E7%82%B9\">#</a></h2>\n<ol>\n<li>JDK 标准的 SPI 会一次性加载实例化扩展点的所有实现，什么意思呢?就是如果你在 META-INF/service 下的文件里面加了 N 个实现类，那么 JDK 启动的时候都会一次性全部加载。那么如果有的扩展点实现初始化很耗时或者如果有些实现类并没有用到， 那么会很浪费资源</li>\n<li>如果扩展点加载失败，会导致调用方报错，而且这个错误很难定位到是这个原因 Dubbo 优化后的 SPI 机制</li>\n</ol>\n",
  "link": "/zh-cn/docs/7.分布式/dubbo/2.SPI.html",
  "meta": {}
}