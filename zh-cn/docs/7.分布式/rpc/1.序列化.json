{
  "filename": "1.序列化.md",
  "__html": "<h2 id=\"xml-%E5%BA%8F%E5%88%97%E5%8C%96\">XML 序列化 <a class=\"header-anchor\" href=\"#xml-%E5%BA%8F%E5%88%97%E5%8C%96\">#</a></h2>\n<p>XML 序列化的好处在于可读性好，方便阅读和调试。但是序列化以后的字节码文件比较大， 而且效率不高，适用于对性能不高，而且 QPS 较低的企业级内部系统之间的数据交换的场景， 同时 XML 又具有语言无关性，所以还可以用于异构系统之间的数据交换和协议。比如我们熟 知的 Webservice，就是采用 XML 格式对数据进行序列化的。XML 序列化/反序列化的实现方 式有很多，熟知的方式有 XStream 和 Java 自带的 XML 序列化和反序列化两种。</p>\n<h2 id=\"json-%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6\">JSON 序列化框架 <a class=\"header-anchor\" href=\"#json-%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6\">#</a></h2>\n<p>JSON(JavaScript Object Notation)是一种轻量级的数据交换格式，相对于 XML 来说，JSON 的字节流更小，而且可读性也非常好。现在 JSON 数据格式在企业运用是最普遍的\nJSON 序列化常用的开源工具有很多</p>\n<ol>\n<li>Jackson (<a href=\"https://github.com/FasterXML/jackson\">https://github.com/FasterXML/jackson</a>)</li>\n<li>阿里开源的 FastJson (<a href=\"https://github.com/alibaba/fastjon\">https://github.com/alibaba/fastjon</a>)</li>\n<li>Google 的 GSON (<a href=\"https://github.com/google/gson\">https://github.com/google/gson</a>)</li>\n</ol>\n<p>这几种 json 序列化工具中，Jackson 与 fastjson 要比 GSON 的性能要好，但是 Jackson、 GSON 的稳定性要比 Fastjson 好。而 fastjson 的优势在于提供的 api 非常容易使用</p>\n<h2 id=\"hessian-%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6\">Hessian 序列化框架 <a class=\"header-anchor\" href=\"#hessian-%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6\">#</a></h2>\n<p>Hessian 是一个支持跨语言传输的二进制序列化协议，相对于 Java 默认的序列化机制来说， Hessian 具有更好的性能和易用性，而且支持多种不同的语言。</p>\n<p>实际上 Dubbo 采用的就是 Hessian 序列化来实现，只不过 Dubbo 对 Hessian 进行了重构， 性能更高</p>\n<h2 id=\"avro-%E5%BA%8F%E5%88%97%E5%8C%96\">Avro 序列化 <a class=\"header-anchor\" href=\"#avro-%E5%BA%8F%E5%88%97%E5%8C%96\">#</a></h2>\n<p>Avro 是一个数据序列化系统，设计用于支持大批量数据交换的应用。它的主要特点有:支持 二进制序列化方式，可以便捷，快速地处理大量数据;动态语言友好，Avro 提供的机制使动 态语言可以方便地处理 Avro 数据。</p>\n<h2 id=\"kyro-%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6\">kyro 序列化框架 <a class=\"header-anchor\" href=\"#kyro-%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6\">#</a></h2>\n<p>Kryo 是一种非常成熟的序列化实现，已经在 Hive、Storm)中使用得比较广泛，不过它不能 跨语言. 目前 dubbo 已经在 2.6 版本支持 kyro 的序列化机制。它的性能要优于之前的 hessian2</p>\n<h2 id=\"protobuf-%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6\">Protobuf 序列化框架 <a class=\"header-anchor\" href=\"#protobuf-%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6\">#</a></h2>\n<p>Protobuf 是 Google 的一种数据交换格式，它独立于语言、独立于平台。Google 提供了多种 语言来实现，比如 Java、C、Go、Python，每一种实现都包含了相应语言的编译器和库文件， Protobuf 是一个纯粹的表示层协议，可以和各种传输层协议一起使用。</p>\n<p>Protobuf 使用比较广泛，主要是空间开销小和性能比较好，非常适合用于公司内部对性能要 求高的 RPC 调用。 另外由于解析性能比较高，序列化以后数据量相对较少，所以也可以应 用在对象的持久化场景中</p>\n<p>但是要使用 Protobuf 会相对来说麻烦些，因为他有自己的语法，有自己的编译器，如果需要 用到的话必须要去投入成本在这个技术的学习中</p>\n<p>protobuf 有个缺点就是要传输的每一个类的结构都要生成对应的 proto 文件，如果某个类发 生修改，还得重新生成该类对应的 proto 文件</p>\n<h2 id=\"%E5%BA%8F%E5%88%97%E5%8C%96%E6%8A%80%E6%9C%AF%E7%9A%84%E9%80%89%E5%9E%8B\">序列化技术的选型 <a class=\"header-anchor\" href=\"#%E5%BA%8F%E5%88%97%E5%8C%96%E6%8A%80%E6%9C%AF%E7%9A%84%E9%80%89%E5%9E%8B\">#</a></h2>\n<ol>\n<li>序列化空间开销，也就是序列化产生的结果大小，这个影响到传输的性能</li>\n<li>序列化过程中消耗的时长，序列化消耗时间过长影响到业务的响应时间</li>\n<li>序列化协议是否支持跨平台，跨语言。因为现在的架构更加灵活，如果存在异构系统通信\n需求，那么这个是必须要考虑的</li>\n<li>可扩展性/兼容性，在实际业务开发中，系统往往需要随着需求的快速迭代来实现快速更新，\n这就要求我们采用的序列化协议基于良好的可扩展性/兼容性，比如在现有的序列化数据结\n构中新增一个业务字段，不会影响到现有的服务</li>\n<li>技术的流行程度，越流行的技术意味着使用的公司多，那么很多坑都已经淌过并且得到了解决，技术解决方案也相对成熟</li>\n<li>学习难度和易用性</li>\n</ol>\n<h2 id=\"%E9%80%89%E5%9E%8B%E5%BB%BA%E8%AE%AE\">选型建议 <a class=\"header-anchor\" href=\"#%E9%80%89%E5%9E%8B%E5%BB%BA%E8%AE%AE\">#</a></h2>\n<ol>\n<li>对性能要求不高的场景，可以采用基于 XML 的 SOAP 协议</li>\n<li>对性能和间接性有比较高要求的场景，那么 Hessian、Protobuf、Thrift、Avro 都可以。</li>\n<li>基于前后端分离，或者独立的对外的 api 服务，选用 JSON 是比较好的，对于调试、可读\n性都很不错</li>\n<li>Avro 设计理念偏于动态类型语言，那么这类的场景使用 Avro 是可以的</li>\n</ol>\n<p>各个序列化技术的性能比较\n这 个 地 址 有 针 对 不 同 序 列 化 技 术 进 行 性 能 比 较 : <a href=\"https://github.com/eishay/jvm-serializers/wiki\">地址</a></p>\n",
  "link": "/zh-cn/docs/7.分布式/rpc/1.序列化.html",
  "meta": {}
}