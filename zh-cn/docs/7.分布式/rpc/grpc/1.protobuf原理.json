{
  "filename": "1.protobuf原理.md",
  "__html": "<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n    UserProtos.User user=UserProtos.User.newBuilder().\n        setAge(<span class=\"hljs-number\">300</span>).setName(<span class=\"hljs-string\">\"abc\"</span>).build();\n    <span class=\"hljs-keyword\">byte</span>[] bytes=user.toByteArray();\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">byte</span> bt:bytes){\n     System.out.print(bt+<span class=\"hljs-string\">\" \"</span>);\n    }\n}\n\n</code></pre>\n<p>序列化出来的数字基本看不懂，但是序列化以后的数据确实很小，那我们接 下来去了解一下底层的原理</p>\n<p>正常来说，要达到最小的序列化结果，一定会用到压缩的技术，而 protobuf 里面用到了两种 压缩算法，一种是 varint，另一种是 zigzag</p>\n<h2 id=\"%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F\">存储格式 <a class=\"header-anchor\" href=\"#%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F\">#</a></h2>\n<p>protobuf 采用 T-L-V 作为存储方式</p>\n<p><img src=\"http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/1e2ce0047e5c408280b2b1545af67525.png\" alt=\"image\"></p>\n<p>tag 的计算方式是 field_number(当前字段的编号) &lt;&lt; 3 | wire_type</p>\n<p>比如Mic的字段编号是1 ，类型wire_type的值为 2 所以 : 1&lt;&lt;3|2=10</p>\n<p>age=300 的字段编号是 2，类型 wire_type 的值是 0， 所以 : 2&lt;&lt;3|0 =16</p>\n<h2 id=\"%E8%B4%9F%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8\">负数的存储 <a class=\"header-anchor\" href=\"#%E8%B4%9F%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8\">#</a></h2>\n<p>在计算机中，负数会被表示为很大的整数，因为计算机定义负数符号位为数字的最高位，所 以如果采用 varint 编码表示一个负数，那么一定需要 5 个比特位。所以在 protobuf 中通过 sint32/sint64 类型来表示负数，负数的处理形式是先采用 zigzag 编码(把符号数转化为无符 号数)，在采用 varint 编码。</p>\n<p>sint32:(n &lt;&lt; 1) ^ (n &gt;&gt; 31)</p>\n<p>sint64:(n &lt;&lt; 1) ^ (n &gt;&gt; 63)</p>\n<p>比如存储一个(-300)的值 -300</p>\n<p>原码:0001 0010 1100</p>\n<p>取反:1110 1101 0011</p>\n<p>加 1 :1110 1101 0100</p>\n<p>n&lt;&lt;1: 整体左移一位，右边补 0 -&gt; 1101 1010 1000</p>\n<p>n&gt;&gt;31: 整体右移 31 位，左边补 1 -&gt; 1111 1111 1111</p>\n<p>n&lt;&lt;1 ^ n &gt;&gt;31</p>\n<p>1101 1010 1000 ^ 1111 1111 1111 = 0010 0101 0111</p>\n<p>十进制: 0010 0101 0111 = 599</p>\n<p>varint 算法: 从右往做，选取 7 位，高位补 1/0(取决于字节数) 得到两个字节</p>\n<p>1101 0111 0000 0100</p>\n<p>-41 、 4</p>\n<p>总结：</p>\n<p>Protocol Buffer 的性能好，主要体现在 序列化后的数据体积小 &amp; 序列化速度快，最终使得 传输效率高，其原因如下:</p>\n<p>序列化速度快的原因:</p>\n<p>a. 编码 / 解码 方式简单(只需要简单的数学运算 = 位移等等)</p>\n<p>b. 采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成</p>\n<p>序列化后的数据量体积小(即数据压缩效果好)的原因:</p>\n<p>a. 采用了独特的编码方式，如 Varint、Zigzag 编码方式等等</p>\n<p>b. 采用 T - L - V 的数据存储方式:减少了分隔符的使用 &amp; 数据存储得紧凑</p>\n",
  "link": "/zh-cn/docs/7.分布式/rpc/grpc/1.protobuf原理.html",
  "meta": {}
}