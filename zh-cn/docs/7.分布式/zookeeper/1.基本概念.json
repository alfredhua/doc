{
  "filename": "1.基本概念.md",
  "__html": "<h2 id=\"%E8%8A%82%E7%82%B9\">节点 <a class=\"header-anchor\" href=\"#%E8%8A%82%E7%82%B9\">#</a></h2>\n<ul>\n<li>持久节点(PERSISTENT)：创建后会一直存在 zookeeper 服务器上，直到主动删除</li>\n<li>持久有序节点(PERSISTENT_SEQUENTIAL) ：每个节点都会为它的一级子节点维护一个顺序</li>\n<li>临时节点(EPHEMERAL)：临时节点的生命周期和客户端的会话绑定在一起，当客户端会话，失效该节点自动清理。</li>\n<li>临时有序节点(EPHEMERAL) ：在临时节点的基础上多了一个顺序性。</li>\n</ul>\n<h2 id=\"%E4%BC%9A%E8%AF%9D\">会话 <a class=\"header-anchor\" href=\"#%E4%BC%9A%E8%AF%9D\">#</a></h2>\n<p><img src=\"http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/file/20d78f64c1f54d23905ba1b71d9cfd47\" alt=\"image\"></p>\n<ol>\n<li>Client 初始化连接，状态转为 CONNECTING(1)</li>\n<li>Client 与 Server 成功建立连接，状态转为 CONNECTED(2)</li>\n<li>Client 丢失了与 Server 的连接或者没有接受到 Server 的响应，状态转为 CONNECTING(3)</li>\n<li>Client 连上另外的 Server 或连接上了之前的 Server，状态 转为 CONNECTED(2)</li>\n<li>若会话过期(是 Server 负责声明会话过期，而不是 Client )， 状态转为 CLOSED(5)，状态转为 CLOSED</li>\n<li>Client 也可以主动关闭会话(4)，状态转为 CLOSED</li>\n</ol>\n<h2 id=\"stat-%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF\">Stat 状态信息 <a class=\"header-anchor\" href=\"#stat-%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF\">#</a></h2>\n<p>每个节点除了存储数据内容以外，还存储了数据节点本身的 一些状态信息，通过 get 命令可以获得状态信息的详细内容</p>\n<p><img src=\"http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/file/de1902d8d2ec4cf382eeabbbf6392943\" alt=\"image\"></p>\n<p><img src=\"http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/file/c074a72ef55344f0b4b6f07cec912c93\" alt=\"image\"></p>\n<h2 id=\"%E7%89%88%E6%9C%AC-%E4%BF%9D%E8%AF%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E5%AD%90%E6%80%A7\">版本-保证分布式数据原子性 <a class=\"header-anchor\" href=\"#%E7%89%88%E6%9C%AC-%E4%BF%9D%E8%AF%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E5%AD%90%E6%80%A7\">#</a></h2>\n<p>zookeeper 为数据节点引入了版本的概念，每个数据节点都有三 类版本信息，对数据节点任何更新操作都会引起版本号的变化。</p>\n<p>zookeeper 为数据节点引入了版本的概念，每个数据节点都有三 类版本信息，对数据节点任何更新操作都会引起版本号的变化。</p>\n<p>版本有点和我们经常使用的乐观锁类似。这里有两个概念说 一下，一个是乐观锁，一个是悲观锁</p>\n<p>悲观锁:是数据库中一种非常典型且非常严格的并发控制策 略。假如一个事务 A 正在对数据进行处理，那么在整个处理 过程中，都会将数据处于锁定状态，在这期间其他事务无法 对数据进行更新操作。</p>\n<p>乐观锁:乐观锁和悲观锁正好想法，它假定多个事务在处理 过程中不会彼此影响，因此在事务处理过程中不需要进行加 锁处理，如果多个事务对同一数据做更改，那么在更新请求 提交之前，每个事务都会首先检查当前事务读取数据后，是 否有其他事务对数据进行了修改。如果有修改，则回滚事务 再回到 zookeeper，version 属性就是用来实现乐观锁机制的 “写入校验”。</p>\n<h2 id=\"watcher\">Watcher <a class=\"header-anchor\" href=\"#watcher\">#</a></h2>\n<p>zookeeper 提供了分布式数据的发布/订阅功能，zookeeper 允许客户端向服务端注册一个 watcher 监听，当服务端的一 些指定事件触发了 watcher，那么服务端就会向客户端发送一个事件通知。\n值得注意的是，Watcher 通知是一次性的，即一旦触发一次 通知后，该 Watcher 就失效了，因此客户端需要反复注册 Watcher，即程序中在 process 里面又注册了 Watcher，否则， 将无法获取 c3 节点的创建而导致子节点变化的事件。</p>\n",
  "link": "/zh-cn/docs/7.分布式/zookeeper/1.基本概念.html",
  "meta": {}
}