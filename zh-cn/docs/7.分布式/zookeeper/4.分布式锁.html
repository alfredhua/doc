<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="4.分布式锁" />
	<meta name="description" content="4.分布式锁" />
	<!-- 网页标签标题 -->
	<title>4.分布式锁</title>
	<link rel="shortcut icon" href="/img/docsite.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a class="logo" href="/zh-cn/index.html"><span class="logo-normal">码农阿华| <span class="logo-desc">玩玩技术，说说产品</span></span></a><div class="search search-normal"><span class="icon-search"></span></div><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/begin.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/system/docs.png" class="front-img"/><span>文档</span><img src="/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>设计模式</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>设计原则<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/2.开闭原则.html" target="_self">开闭原则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/3.接口隔离原则.html" target="_self">接口隔离原则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/1.设计模式/1.单一职责.html" target="_self">单一职责</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>JAVA</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>目录<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dir/demo3.html" target="_self">示例3</a></li></ul></li></ul></li></ul></div><div class="doc-content markdown-body"><h2 id="%E7%94%A8-zookeeper-%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">用 zookeeper 来实现分布式锁 <a class="header-anchor" href="#%E7%94%A8-zookeeper-%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">#</a></h2>
<p>结合我们前面对 zookeeper 特性的分析和理解，我们可以 利用 zookeeper 节点的特性来实现独占锁，就是同级节点 的唯一性，多个进程往 zookeeper 的指定节点下创建一个 相同名称的节点，只有一个能成功，另外一个是创建失败; 创建失败的节点全部通过 zookeeper 的 watcher 机制来监听 zookeeper 这个子节点的变化，一旦监听到子节点的删 除事件，则再次触发所有进程去写锁;</p>
<p>这种实现方式很简单，但是会产生“惊群效应”，简单来说就 是如果存在许多的客户端在等待获取锁，当成功获取到锁 的进程释放该节点后，所有处于等待状态的客户端都会被 唤醒，这个时候 zookeeper 在短时间内发送大量子节点变 更事件给所有待获取锁的客户端，然后实际情况是只会有 一个客户端获得锁。如果在集群规模比较大的情况下，会 对 zookeeper 服务器的性能产生比较的影响。</p>
<h2 id="%E5%88%A9%E7%94%A8%E6%9C%89%E5%BA%8F%E8%8A%82%E7%82%B9%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">利用有序节点来实现分布式锁 <a class="header-anchor" href="#%E5%88%A9%E7%94%A8%E6%9C%89%E5%BA%8F%E8%8A%82%E7%82%B9%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">#</a></h2>
<p>我们可以通过有序节点来实现分布式锁，每个客户端都往指定的节点下注册一个临时有序节点，越早创建的节点， 节点的顺序编号就越小，那么我们可以判断子节点中最小 的节点设置为获得锁。如果自己的节点不是所有子节点中 最小的，意味着还没有获得锁。这个的实现和前面单节点 实现的差异性在于，每个节点只需要监听比自己小的节点， 当比自己小的节点删除以后，客户端会收到 watcher 事件， 此时再次判断自己的节点是不是所有子节点中最小的，如 果是则获得锁，否则就不断重复这个过程，这样就不会导 致羊群效应，因为每个客户端只需要监控一个节点。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
       CuratorFramework curatorFramework=<span class="hljs-keyword">null</span>;
       curatorFramework=CuratorFrameworkFactory.builder(). 
        connectString(ZkConfig.ZK_CONNECT_STR).sessionTimeoutMs(ZkConfig.ZK_SESSION_TIMEOUT).
        retryPolicy(<span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>,<span class="hljs-number">10</span>)).build(); 
        curatorFramework.start();
    <span class="hljs-keyword">final</span> InterProcessMutex lock=<span class="hljs-keyword">new</span> InterProcessMutex(curatorFramework ,<span class="hljs-string">"/locks"</span>);
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++){ <span class="hljs-keyword">new</span> Thread(()-&gt;{
        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"-&gt;尝试获取锁"</span>);
         <span class="hljs-keyword">try</span> {
                lock.acquire(); 
                System.out.println(Thread.<span class="hljs-function">currentT
                <span class="hljs-title">hread</span><span class="hljs-params">()</span>.<span class="hljs-title">getName</span><span class="hljs-params">()</span>+"-&gt;获得锁成功")</span>; 
            } <span class="hljs-keyword">catch</span> (Exception e){
                e.printStackTrace();
            }
            <span class="hljs-keyword">try</span> { 
                Thread.sleep(<span class="hljs-number">4000</span>);
                 lock.release();
                System.out.println(Thread.<span class="hljs-function">currentT <span class="hljs-title">hread</span><span class="hljs-params">()</span>.<span class="hljs-title">getName</span><span class="hljs-params">()</span>+"-&gt;释放锁成功")</span>;
         } <span class="hljs-keyword">catch</span> (Exception e)
                e.printStackTrace(); }
       },<span class="hljs-string">"t"</span>+i).start(); 
    }
}

</code></pre>
<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E5%91%A2%3F">什么是分布式一致性问题呢? <a class="header-anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E5%91%A2%3F">#</a></h2>
<p>简单来说，就是在一个分布式系统中，有多个节点，每个节点 都会提出一个请求，但是在所有节点中只能确定一个请求被通过。而这个通过是需要所有节 点达成一致的结果，所以所谓的一致性就是在提出的所有请求中能够选出最终一个确定请求。 并且这个请求选出来以后，所有的节点都要知道。这个就是典型的拜占庭将军问题</p>
<p>拜占庭将军问题说的是:拜占庭帝国军队的将军们必须通过投票达成一致来决定是否对某一 个国家发起进攻。但是这些将军在地里位置上是分开的，并且在将军中存在叛徒。叛徒可以 通过任意行动来达到自己的目标:</p>
<ol>
<li>欺骗某些将军采取进攻行动</li>
<li>促使一个不是所有将军都统一的决定，比如将军们本意是不希望进攻，但是叛徒可以促成 进攻行动</li>
<li>迷惑将军使得他们无法做出决定 如果叛徒达到了任意一个目标，那么这次行动必然失败。只有完全达成一致那么这次进攻才 可能胜利 拜占庭问题的本质是，由于网络通信存在不可靠的问题，也就是可能存在消息丢失，或者网 络延迟。如何在这样的背景下对某一个请求达成一致。 为了解决这个问题，很多人提出了各种协议，比如大名鼎鼎的 Paxos; 也就是说在不可信的 网络环境中，按照 paxos 这个协议就能够针对某个提议达成一致。 所以:分布式一致性的本质<strong>就是在分布式系统中，多个节点就某一个提议如何达成一致</strong></li>
</ol>
<p>这个和 Google Chubby 有什么关系呢</p>
<p>在 Google 有一个 GFS(google file system)，他们有一个需求就是要从多个 gfs server 中选出 一个 master server。这个就是典型的一致性问题，5 个分布在不同节点的 server，需要确定 一个 master server，而他们要达成的一致性目标是:确定某一个节点为 master，并且所有节 点要同意。
而 GFS 就是使用 chubby 来解决这个问题的。</p>
<p>实现原理是:所有的 server 通过 Chubby 提供的通信协议到 Chubby server 上创建同一个文 件，当然，最终只有一个 server 能够获准创建这个文件，这个 server 就成为了 master，它 会在这个文件中写入自己 的地址，这样其它的 server 通过读取这个文件就能知道被选出的 master 的地址</p>
</div></section><footer class="footer-container"><div class="footer-body"><div class="cols-container"><div class="col col-12"><h3>码农阿华</h3><p>联系邮箱：alfredhua@aliyun.com</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/demo1.html" target="_self">概览</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd></dl></div></div><div class="copyright"><span>CopyRight©2019 版权所有 码农阿华 京ICP备19044364号</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>