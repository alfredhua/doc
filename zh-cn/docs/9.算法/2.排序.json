{
  "filename": "2.排序.md",
  "__html": "<h2 id=\"%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">时间复杂度 <a class=\"header-anchor\" href=\"#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">#</a></h2>\n<p><img src=\"http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/file/4c47e605fc85475db4208ea2aae29cd3\" alt=\"image\"></p>\n<h2 id=\"%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-o(n%C2%B2)\">冒泡排序 O(n²) <a class=\"header-anchor\" href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-o(n%C2%B2)\">#</a></h2>\n<ul>\n<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个；</li>\n<li>重复步骤1~3，直到排序完成。</li>\n</ul>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BubbleSort</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IArraySort</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span>[] sort(<span class=\"hljs-keyword\">int</span>[] sourceArray) <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-comment\">// 对 arr 进行拷贝，不改变参数内容</span>\n        <span class=\"hljs-keyword\">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; arr.length; i++) {\n            <span class=\"hljs-comment\">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span>\n            <span class=\"hljs-keyword\">boolean</span> flag = <span class=\"hljs-keyword\">true</span>;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; arr.length - i; j++) {\n                <span class=\"hljs-keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"hljs-number\">1</span>]) {\n                    <span class=\"hljs-keyword\">int</span> tmp = arr[j];\n                    arr[j] = arr[j + <span class=\"hljs-number\">1</span>];\n                    arr[j + <span class=\"hljs-number\">1</span>] = tmp;\n                    flag = <span class=\"hljs-keyword\">false</span>;\n                }\n            }\n            <span class=\"hljs-keyword\">if</span> (flag) {\n                <span class=\"hljs-keyword\">break</span>;\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> arr;\n    }\n}\n</code></pre>\n<h2 id=\"%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8Fo(n%C2%B2)\">选择排序O(n²) <a class=\"header-anchor\" href=\"#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8Fo(n%C2%B2)\">#</a></h2>\n<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p>\n<p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>\n<p>重复第二步，直到所有元素均排序完毕。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SelectionSort</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IArraySort</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span>[] sort(<span class=\"hljs-keyword\">int</span>[] sourceArray) <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-keyword\">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n        <span class=\"hljs-comment\">// 总共要经过 N-1 轮比较</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length - <span class=\"hljs-number\">1</span>; i++) {\n            <span class=\"hljs-keyword\">int</span> min = i;\n            <span class=\"hljs-comment\">// 每轮需要比较的次数 N-i，0</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = i + <span class=\"hljs-number\">1</span>; j &lt; arr.length; j++) {\n                <span class=\"hljs-keyword\">if</span> (arr[j] &lt; arr[min]) {\n                    <span class=\"hljs-comment\">// 记录目前能找到的最小值元素的下标</span>\n                    min = j;\n                }\n            }\n            <span class=\"hljs-comment\">// 将找到的最小值和i位置所在的值进行交换</span>\n            <span class=\"hljs-keyword\">if</span> (i != min) {\n                <span class=\"hljs-keyword\">int</span> tmp = arr[i];\n                arr[i] = arr[min];\n                arr[min] = tmp;\n            }\n\n        }\n        <span class=\"hljs-keyword\">return</span> arr;\n    }\n}\n</code></pre>\n<h2 id=\"%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\">插入排序 <a class=\"header-anchor\" href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\">#</a></h2>\n<p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>\n<p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">InsertSort</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IArraySort</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span>[] sort(<span class=\"hljs-keyword\">int</span>[] sourceArray) <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-comment\">// 对 arr 进行拷贝，不改变参数内容</span>\n        <span class=\"hljs-keyword\">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n        <span class=\"hljs-comment\">// 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; arr.length; i++) {\n            <span class=\"hljs-comment\">// 记录要插入的数据</span>\n            <span class=\"hljs-keyword\">int</span> tmp = arr[i];\n            <span class=\"hljs-comment\">// 从已经排序的序列最右边的开始比较，找到比其小的数</span>\n            <span class=\"hljs-keyword\">int</span> j = i;\n            <span class=\"hljs-keyword\">while</span> (j &gt; <span class=\"hljs-number\">0</span> &amp;&amp; tmp &lt; arr[j - <span class=\"hljs-number\">1</span>]) {\n                arr[j] = arr[j - <span class=\"hljs-number\">1</span>];\n                j--;\n            }\n            <span class=\"hljs-comment\">// 存在比其小的数，插入</span>\n            <span class=\"hljs-keyword\">if</span> (j != i) {\n                arr[j] = tmp;\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> arr;\n    }\n}\n</code></pre>\n<h2 id=\"%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\">希尔排序 <a class=\"header-anchor\" href=\"#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\">#</a></h2>\n<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录&quot;基本有序&quot;时，再对全体记录进行依次直接插入排序。</p>\n<p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p>\n<p>按增量序列个数 k，对序列进行 k 趟排序；</p>\n<p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ShellSort</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IArraySort</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span>[] sort(<span class=\"hljs-keyword\">int</span>[] sourceArray) <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-comment\">// 对 arr 进行拷贝，不改变参数内容</span>\n        <span class=\"hljs-keyword\">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n        <span class=\"hljs-keyword\">int</span> gap = <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">while</span> (gap &lt; arr.length) {\n            gap = gap * <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">1</span>;\n        }\n        <span class=\"hljs-keyword\">while</span> (gap &gt; <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = gap; i &lt; arr.length; i++) {\n                <span class=\"hljs-keyword\">int</span> tmp = arr[i];\n                <span class=\"hljs-keyword\">int</span> j = i - gap;\n                <span class=\"hljs-keyword\">while</span> (j &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; arr[j] &gt; tmp) {\n                    arr[j + gap] = arr[j];\n                    j -= gap;\n                }\n                arr[j + gap] = tmp;\n            }\n            gap = (<span class=\"hljs-keyword\">int</span>) Math.floor(gap / <span class=\"hljs-number\">3</span>);\n        }\n\n        <span class=\"hljs-keyword\">return</span> arr;\n    }\n}\n</code></pre>\n<h2 id=\"%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\">归并排序 <a class=\"header-anchor\" href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\">#</a></h2>\n<ol>\n<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>\n<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>\n<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>\n<li>重复步骤 3 直到某一指针达到序列尾；</li>\n<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MergeSort</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IArraySort</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span>[] sort(<span class=\"hljs-keyword\">int</span>[] sourceArray) <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-comment\">// 对 arr 进行拷贝，不改变参数内容</span>\n        <span class=\"hljs-keyword\">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n        <span class=\"hljs-keyword\">if</span> (arr.length &lt; <span class=\"hljs-number\">2</span>) {\n            <span class=\"hljs-keyword\">return</span> arr;\n        }\n        <span class=\"hljs-keyword\">int</span> middle = (<span class=\"hljs-keyword\">int</span>) Math.floor(arr.length / <span class=\"hljs-number\">2</span>);\n        <span class=\"hljs-keyword\">int</span>[] left = Arrays.copyOfRange(arr, <span class=\"hljs-number\">0</span>, middle);\n        <span class=\"hljs-keyword\">int</span>[] right = Arrays.copyOfRange(arr, middle, arr.length);\n        <span class=\"hljs-keyword\">return</span> merge(sort(left), sort(right));\n    }\n\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">int</span>[] merge(<span class=\"hljs-keyword\">int</span>[] left, <span class=\"hljs-keyword\">int</span>[] right) {\n        <span class=\"hljs-keyword\">int</span>[] result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[left.length + right.length];\n        <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">while</span> (left.length &gt; <span class=\"hljs-number\">0</span> &amp;&amp; right.length &gt; <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">if</span> (left[<span class=\"hljs-number\">0</span>] &lt;= right[<span class=\"hljs-number\">0</span>]) {\n                result[i++] = left[<span class=\"hljs-number\">0</span>];\n                left = Arrays.copyOfRange(left, <span class=\"hljs-number\">1</span>, left.length);\n            } <span class=\"hljs-keyword\">else</span> {\n                result[i++] = right[<span class=\"hljs-number\">0</span>];\n                right = Arrays.copyOfRange(right, <span class=\"hljs-number\">1</span>, right.length);\n            }\n        }\n        <span class=\"hljs-keyword\">while</span> (left.length &gt; <span class=\"hljs-number\">0</span>) {\n            result[i++] = left[<span class=\"hljs-number\">0</span>];\n            left = Arrays.copyOfRange(left, <span class=\"hljs-number\">1</span>, left.length);\n        }\n        <span class=\"hljs-keyword\">while</span> (right.length &gt; <span class=\"hljs-number\">0</span>) {\n            result[i++] = right[<span class=\"hljs-number\">0</span>];\n            right = Arrays.copyOfRange(right, <span class=\"hljs-number\">1</span>, right.length);\n        }\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n\n}\n</code></pre>\n<h2 id=\"%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-o(-n*log-n-)\">快速排序 O( n*log n ) <a class=\"header-anchor\" href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-o(-n*log-n-)\">#</a></h2>\n<ol>\n<li>从数列中挑出一个元素，称为 &quot;基准&quot;（pivot）;</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">QuickSort</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IArraySort</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span>[] sort(<span class=\"hljs-keyword\">int</span>[] sourceArray) <span class=\"hljs-keyword\">throws</span> Exception {\n        <span class=\"hljs-comment\">// 对 arr 进行拷贝，不改变参数内容</span>\n        <span class=\"hljs-keyword\">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        <span class=\"hljs-keyword\">return</span> quickSort(arr, <span class=\"hljs-number\">0</span>, arr.length - <span class=\"hljs-number\">1</span>);\n    }\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span>[] quickSort(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> left, <span class=\"hljs-keyword\">int</span> right) {\n        <span class=\"hljs-keyword\">if</span> (left &lt; right) {\n            <span class=\"hljs-keyword\">int</span> partitionIndex = partition(arr, left, right);\n            quickSort(arr, left, partitionIndex - <span class=\"hljs-number\">1</span>);\n            quickSort(arr, partitionIndex + <span class=\"hljs-number\">1</span>, right);\n        }\n        <span class=\"hljs-keyword\">return</span> arr;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">partition</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> left, <span class=\"hljs-keyword\">int</span> right)</span> </span>{\n        <span class=\"hljs-comment\">// 设定基准值（pivot）</span>\n        <span class=\"hljs-keyword\">int</span> pivot = left;\n        <span class=\"hljs-keyword\">int</span> index = pivot + <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = index; i &lt;= right; i++) {\n            <span class=\"hljs-keyword\">if</span> (arr[i] &lt; arr[pivot]) {\n                swap(arr, i, index);\n                index++;\n            }\n        }\n        swap(arr, pivot, index - <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-keyword\">return</span> index - <span class=\"hljs-number\">1</span>;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">swap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> i, <span class=\"hljs-keyword\">int</span> j)</span> </span>{\n        <span class=\"hljs-keyword\">int</span> temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n}\n</code></pre>\n",
  "link": "/zh-cn/docs/9.算法/2.排序.html",
  "meta": {}
}