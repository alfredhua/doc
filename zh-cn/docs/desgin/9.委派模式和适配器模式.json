{
  "filename": "9.委派模式和适配器模式.md",
  "__html": "<p>委派模式：</p>\n<p>委派模式注重的是结果：</p>\n<p>核心是：就是分发、调度、派遣</p>\n<p>BOSS ----&gt; leader ----&gt;target</p>\n<pre><code>public interface ITarget {\n\n     void doing(String com);\n}\n\npublic class TargetA implements ITarget {\n\n    @Override\n    public void doing(String com) {\n        System.out.println(&quot;我是员工A，我在做&quot;+com+&quot;工作&quot;);\n    }\n}\n\npublic class TargetB implements ITarget {\n\n    @Override\n    public void doing(String com) {\n        System.out.println(&quot;我是员工B，我在做&quot;+com+&quot;工作&quot;);\n    }\n}\n\npublic class Leader {\n\n    private Map&lt;String,ITarget&gt; doMap=new HashMap&lt;&gt;();\n\n    public Leader() {\n        doMap.put(&quot;加密&quot;, new TargetA());\n        doMap.put(&quot;登录&quot;, new TargetB());\n    }\n    //自己不干活，让别人干，自己负责选择让谁去干。\n    public void doing(String com){\n        doMap.get(com).doing(com);\n\n    }\n\n}\n\npublic class Boss {\n\n    //客户请求（Boss）、委派者（Leader）、被被委派者（Target）\n    //委派者要持有被委派者的引用\n    //代理模式注重的是过程， 委派模式注重的是结果\n    //策略模式注重是可扩展（外部扩展），委派模式注重内部的灵活和复用\n    //委派的核心：就是分发、调度、派遣\n\n    //委派模式：就是静态代理和策略模式一种特殊的组合\n    public static void main(String[] args){\n        new Leader().doing(&quot;加密&quot;);\n    }\n\n}\n\n\n</code></pre>\n<p>适配器模式：</p>\n<p>注重的是兼容。稳定的代码不去修改，直接继承下来。</p>\n<pre><code>public interface SignService {\n\n    void sign();\n\n    void login();\n}\n\npublic class SignServiceImpl implements SignService {\n    @Override\n    public void sign() {\n        System.out.println(&quot;注册&quot;);\n    }\n\n    @Override\n    public void login() {\n        System.out.println(&quot;登录&quot;);\n    }\n}\n\npublic class QQSignService extends SignServiceImpl {\n\n    public void qqSign(){\n        //qq注册\n        super.sign();\n    }\n}\n\npublic class SignTest {\n\n    public static void main(String[] args){\n        QQSignService qqSignService = new QQSignService();\n        qqSignService.qqSign();\n    }\n}\n</code></pre>\n",
  "link": "/zh-cn/docs/desgin/9.委派模式和适配器模式.html",
  "meta": {}
}