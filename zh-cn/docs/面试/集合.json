{
  "filename": "集合.md",
  "__html": "<h2 id=\"%E5%B8%B8%E7%94%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\">常用的集合类有哪些？ <a class=\"header-anchor\" href=\"#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\">#</a></h2>\n<p>Collection接口的子接口包括：Set接口和List接口</p>\n<ul>\n<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li>\n<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>\n<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>\n</ul>\n<h2 id=\"%E6%80%8E%E4%B9%88%E7%A1%AE%E4%BF%9D%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E4%B8%8D%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9%EF%BC%9F\">怎么确保一个集合不能被修改？ <a class=\"header-anchor\" href=\"#%E6%80%8E%E4%B9%88%E7%A1%AE%E4%BF%9D%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E4%B8%8D%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9%EF%BC%9F\">#</a></h2>\n<p>可以使用 Collections.unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>\n<pre><code class=\"language-java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\nlist.add(<span class=\"hljs-string\">\"x\"</span>);\nCollection&lt;String&gt; clist = Collections.unmodifiableCollection(list);\nclist.add(<span class=\"hljs-string\">\"y\"</span>); <span class=\"hljs-comment\">// 运行时此行报错</span>\nSystem.out.println(list. size());\n</code></pre>\n<h2 id=\"set%EF%BC%8Clist%EF%BC%8Cqueue\">Set，List，Queue <a class=\"header-anchor\" href=\"#set%EF%BC%8Clist%EF%BC%8Cqueue\">#</a></h2>\n<ol>\n<li>Set</li>\n</ol>\n<ul>\n<li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>\n<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>\n<li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</li>\n</ul>\n<ol start=\"2\">\n<li>List</li>\n</ol>\n<ul>\n<li>ArrayList：基于动态数组实现，支持随机访问。</li>\n<li>Vector：和 ArrayList 类似，但它是线程安全的。</li>\n<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>\n</ul>\n<ol start=\"3\">\n<li>Queue</li>\n</ol>\n<ul>\n<li>LinkedList：可以用它来实现双向队列。</li>\n<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>\n</ul>\n<h2 id=\"%E8%AF%B4%E4%B8%80%E4%B8%8B-hashset-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F\">说一下 HashSet 的实现原理？ <a class=\"header-anchor\" href=\"#%E8%AF%B4%E4%B8%80%E4%B8%8B-hashset-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F\">#</a></h2>\n<p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为present，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>\n<h2 id=\"hashset%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D%EF%BC%9Fhashset%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E7%9A%84%EF%BC%9F\">HashSet如何检查重复？HashSet是如何保证数据不可重复的？ <a class=\"header-anchor\" href=\"#hashset%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D%EF%BC%9Fhashset%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E7%9A%84%EF%BC%9F\">#</a></h2>\n<ul>\n<li>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。</li>\n<li>HashSet 中的add ()方法会使用HashMap 的put()方法。</li>\n<li>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</li>\n</ul>\n<p>以下是HashSet 部分源码：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Object PRESENT = <span class=\"hljs-keyword\">new</span> Object();\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">transient</span> HashMap&lt;E,Object&gt; map;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">HashSet</span><span class=\"hljs-params\">()</span> </span>{\n    map = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(E e)</span> </span>{\n    <span class=\"hljs-comment\">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span>\n\t<span class=\"hljs-keyword\">return</span> map.put(e, PRESENT)==<span class=\"hljs-keyword\">null</span>;\n}\n\n</code></pre>\n<h2 id=\"map\">Map <a class=\"header-anchor\" href=\"#map\">#</a></h2>\n<ul>\n<li>TreeMap：基于红黑树实现。</li>\n<li>HashMap：基于哈希表实现。</li>\n<li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>\n<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>\n</ul>\n<h2 id=\"arraylist\">ArrayList <a class=\"header-anchor\" href=\"#arraylist\">#</a></h2>\n<p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ArrayList</span>&lt;<span class=\"hljs-title\">E</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractList</span>&lt;<span class=\"hljs-title\">E</span>&gt;\n        <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">List</span>&lt;<span class=\"hljs-title\">E</span>&gt;, <span class=\"hljs-title\">RandomAccess</span>, <span class=\"hljs-title\">Cloneable</span>, <span class=\"hljs-title\">java</span>.<span class=\"hljs-title\">io</span>.<span class=\"hljs-title\">Serializable</span>\n\n</span></code></pre>\n<p>初始化默认大小是10。</p>\n<ul>\n<li>\n<p>扩容</p>\n<p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p>\n<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>\n</li>\n<li>\n<p>删除</p>\n<p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> E <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> index)</span> </span>{\n    rangeCheck(index);\n    modCount++;\n    E oldValue = elementData(index);\n    <span class=\"hljs-keyword\">int</span> numMoved = size - index - <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">if</span> (numMoved &gt; <span class=\"hljs-number\">0</span>)\n        System.arraycopy(elementData, index+<span class=\"hljs-number\">1</span>, elementData, index, numMoved);\n    elementData[--size] = <span class=\"hljs-keyword\">null</span>; <span class=\"hljs-comment\">// clear to let GC do its work</span>\n    <span class=\"hljs-keyword\">return</span> oldValue;\n}\n</code></pre>\n</li>\n<li>\n<p>序列化</p>\n<p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p>\n<p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p>\n<p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p>\n</li>\n</ul>\n<h2 id=\"vector\">Vector <a class=\"header-anchor\" href=\"#vector\">#</a></h2>\n<ul>\n<li>\n<p>扩容：</p>\n<p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p>\n</li>\n</ul>\n<h2 id=\"vector%E4%B8%8Earraylist-%E7%9A%84%E6%AF%94%E8%BE%83\">Vector与ArrayList 的比较 <a class=\"header-anchor\" href=\"#vector%E4%B8%8Earraylist-%E7%9A%84%E6%AF%94%E8%BE%83\">#</a></h2>\n<ul>\n<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>\n<li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li>\n</ul>\n<h2 id=\"linkedlist-%E4%B8%8E-arraylist-%E7%9A%84%E6%AF%94%E8%BE%83\">LinkedList 与 ArrayList 的比较 <a class=\"header-anchor\" href=\"#linkedlist-%E4%B8%8E-arraylist-%E7%9A%84%E6%AF%94%E8%BE%83\">#</a></h2>\n<p>​\tArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：</p>\n<ul>\n<li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；</li>\n<li>链表不支持随机访问，但插入删除只需要改变指针。</li>\n</ul>\n<h2 id=\"hashmap\">HashMap <a class=\"header-anchor\" href=\"#hashmap\">#</a></h2>\n<ul>\n<li>\n<p>put</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> V <span class=\"hljs-title\">put</span><span class=\"hljs-params\">(K key, V value)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> putVal(hash(key), key, value, <span class=\"hljs-keyword\">false</span>, <span class=\"hljs-keyword\">true</span>);\n}\n</code></pre>\n<p>hash方法，计算出该存放的在数组中的位置（除以16求余道理一样）：</p>\n<p>hashCode() 方法用于返回字符串的哈希码。</p>\n<p>字符串对象的哈希码根据以下公式计算：</p>\n<pre><code class=\"language-java\">s[<span class=\"hljs-number\">0</span>]*<span class=\"hljs-number\">31</span>^(n-<span class=\"hljs-number\">1</span>) + s[<span class=\"hljs-number\">1</span>]*<span class=\"hljs-number\">31</span>^(n-<span class=\"hljs-number\">2</span>) + ... + s[n-<span class=\"hljs-number\">1</span>]\n</code></pre>\n<p>使用 int 算法，这里 s[i] 是字符串的第 i 个字符，n 是字符串的长度，^ 表示求幂。空字符串的哈希值为 0。</p>\n<p>h无符号位右移动 16位，相当于获取高16位，低16位舍去，</p>\n<p>与h进行异或运算，则一定获取的是一个32位的数字。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">//h无符号位右移动 16位与h进行异或运算</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">hash</span><span class=\"hljs-params\">(Object key)</span> </span>{\n    <span class=\"hljs-keyword\">int</span> h;\n    <span class=\"hljs-keyword\">return</span> (key == <span class=\"hljs-keyword\">null</span>) ? <span class=\"hljs-number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"hljs-number\">16</span>);\n}\n</code></pre>\n<p>在get和put的过程中，计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示:</p>\n<p>高16bit不变，低16bit和高16bit做了一个异或。</p>\n<p><img src=\"http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/0b08089dcff640b29532b9e639d3a140.png\" alt=\"image\"></p>\n</li>\n</ul>\n<h2 id=\"%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E7%BA%A2%E9%BB%91%E6%A0%91%E9%98%88%E5%80%BC%E6%97%B68%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BD%AC%E6%8D%A2%E5%88%97%E8%A1%A8%E9%98%88%E5%80%BC%E6%98%AF6%E3%80%82%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F\">列表转换红黑树阈值时8，红黑树转换列表阈值是6。为什么？ <a class=\"header-anchor\" href=\"#%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E7%BA%A2%E9%BB%91%E6%A0%91%E9%98%88%E5%80%BC%E6%97%B68%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BD%AC%E6%8D%A2%E5%88%97%E8%A1%A8%E9%98%88%E5%80%BC%E6%98%AF6%E3%80%82%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F\">#</a></h2>\n<p>通过源码我们得知HashMap源码作者通过泊松分布算出，当桶中结点个数为8时，出现的几率是亿分之6的，因此常见的情况是桶中个数小于8的情况，此时链表的查询性能和红黑树相差不多，因为转化为树还需要时间和空间，所以此时没有转化成树的必要。</p>\n<p>既然个数为8时发生的几率这么低，我们为什么还要当链表个数大于8时来树化来优化这几乎不会发生的场景呢？</p>\n<p>首先我们要知道亿分之6这个几乎不可能的概率是建立在什么情况下的 答案是：建立在良好的hash算法情况下，例如String，Integer等包装类的hash算法、如果一旦发生桶中元素大于8，说明是不正常情况，可能采用了冲突较大的hash算法，此时桶中个数出现超过8的概率是非常大的，可能有n个key冲突在同一个桶中，此时再看链表的平均查询复杂度和红黑树的时间复杂度，就知道为什么要引入红黑树了，</p>\n<p>举个例子，若hash算法写的不好，一个桶中冲突1024个key，使用链表平均需要查询512次，但是红黑树仅仅10次，红黑树的引入保证了在大量hash冲突的情况下，HashMap还具有良好的查询性能。</p>\n<p>红黑树的时间复杂度：</p>\n<p>红黑树的插入、删除和遍历的最坏时间复杂度都是log(n)，</p>\n<p>列表的时间复杂度：n</p>\n<h2 id=\"hashmap%E7%9A%84%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84%EF%BC%8C%E6%89%A9%E5%AE%B9%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F\">hashMap的扩容过程是怎么样子的，扩容的大小是什么样的？ <a class=\"header-anchor\" href=\"#hashmap%E7%9A%84%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84%EF%BC%8C%E6%89%A9%E5%AE%B9%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F\">#</a></h2>\n<p>hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小 x loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16 x 0.75=12的时候，就把数组的大小扩展为2 x 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。</p>\n<h2 id=\"hash%E7%9A%84%E5%86%B2%E7%AA%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F\">hash的冲突是如何处理的？ <a class=\"header-anchor\" href=\"#hash%E7%9A%84%E5%86%B2%E7%AA%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F\">#</a></h2>\n<p>如果persons.put(“1”,”jack”);persons.put(“2”,”john”); 同时计算到的hash值都为123，那么jack先放在第一列的第一个位置Node-jack，persons.put(“2”,”john”);执行时会将Node-jack的next(Node) = Node(john)，Jack的下个节点将指向Node(john)。</p>\n<p>那么取的时候呢，persons.get(“2”)，这个时候取得的hash值是123，即table[123]，这时table[123]其实是Node-jack，Key值不相等，取Node-jack的next下个Node，即Node-John，这时Key值相等了，然后返回对应的person。</p>\n<h2 id=\"hashmap%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BC%9A%E5%BC%95%E5%8F%91%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F%EF%BC%88%E5%88%97%E8%A1%A8%E7%8E%AF%E8%B7%AF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E7%94%BB%E5%9B%BE%E8%AF%B4%E6%98%8E%EF%BC%89\">hashMap的多线程的环境下会引发什么样的情况？（列表环路，为什么？画图说明） <a class=\"header-anchor\" href=\"#hashmap%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BC%9A%E5%BC%95%E5%8F%91%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F%EF%BC%88%E5%88%97%E8%A1%A8%E7%8E%AF%E8%B7%AF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E7%94%BB%E5%9B%BE%E8%AF%B4%E6%98%8E%EF%BC%89\">#</a></h2>\n<p>1.put的时候导致的多线程数据不一致。</p>\n<p>2.多线程put后可能导致get死循环：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">transfer</span><span class=\"hljs-params\">(Entry[] newTable)</span> </span>{\n     Entry[] src = table;                   <span class=\"hljs-comment\">//src引用了旧的Entry数组</span>\n     <span class=\"hljs-keyword\">int</span> newCapacity = newTable.length;\n     <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; src.length; j++) { <span class=\"hljs-comment\">//遍历旧的Entry数组</span>\n         Entry&lt;K,V&gt; e = src[j];             <span class=\"hljs-comment\">//取得旧Entry数组的每个元素</span>\n         <span class=\"hljs-keyword\">if</span> (e != <span class=\"hljs-keyword\">null</span>) {\n             src[j] = <span class=\"hljs-keyword\">null</span>;<span class=\"hljs-comment\">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span>\n             <span class=\"hljs-keyword\">do</span> {\n                 Entry&lt;K,V&gt; next = e.next;\n                 <span class=\"hljs-keyword\">int</span> i = indexFor(e.hash, newCapacity); <span class=\"hljs-comment\">//！！重新计算每个元素在数组中的位置</span>\n                 e.next = newTable[i]; <span class=\"hljs-comment\">//标记[1]</span>\n                 newTable[i] = e;      <span class=\"hljs-comment\">//将元素放在数组上</span>\n                 e = next;             <span class=\"hljs-comment\">//访问下一个Entry链上的元素</span>\n             } <span class=\"hljs-keyword\">while</span> (e != <span class=\"hljs-keyword\">null</span>);\n         }\n     }\n }\n</code></pre>\n<ol>\n<li>\n<p>对索引数组中的元素遍历</p>\n</li>\n<li>\n<p>对链表上的每一个节点遍历：用 next 取得要转移那个元素的下一个，将 e 转移到新 Hash 表的头部，使用头插法插入节点。</p>\n</li>\n<li>\n<p>循环2，直到链表节点全部转移</p>\n</li>\n<li>\n<p>循环1，直到所有索引数组全部转移</p>\n</li>\n</ol>\n<p>经过这几步，我们会发现转移的时候是逆序的。假如转移前链表顺序是1-&gt;2-&gt;3，那么转移后就会变成3-&gt;2-&gt;1。这时候就有点头绪了，死锁问题不就是因为1-&gt;2的同时2-&gt;1造成的吗？所以，HashMap 的死锁问题就出在这个transfer()函数上。</p>\n<h2 id=\"hashmap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E4%B8%BA%E4%BC%9A%E5%A6%82%E4%BD%95%EF%BC%9F\">hashMap的初始化大小是多少？如果自定义初始化大小为会如何？ <a class=\"header-anchor\" href=\"#hashmap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E4%B8%BA%E4%BC%9A%E5%A6%82%E4%BD%95%EF%BC%9F\">#</a></h2>\n<p>初始化大小是：16，</p>\n<p>最大定义是2的30次方。超过这个大小则为2的30次方，</p>\n<p>自定义为3 的话，则初始化大小为4，为最近的2的n次方。</p>\n<p>如果HashMap需要放置1024个元素，由于没有设置容量初始大小，随着元素不断增加，容量7次被迫扩大，resize需要重建hash表，严重影响性能。</p>\n<h2 id=\"%E4%B8%BA%E4%BB%80%E4%B9%88hashmap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E4%BC%9A%E8%AE%BE%E7%BD%AE%E4%B8%BA2%E7%9A%84n%E6%AC%A1%E6%96%B9%EF%BC%9F\">为什么hashMap的初始化大小会设置为2的n次方？ <a class=\"header-anchor\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88hashmap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E4%BC%9A%E8%AE%BE%E7%BD%AE%E4%B8%BA2%E7%9A%84n%E6%AC%A1%E6%96%B9%EF%BC%9F\">#</a></h2>\n<p>为了减少hash碰撞，因为tab的存放位置是(n - 1) &amp; hash，2的n次方发生hash碰撞的几率要小，能均匀分布。</p>\n<p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的 范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应 用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之 前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算 方法是“ (n - 1) &amp; hash ”。(n代表数组长度)。这也就解释了 HashMap 的长度为什么是2的幂次方。</p>\n<h2 id=\"linkedhashmap\">LinkedHashMap <a class=\"header-anchor\" href=\"#linkedhashmap\">#</a></h2>\n",
  "link": "/zh-cn/docs/面试/集合.html",
  "meta": {}
}